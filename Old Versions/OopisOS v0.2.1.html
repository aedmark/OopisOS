<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOs v.0.2.1</title> <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
        }

        .input-line { display: flex; align-items: center; width: 100%; }
        .prompt-user { margin-right: 2px; color: #7fdbff; }
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #visual-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        #input-before-cursor, #input-after-cursor {
            white-space: pre;
            display: inline-block;
        }
        .cursor {
            width: 10px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #hidden-input { position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .file-item { }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }

        /* Editor specific styles */
        #editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #editor-textarea {
            flex-grow: 1;
            width: 100%;
            background-color: #0c0c0c;
            color: #00dd00;
            border: 1px solid #222;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            resize: none;
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 4px;
            overflow-y: auto;
        }
        #editor-instructions {
            padding: 5px 0;
            font-size: 0.9em;
            text-align: center;
            color: #aaa;
            flex-shrink: 0;
        }
        .diag-output-block {
        }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line">
                <span id="prompt-user" class="prompt-user"></span>
                <span class="prompt-separator">@</span>
                <span id="prompt-host" class="prompt-host">OopisOs</span>
                <span class="prompt-separator">:</span>
                <span id="prompt-path" class="prompt-path"></span>
                <span class="prompt-char">&gt;</span>
                <div id="visual-input-container">
                    <span id="input-before-cursor"></span>
                    <div class="cursor"></div>
                    <span id="input-after-cursor"></span>
                </div>
            </div>
            <input type="text" id="hidden-input" autofocus autocapitalize="none" autocorrect="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const terminalDiv = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const standardInputLineDiv = terminalDiv.querySelector('.input-line');
        const inputBeforeCursorSpan = document.getElementById('input-before-cursor');
        const inputAfterCursorSpan = document.getElementById('input-after-cursor');
        const hiddenInput = document.getElementById('hidden-input');
        const promptUserSpan = document.getElementById('prompt-user');
        const promptPathSpan = document.getElementById('prompt-path');
        const promptHostSpan = document.getElementById('prompt-host');

        // --- Constants ---
        const USER_CREDENTIALS_KEY = 'oopisOsUserCredentials';
        const USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsUserTerminalState_';
        const MANUAL_USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsManualUserTerminalState_';
        const DEFAULT_USER = "Guest";
        const OS_NAME = "OopisOs";
        const OS_VERSION = "0.2.1.0"; // Updated OS Version
        const MAX_HISTORY_SIZE = 50;

        // IndexedDB Constants
        const DB_NAME = "OopisOsDB";
        const DB_VERSION = 1;
        const FS_STORE_NAME = "FileSystemsStore";
        let db;

        // --- CSS Classes ---
        const CSS_ERROR_MSG = 'error-message';
        const CSS_SUCCESS_MSG = 'success-message';
        const CSS_CONSOLE_LOG_MSG = 'console-log-message';
        const CSS_WARNING_MSG = 'warning-message';
        const CSS_DIR_ITEM = 'directory-item';
        const CSS_FILE_ITEM = 'file-item';
        const CSS_HELP_CMD_NAME = 'help-command-name';
        const CSS_HELP_DESC = 'help-description';
        const CSS_OUTPUT_LINE = 'output-line';
        const CSS_MAN_SECTION_TITLE = 'man-section-title';
        const CSS_MAN_SECTION_CONTENT = 'man-section-content';
        const CSS_MAN_EXAMPLE = 'man-example';
        const CSS_SYSMON_LABEL = 'sysmon-label';

        // --- Application State ---
        let fsData = {};
        let currentPath = '/';
        let currentUser = DEFAULT_USER;
        let awaitingResetConfirmation = false;
        let awaitingLoadstateConfirmation = false;
        let awaitingRmConfirmation = false;
        let itemToRemovePath = null;
        let pendingManualStateToLoad = null;
        let commandHistory = [];
        let historyIndex = 0;
        let lastCommandFailed = false;
        let isPasswordInputActive = false;
        let passwordMaskStartIndex = -1;
        let isEditingFile = false;
        let editingFilePath = null;
        let editorWrapperDiv = null;
        let editorTextareaElement = null;
        let editorInstructionsDiv = null;
        let isRunningDiag = false;


        // --- Helper to format console arguments ---
        function formatConsoleArgs(args) {
            return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
        }

        // --- Output Management ---
        function appendToOutput(text, isError = false, typeClass = null) {
            if (isEditingFile && typeClass !== 'editor-message' && typeClass !== 'diag-output') return;
            const newLine = document.createElement('div');
            newLine.classList.add(CSS_OUTPUT_LINE);
            if (typeClass) newLine.classList.add(typeClass);
            if (isError && !typeClass) newLine.classList.add(CSS_ERROR_MSG);
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
            outputDiv.scrollTop = outputDiv.scrollHeight;
            if(isError) lastCommandFailed = true;
        }
        function appendHtmlToOutput(htmlContent) {
             if (isEditingFile) return;
             const blockDiv = document.createElement('div');
             blockDiv.innerHTML = htmlContent;
             outputDiv.appendChild(blockDiv);
             outputDiv.scrollTop = outputDiv.scrollHeight;
        }
        function appendStyledOutput(label, value) {
            if (isEditingFile) return;
            const line = document.createElement('div');
            line.classList.add(CSS_OUTPUT_LINE);
            const labelSpan = document.createElement('span');
            labelSpan.classList.add(CSS_SYSMON_LABEL);
            labelSpan.textContent = label.padEnd(20, ' ');
            const valueSpan = document.createElement('span');
            valueSpan.textContent = value;
            line.appendChild(labelSpan);
            line.appendChild(valueSpan);
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        // --- Console Output Redirection ---
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        console.log = (...args) => { if (!isEditingFile) appendToOutput(`LOG: ${formatConsoleArgs(args)}`, false, CSS_CONSOLE_LOG_MSG); originalConsoleLog.apply(console, args); };
        console.warn = (...args) => { if (!isEditingFile) appendToOutput(`WARN: ${formatConsoleArgs(args)}`, false, CSS_WARNING_MSG); originalConsoleWarn.apply(console, args); };
        console.error = (...args) => { if (!isEditingFile) appendToOutput(`ERROR: ${formatConsoleArgs(args)}`, true, CSS_ERROR_MSG); originalConsoleError.apply(console, args); };

        // --- Unified LocalStorage Helpers (for non-filesystem data) ---
        function loadJSONFromStorage(key, itemName, defaultValue = null) {
            try {
                const storedValue = localStorage.getItem(key);
                if (storedValue) return JSON.parse(storedValue);
            } catch (e) {
                if(!isRunningDiag) appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, true, CSS_WARNING_MSG);
            }
            return defaultValue;
        }
        function saveJSONToStorage(key, data, itemName) {
            try { localStorage.setItem(key, JSON.stringify(data)); return true; }
            catch (e) {
                if(!isRunningDiag) appendToOutput(`Critical Error: Could not save ${itemName} for '${key}'.`, true, CSS_ERROR_MSG);
            }
            return false;
        }

        // --- IndexedDB Initialization ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(FS_STORE_NAME)) {
                        dbInstance.createObjectStore(FS_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    if (!isRunningDiag && !window.diagInitialized) {
                        appendToOutput("FileSystem DB initialized.", false, CSS_CONSOLE_LOG_MSG);
                        window.diagInitialized = true;
                    }
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("Database error: ", event.target.error);
                    appendToOutput("Critical Error: Could not initialize FileSystem DB.", true, CSS_ERROR_MSG);
                    reject(event.target.error);
                };
            });
        }

        // --- Filesystem Management (IndexedDB) ---
        function getFileSystemKey(user) { return `fs_${user}`; }

        async function initializeFileSystem(user = currentUser) {
            fsData = { '/': { type: 'directory', children: {} } };
            await saveFileSystemData(user);
        }

        async function saveFileSystemData(user = currentUser) {
            if (!db) {
                if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for saving.", true, CSS_ERROR_MSG);
                return Promise.reject("DB not initialized");
            }
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.put({ id: getFileSystemKey(user), data: deepCopyNode(fsData) });
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error saving FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user}.`, true, CSS_ERROR_MSG);
                        reject(event.target.error);
                    };
                } catch (e) {
                    console.error(`Error initiating save transaction for ${user}:`, e);
                    if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user} (transaction error).`, true, CSS_ERROR_MSG);
                    reject(e);
                }
            });
        }

        async function loadFileSystemData(user) {
            if (!db) {
                 if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for loading.", true, CSS_ERROR_MSG);
                fsData = { '/': { type: 'directory', children: {} } };
                return Promise.reject("DB not initialized");
            }
            return new Promise(async (resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.get(getFileSystemKey(user));
                    request.onsuccess = async (event) => {
                        const result = event.target.result;
                        if (result && result.data && result.data['/']?.type === 'directory') {
                            fsData = result.data;
                        } else {
                            if (!isRunningDiag) appendToOutput(result ? `Invalid FS for ${user}. Reinitializing.` : `No FS for ${user}. Initializing.`, false, result ? CSS_WARNING_MSG : CSS_CONSOLE_LOG_MSG);
                            await initializeFileSystem(user);
                        }
                        resolve();
                    };
                    request.onerror = async (event) => {
                        console.error(`Error loading FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted or unavailable. Initializing new FS.`, false, CSS_WARNING_MSG);
                        await initializeFileSystem(user);
                        reject(event.target.error);
                    };
                } catch (e) {
                     console.error(`Error initiating load transaction for ${user}:`, e);
                     if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted (transaction error). Initializing new FS.`, false, CSS_WARNING_MSG);
                     await initializeFileSystem(user);
                     reject(e);
                }
            });
        }

        async function deleteFileSystemData(user) {
            if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(FS_STORE_NAME);
                const request = store.delete(getFileSystemKey(user));
                request.onsuccess = () => resolve(true);
                request.onerror = (event) => {
                    console.error(`Error deleting FS for ${user}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // --- Visual Input Update (unchanged) ---
        function updateVisualInput() { /* ... */
            const inputValue = hiddenInput.value;
            const cursorPos = hiddenInput.selectionStart;
            let visualString = inputValue;
            if (isPasswordInputActive && passwordMaskStartIndex !== -1) {
                if (inputValue.length > passwordMaskStartIndex) {
                    const prefix = inputValue.substring(0, passwordMaskStartIndex);
                    const suffixToMask = inputValue.substring(passwordMaskStartIndex);
                    visualString = prefix + '*'.repeat(suffixToMask.length);
                }
            }
            inputBeforeCursorSpan.textContent = visualString.substring(0, cursorPos);
            inputAfterCursorSpan.textContent = visualString.substring(cursorPos);
        }

        // --- Automatic Session State (UI only - localStorage) (unchanged) ---
        function getAutomaticSessionStateKey(user) { return `${USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }
        function saveAutomaticSessionState() { /* ... */
             const autoState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value };
            saveJSONToStorage(getAutomaticSessionStateKey(currentUser), autoState, `Auto session for ${currentUser}`);
        }
        function loadAutomaticSessionState(user = currentUser) { /* ... */
            const autoState = loadJSONFromStorage(getAutomaticSessionStateKey(user), `Auto session for ${user}`);
            if (autoState) {
                currentPath = autoState.currentPath || '/';
                if (!isRunningDiag && autoState.hasOwnProperty('outputHTML')) {
                     outputDiv.innerHTML = autoState.outputHTML || '';
                } else if (!isRunningDiag && !autoState.hasOwnProperty('outputHTML')) {
                }
                hiddenInput.value = autoState.currentInput || '';
            } else {
                if (!isRunningDiag) outputDiv.innerHTML = '';
                hiddenInput.value = ''; currentPath = '/';
                if (!isRunningDiag) {
                    appendToOutput(`Welcome, ${user}! Type 'help' for commands.`, false, CSS_CONSOLE_LOG_MSG);
                }
            }
            updateVisualInput();
            updatePrompt();
            if (!isRunningDiag) outputDiv.scrollTop = outputDiv.scrollHeight;
            return !!autoState;
        }

        // --- Manual Save State (fsDataSnapshot will be from memory) (unchanged) ---
        function getManualUserTerminalStateKey(user) { return `${MANUAL_USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }

        // --- Path and Node Utilities (unchanged) ---
        function getAbsolutePath(targetPath, basePath) { /* ... */
            if (!targetPath) targetPath = '.';
            if (targetPath.startsWith('/')) basePath = '/';
            const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s && s !== '.');
            let resolvedSegments = [...baseSegments];
            const targetSegments = targetPath.split('/');
            for (const segment of targetSegments) {
                if (segment === '' || segment === '.') {
                    if (targetPath.startsWith('/') && resolvedSegments.length === 0 && segment === '') {}
                    continue;
                }
                if (segment === '..') {
                    if (resolvedSegments.length > 0) {
                        resolvedSegments.pop();
                    }
                } else {
                    resolvedSegments.push(segment);
                }
            }
            if (targetPath.startsWith('/') && resolvedSegments.length === 0) return '/';
            return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/');
        }
        function getNodeByPath(path) { /* ... */
             if (path === '/') return fsData['/'];
            const segments = path.substring(1).split('/').filter(s => s);
            let currentNode = fsData['/'];
            for (const segment of segments) {
                if (currentNode && currentNode.type === 'directory' && currentNode.children && currentNode.children[segment]) {
                    currentNode = currentNode.children[segment];
                } else return null;
            }
            return currentNode;
        }
        function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }

        // --- User Credentials Management (localStorage - unchanged) ---
        function getUserCredentials() { return loadJSONFromStorage(USER_CREDENTIALS_KEY, "User creds", {}); }
        function saveUserCredentials(credentials) { return saveJSONToStorage(USER_CREDENTIALS_KEY, credentials, "User creds"); }

        // --- Password Hashing (unchanged) ---
        async function hashPassword(password) { /* ... */
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            } catch (error) {
                console.error("Password hashing failed:", error);
                appendToOutput("Critical error: Password hashing service unavailable.", true, CSS_ERROR_MSG);
                throw error;
            }
        }

        // --- Helper to create parent directories (unchanged) ---
        function createParentDirectoriesIfNeeded(fullPath) { /* ... */
            if (fullPath === '/') return null;
            const lastSlashIndex = fullPath.lastIndexOf('/');
            if (lastSlashIndex === -1) return null;
            const parentPath = lastSlashIndex === 0 ? '/' : fullPath.substring(0, lastSlashIndex);
            const newFileName = fullPath.substring(lastSlashIndex + 1);
            if (!newFileName || newFileName === "." || newFileName === "..") {
                const messageClass = isEditingFile || isRunningDiag ? 'diag-output' : CSS_ERROR_MSG;
                appendToOutput(`Error: Invalid file name '${newFileName}' in path '${fullPath}'`, true, messageClass);
                return null;
            }
            if (parentPath === '/') return fsData['/'];
            const parentPathSegments = parentPath.substring(1).split('/').filter(s => s);
            let currentDirNode = fsData['/'];
            let currentBuiltParentPath = "";
            for (const segment of parentPathSegments) {
                currentBuiltParentPath += "/" + segment;
                if (!currentDirNode.children[segment]) {
                    currentDirNode.children[segment] = { type: 'directory', children: {} };
                } else if (currentDirNode.children[segment].type !== 'directory') {
                    const messageClass = isEditingFile || isRunningDiag ? 'diag-output' : CSS_ERROR_MSG;
                    appendToOutput(`Error: Path component '${currentBuiltParentPath}' is not a directory.`, true, messageClass);
                    return null;
                }
                currentDirNode = currentDirNode.children[segment];
            }
            return currentDirNode;
        }

        // --- Byte Formatting Helper (unchanged from 0.1.2.2) ---
        function formatBytes(bytes, decimals = 2) { /* ... */
            if (bytes === 0) return '0 B';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- Command Help Data ---
        const commandHelpData = {
            'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
            'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
            'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
            'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
            'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
            'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
            'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
            'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
            'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms).', syntax: 'rm ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command requires confirmation before deletion as it cannot be undone. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder']},
            'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
            'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
            'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
            'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
            'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
            'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
            'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
            'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
            'register': { usage: 'register <username> <password>', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME PASSWORD', details: 'Registers a new user with the given USERNAME and PASSWORD. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage and input is masked.', examples: ['register myuser mysecretpass']},
            'login': { usage: 'login <username> <password>', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME PASSWORD', details: 'Logs in as the specified USERNAME using the provided PASSWORD. The entered password will be hashed, compared against the stored hash, and input is masked. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser mysecretpass']},
            'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
            'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
            'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
            'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
            'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
            'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
            'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
            'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
            'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
            'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
            'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
            'head': { // NEW
                usage: 'head [-n N] <filename>',
                summary: 'Displays the beginning of a file.',
                syntax: 'head [-n N] FILE',
                details: 'Prints the first N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid, it defaults to 10.',
                examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt']
            },
            'tail': { // NEW
                usage: 'tail [-n N] <filename>',
                summary: 'Displays the end of a file.',
                syntax: 'tail [-n N] FILE',
                details: 'Prints the last N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid, it defaults to 10.',
                examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt']
            }
        };

        // --- Command Handlers ---
        async function handleLs(args) { /* ... */
            const targetPathArg = args[0] || '.';
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') {
                const childrenNames = Object.keys(node.children).sort();
                if (childrenNames.length === 0) return "Directory is empty.";
                let outputLines = [];
                childrenNames.forEach(name => {
                    const childNode = node.children[name];
                    let line = name;
                    if (childNode.type === 'directory') line += '/';
                    outputLines.push(line);
                });
                return outputLines.join('\n');
            } else if (node) {
                appendToOutput(`ls: '${targetPathArg}': Not a directory`, true);
                return null;
            } else {
                appendToOutput(`ls: cannot access '${targetPathArg}': No such file or directory`, true);
                return null;
            }
        }
        async function handleCd(args) { /* ... */
            if (!args.length) { appendToOutput("cd: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);

            if (resolvedPath === currentPath) {
                return null;
            }

            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') {
                currentPath = resolvedPath;
                updatePrompt();
            } else if (node) {
                appendToOutput(`cd: '${targetPathArg}': Not a directory`, true);
            } else {
                appendToOutput(`cd: '${targetPathArg}': No such file or directory`, true);
            }
            return null;
        }
        async function handleMkdir(args) { /* ... */
            if (args.length === 0) { appendToOutput("mkdir: missing operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg === '/' || fullPathArg === '.' || fullPathArg === '..') {
                appendToOutput(`mkdir: invalid directory name '${fullPathArg}'`, true); return null;
            }
            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') {
                appendToOutput(`mkdir: cannot create directory '/': It already exists.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const lastSlash = targetAbsPath.lastIndexOf('/');
            const parentDirPath = lastSlash === 0 ? '/' : targetAbsPath.substring(0, lastSlash);
            const dirToCreateName = targetAbsPath.substring(lastSlash + 1);

            if (!dirToCreateName) {
                appendToOutput(`mkdir: invalid directory name in '${fullPathArg}'`, true); return null;
            }

            let parentNode;
            if (parentDirPath === '/') {
                parentNode = fsData['/'];
            } else {
                parentNode = createParentDirectoriesIfNeeded(targetAbsPath); // Ensures parent of targetAbsPath exists
                if (!parentNode) {
                    return null;
                }
            }

            if (parentNode.children[dirToCreateName]) {
                if (parentNode.children[dirToCreateName].type === 'directory') {
                    appendToOutput(`mkdir: cannot create directory '${fullPathArg}': Directory already exists.`, false, CSS_CONSOLE_LOG_MSG);
                } else {
                    appendToOutput(`mkdir: cannot create directory '${fullPathArg}': A file with the name '${dirToCreateName}' already exists.`, true);
                }
                return null;
            }

            parentNode.children[dirToCreateName] = { type: 'directory', children: {} };
            if (!await saveFileSystemData()) { // Await the save
                return null;
            }
            return null;
        }
        async function handleTouch(args) { /* ... */
            if (args.length === 0) { appendToOutput("touch: missing file operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg.endsWith('/')) { appendToOutput(`touch: invalid argument '${fullPathArg}'`, true); return null; }

            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') { appendToOutput(`touch: cannot create file at root '/'`, true); return null; }

            const parentNode = createParentDirectoriesIfNeeded(targetAbsPath);
            if (!parentNode) return null;

            const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);

            if (parentNode.children[newFileName]?.type === 'directory') {
                appendToOutput(`touch: cannot touch '${fullPathArg}': It is a directory.`, true); return null;
            }

            if (parentNode.children[newFileName]) {
                 // appendToOutput(`touch: file '${fullPathArg}' already exists.`, false, CSS_CONSOLE_LOG_MSG);
            } else {
                parentNode.children[newFileName] = { type: 'file', content: "" };
                if (!await saveFileSystemData()) return null; // Await the save
            }
            return null;
        }
        async function handleCat(args) { /* ... */
            if (args.length === 0) { appendToOutput("cat: missing file operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`cat: ${targetPathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`cat: ${targetPathArg}: Is a directory`, true); return null; }
            return node.content;
        }
        async function handleEcho(args) { /* ... */
            let outputString = args.join(' ');
            if (outputString.length >= 2) {
                const firstChar = outputString[0];
                const lastChar = outputString[outputString.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    outputString = outputString.substring(1, outputString.length - 1);
                }
            }
            return outputString;
        }
        async function handleMv(args) { /* ... */
            if (args.length < 2) { appendToOutput("mv: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);
            if (absSourcePath === '/') { appendToOutput("mv: cannot move root '/'", true); return null; }
            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`mv: '${sourcePathArg}': No such file or directory`, true); return null; }
            const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/';
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            const sourceParentNode = getNodeByPath(sourceParentPath);
            if (!sourceParentNode?.children?.[sourceName]) { appendToOutput(`mv: internal error: source '${sourceName}' not in parent`, true); return null; }
            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);
            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }
            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`mv: invalid destination name '${finalDestName}'`, true); return null; }
            if (absSourcePath === absDestPath) { appendToOutput(`mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, false, CSS_CONSOLE_LOG_MSG); return null; }
            if (finalDestParentNode.children[finalDestName]) {
                if (!(destNodeAtFullPath?.type === 'directory' && sourceNode.type !== 'directory')) {
                    appendToOutput(`mv: destination '${finalDestName}' already exists.`, true); return null;
                }
            }
            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`mv: cannot move directory into itself`, true); return null;
            }
            finalDestParentNode.children[finalDestName] = sourceNode;
            delete sourceParentNode.children[sourceName];
            if (await saveFileSystemData()) appendToOutput(`Moved '${sourcePathArg}' to '${destPathArg}'`, false, CSS_SUCCESS_MSG); // Await
            return null;
        }
        async function handleCp(args) { /* ... */
            if (args.length < 2) { appendToOutput("cp: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);
            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`cp: '${sourcePathArg}': No such file or directory`, true); return null; }
            if (absSourcePath === '/') { appendToOutput("cp: cannot copy root '/' itself.", true); return null; }
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);
            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }
            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`cp: invalid destination name '${finalDestName}'`, true); return null; }
            if (finalDestParentNode.children[finalDestName]) {
                appendToOutput(`cp: destination '${finalDestName}' already exists.`, true); return null;
            }
            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`cp: cannot copy directory into itself`, true); return null;
            }
            const copiedNode = deepCopyNode(sourceNode);
            if (!copiedNode) { appendToOutput(`cp: internal error copying '${sourcePathArg}'.`, true); return null; }
            finalDestParentNode.children[finalDestName] = copiedNode;
            if (await saveFileSystemData()) appendToOutput(`Copied '${sourcePathArg}' to '${destPathArg}'`, false, CSS_SUCCESS_MSG); // Await
            return null;
        }
        async function handleRm(args) { /* ... */
             if (args.length === 0) { appendToOutput("rm: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            if (resolvedPath === '/') { appendToOutput("rm: cannot remove root directory '/'", true); return null; }
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`rm: cannot remove '${targetPathArg}': No such file or directory`, true); return null; }
            itemToRemovePath = resolvedPath;
            awaitingRmConfirmation = true;
            const itemType = node.type === 'directory' ? 'directory' : 'file';
            appendToOutput(`Are you sure you want to remove ${itemType} '${targetPathArg}'? This action cannot be undone.`, false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            return null;
        }
        async function handlePwd(args) { /* ... */ return currentPath;}
        async function handleDate(args) { /* ... */ return new Date().toString();}
        async function handleWhoami(args) { /* ... */ return currentUser;}
        async function handleGrep(args) { /* ... (unchanged) ... */
            if (args.length < 2) { appendToOutput("grep: usage: grep PATTERN FILE", true); return null; }
            const filePathArg = args[args.length - 1];
            let patternParts = args.slice(0, args.length - 1);
            let pattern = patternParts.join(' ');
            if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                pattern = pattern.substring(1, pattern.length - 1);
            }
            if (!pattern) { appendToOutput("grep: pattern cannot be empty", true); return null; }
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`grep: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`grep: ${filePathArg}: Is a directory`, true); return null; }
            const fileContent = node.content || "";
            const lines = fileContent.split('\n');
            const matchingLines = [];
            for (const line of lines) { if (line.includes(pattern)) { matchingLines.push(line); } }
            return matchingLines.length > 0 ? matchingLines.join('\n') : "";
        }
        async function handleRun(args) { /* ... (unchanged) ... */
            if (args.length === 0) { appendToOutput("run: missing script file operand", true); return null; }
            const scriptPathArg = args[0];
            const resolvedPath = getAbsolutePath(scriptPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`run: cannot access script '${scriptPathArg}': No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`run: cannot execute '${scriptPathArg}': It is a directory`, true); return null; }
            const scriptContent = node.content || "";
            const scriptLines = scriptContent.split('\n');
            appendToOutput(`Executing script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            (async () => {
                for (let i = 0; i < scriptLines.length; i++) {
                    const line = scriptLines[i];
                    const trimmedLine = line.trim();
                    if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;
                    const commandSuccessful = await processCommand(trimmedLine, false);
                    if (!commandSuccessful) {
                        appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, true);
                        return;
                    }
                }
                appendToOutput(`Finished script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            })();
            return null;
        }
        async function handleSysmon(args) { /* ... (unchanged) ... */
             const output = [
                "Ooputer 1 - System Monitor", "----------------------------------",
                `OS Name:          ${OS_NAME}`, `OS Version:       ${OS_VERSION}`,
                `Current User:     ${currentUser}`, "", "CPU:", `  Type:           OopisCPU Mark I`,
                `  Architecture:   CISC-ish`, `  Cores:          1 (Conceptual)`,
                `  Clock Speed:    ~1-5 OopoHertz (Variable Burst)`, "", "MEMORY (RAM):",
                `  Type:           DJHAR`, `  Capacity:       ~640 KB (Active Working Memory)`,
                "", "STORAGE (LS-SSD):", `  Type:           IndexedDB Drive`, // Updated for IndexedDB
                `  Capacity:       Browser Dependent (Often 10s-100s MB+)`, // Updated
                "", "DISPLAY (OTDA):",
                `  Type:           GreenScreen Deluxe`, `  Mode:           Text-Mode`,
                "----------------------------------"
            ];
            return output.join('\n');
        }
        async function handleSort(args) { /* ... (unchanged) ... */
            if (args.length === 0) { appendToOutput("sort: missing file operand", true); return null; }
            const filePathArg = args[0];
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`sort: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`sort: ${filePathArg}: Is a directory`, true); return null; }
            const fileContent = node.content || "";
            if (fileContent.trim() === "") return "";
            const lines = fileContent.split('\n');
            lines.sort();
            return lines.join('\n');
        }
        async function handleClear() { /* ... */ if (!isEditingFile) outputDiv.innerHTML = ''; return null; }
        async function handleManualSaveState() { /* ... */
            const manualState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value, fsDataSnapshot: deepCopyNode(fsData) };
            if (saveJSONToStorage(getManualUserTerminalStateKey(currentUser), manualState, `Manual save for ${currentUser}`)) {
                appendToOutput(`Session manually saved for ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        async function handleManualLoadState() { /* ... */
             pendingManualStateToLoad = loadJSONFromStorage(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser}`);
            if (pendingManualStateToLoad) {
                appendToOutput("Load manually saved state? This overwrites current session & filesystem.", false, CSS_WARNING_MSG);
                appendToOutput("Type 'YES' to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
                awaitingLoadstateConfirmation = true;
            } else appendToOutput(`No manually saved state found for ${currentUser}.`, false, CSS_CONSOLE_LOG_MSG);
            return null;
        }
        async function performFullReset() { /* ... */
            outputDiv.innerHTML = ''; hiddenInput.value = ''; updateVisualInput();
            // Clear localStorage items
            localStorage.removeItem(getAutomaticSessionStateKey(currentUser));
            localStorage.removeItem(getManualUserTerminalStateKey(currentUser));
            if (currentUser !== DEFAULT_USER) {
                localStorage.removeItem(getAutomaticSessionStateKey(DEFAULT_USER));
                localStorage.removeItem(getManualUserTerminalStateKey(DEFAULT_USER));
            }
            localStorage.removeItem(USER_CREDENTIALS_KEY);

            // Clear IndexedDB FileSystemsStore
            if (db) {
                try {
                    await new Promise((resolve, reject) => {
                        const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(FS_STORE_NAME);
                        const request = store.clear(); // Clear all entries in the store
                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                    appendToOutput("All user filesystems cleared from DB.", false, CSS_CONSOLE_LOG_MSG);
                } catch (error) {
                    console.error("Error clearing FileSystemsStore during reset:", error);
                    appendToOutput("Error clearing user filesystems from DB.", true);
                }
            }

            commandHistory = []; historyIndex = commandHistory.length; currentUser = DEFAULT_USER;
            await initializeFileSystem(DEFAULT_USER); // Re-init and save Guest FS to IndexedDB
            loadAutomaticSessionState(DEFAULT_USER); // Load Guest UI state
            appendToOutput("Terminal fully reset. All user data and states cleared.", false, CSS_SUCCESS_MSG);
        }
        async function handleReset() { /* ... */
            appendToOutput("Reset ALL terminal data? This cannot be undone.", false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            awaitingResetConfirmation = true; return null;
        }
        async function handleRegister(args) { /* ... */
            if (args.length < 2) { appendToOutput("Usage: register <username> <password>", true); return null; }
            const [username, password] = args;
            const credentials = getUserCredentials();
            if (credentials[username]) { appendToOutput(`Error: User '${username}' already exists.`, true); return null; }
            if (username.toLowerCase() === DEFAULT_USER.toLowerCase()) { appendToOutput(`Error: Cannot register '${DEFAULT_USER}'.`, true); return null; }
            try {
                const hashedPassword = await hashPassword(password);
                credentials[username] = hashedPassword;
                if (saveUserCredentials(credentials)) {
                    await initializeFileSystem(username); // Now async
                    if (!isRunningDiag) appendToOutput(`User '${username}' registered. You can now login.`, false, CSS_SUCCESS_MSG);
                }
            } catch (error) {
                 if (!isRunningDiag) appendToOutput(`Registration failed for '${username}' due to hashing error.`, true);
                 else throw error;
            }
            return null;
        }
        async function handleLogin(args) { // UPDATED
            if (args.length < 2) { appendToOutput("Usage: login <username> <password>", true); return null; }
            const [username, password] = args;

            if (username === currentUser) {
                if (!isRunningDiag) {
                    appendToOutput(`login: already logged in as '${username}'.`, false, CSS_CONSOLE_LOG_MSG);
                    return null;
                }
            }

            const credentials = getUserCredentials();
            const storedPasswordHash = credentials[username];

            if (!storedPasswordHash) {
                if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                else lastCommandFailed = true;
                return null;
            }

            try {
                const enteredPasswordHash = await hashPassword(password);
                if (storedPasswordHash === enteredPasswordHash) {
                    if (currentUser !== DEFAULT_USER && currentUser !== username && !isRunningDiag) saveAutomaticSessionState();
                    currentUser = username;
                    commandHistory = []; historyIndex = commandHistory.length;
                    await loadFileSystemData(currentUser);
                    if(!isRunningDiag) loadAutomaticSessionState(currentUser);
                    if(!isRunningDiag) appendToOutput(`Logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
                } else {
                    if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                    else lastCommandFailed = true;
                }
            } catch (error) {
                if (!isRunningDiag) appendToOutput("Login failed due to a system error during password verification.", true);
                else { lastCommandFailed = true; throw error; }
            }
            return null;
        }
        async function handleLogout() { /* ... */
            if (currentUser === DEFAULT_USER) {
                 if (!isRunningDiag) appendToOutput("Already Guest.", false, CSS_CONSOLE_LOG_MSG);
                 return null;
            }
            if (!isRunningDiag) saveAutomaticSessionState();
            const prevUser = currentUser;
            currentUser = DEFAULT_USER;
            commandHistory = []; historyIndex = commandHistory.length;
            await loadFileSystemData(DEFAULT_USER); // Load Guest FS (async)
            if (!isRunningDiag) {
                loadAutomaticSessionState(DEFAULT_USER);
                appendToOutput(`User ${prevUser} logged out. Now ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        async function handleHelp(args) { /* ... (unchanged, but handlers it calls might be async now) ... */
            let outputLines = [];
            if (!args.length) {
                outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                const commandNames = Object.keys(commandRegistry).sort();
                commandNames.forEach(cmdName => { outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${commandHelpData[cmdName]?.summary || ''}`); });
            } else {
                const commandName = args[0].toLowerCase();
                const helpInfo = commandHelpData[commandName];
                if (helpInfo) {
                    outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                    outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                    outputLines.push(`  For more details, type: man ${commandName}`);
                } else { appendToOutput(`No help available for '${commandName}'. Try 'man ${commandName}'.`, true); return null; }
            }
            return outputLines.join('\n');
        }
        async function handleMan(args) { /* ... (unchanged) ... */
            if (args.length === 0) return "What manual page do you want? (e.g., man ls)";
            const commandName = args[0].toLowerCase();
            const manDataFromHelp = commandHelpData[commandName]; let outputLines = [];
            if (manDataFromHelp) {
                outputLines.push(`NAME`); outputLines.push(`    ${commandName} - ${manDataFromHelp.summary || 'No summary available.'}`);
                outputLines.push(`\nSYNOPSIS`); outputLines.push(`    ${manDataFromHelp.syntax || manDataFromHelp.usage || 'No syntax information available.'}`);
                outputLines.push(`\nDESCRIPTION`); outputLines.push(`    ${manDataFromHelp.details || 'No detailed description available.'}`);
                if (manDataFromHelp.examples && manDataFromHelp.examples.length > 0) {
                    outputLines.push(`\nEXAMPLES`);
                    manDataFromHelp.examples.forEach(example => { outputLines.push(`        ${example}`); });
                }
                outputLines.push(""); return outputLines.join('\n');
            } else { appendToOutput(`No manual entry for ${commandName}`, true); return null; }
        }

        async function handleEdit(args) { /* ... (unchanged, but uses saveFileSystemData) ... */
            if (isEditingFile) {
                appendToOutput("Editor already active. Ctrl+S to save, Ctrl+O to quit.", false, 'editor-message');
                return null;
            }
            if (args.length === 0) {
                appendToOutput("edit: missing file operand", true);
                return null;
            }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            if (resolvedPath.endsWith('/')) {
                 appendToOutput(`edit: '${targetPathArg}' is a directory path, not a file.`, true);
                 return null;
            }
            const node = getNodeByPath(resolvedPath);
            if (node && node.type === 'directory') {
                appendToOutput(`edit: '${targetPathArg}' is a directory. Cannot edit directories.`, true);
                return null;
            }
            const content = node?.content || "";
            enterEditMode(resolvedPath, content); // enterEditMode itself is sync
            return null;
        }
        // enterEditMode remains synchronous, exitEditMode becomes async
        function enterEditMode(filePath, content) { /* ... (unchanged) ... */
            isEditingFile = true;
            editingFilePath = filePath;
            outputDiv.style.display = 'none';
            standardInputLineDiv.style.display = 'none';
            hiddenInput.blur();
            editorWrapperDiv = document.createElement('div');
            editorWrapperDiv.id = 'editor-wrapper';
            editorTextareaElement = document.createElement('textarea');
            editorTextareaElement.id = 'editor-textarea';
            editorTextareaElement.value = content;
            editorInstructionsDiv = document.createElement('div');
            editorInstructionsDiv.id = 'editor-instructions';
            editorInstructionsDiv.textContent = `Editing: ${filePath} | Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving`;
            editorWrapperDiv.appendChild(editorTextareaElement);
            editorWrapperDiv.appendChild(editorInstructionsDiv);
            terminalDiv.insertBefore(editorWrapperDiv, standardInputLineDiv);
            editorTextareaElement.focus();
            editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
            editorTextareaElement.addEventListener('keydown', handleEditorKeyDown); // handleEditorKeyDown will call async exitEditMode
        }

        async function exitEditMode(saveChanges = false) { /* ... */
            let success = true;
            if (saveChanges && editorTextareaElement && editingFilePath) {
                const newContent = editorTextareaElement.value;
                const parentNode = createParentDirectoriesIfNeeded(editingFilePath); // This is sync
                if (parentNode) {
                    const fileName = editingFilePath.substring(editingFilePath.lastIndexOf('/') + 1);
                    parentNode.children[fileName] = { type: 'file', content: newContent };
                    if (await saveFileSystemData()) { // Await the save
                        appendToOutput(`File '${editingFilePath}' saved.`, false, CSS_SUCCESS_MSG);
                    } else {
                        appendToOutput(`Error saving file '${editingFilePath}'.`, true, CSS_ERROR_MSG);
                        success = false;
                    }
                } else {
                    appendToOutput(`Failed to save '${editingFilePath}'. Parent path issue.`, true, CSS_ERROR_MSG);
                    success = false;
                }
            } else if (editingFilePath) {
                appendToOutput(`Exited editor for '${editingFilePath}' without saving.`, false, CSS_CONSOLE_LOG_MSG);
            }
            // ... rest of UI cleanup ...
            if (editorWrapperDiv && editorWrapperDiv.parentNode === terminalDiv) {
                terminalDiv.removeChild(editorWrapperDiv);
            }
            if (editorTextareaElement) {
                editorTextareaElement.removeEventListener('keydown', handleEditorKeyDown);
            }
            editorWrapperDiv = null; editorTextareaElement = null; editorInstructionsDiv = null;
            isEditingFile = false; editingFilePath = null;
            outputDiv.style.display = ''; standardInputLineDiv.style.display = '';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            hiddenInput.focus(); updatePrompt();
            return success;
        }

        async function handleEditorKeyDown(event) { // Made async
            if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                await exitEditMode(true); // Await exit
            } else if (event.ctrlKey && (event.key === 'o' || event.key === 'O')) {
                event.preventDefault();
                await exitEditMode(false); // Await exit
            }
            if (event.key === 'Tab') {
                event.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
            }
        }


        async function handleDiag(args) {
            isRunningDiag = true;
            let passCount = 0;
            let failCount = 0;

            const originalCurrentUser = currentUser;
            let originalFsData = deepCopyNode(fsData);
            const originalCurrentPath = currentPath;
            const originalCredentials = deepCopyNode(getUserCredentials());
            const originalOutputHTML = outputDiv.innerHTML;

            const diagPrint = (message) => appendToOutput(message, false, 'diag-output');
            const report = (testName, success, details = "") => {
                if (success) { passCount++; diagPrint(`  PASS: ${testName}`); }
                else { failCount++; diagPrint(`  FAIL: ${testName} ${details ? `- ${details}` : ''}`); }
                return success;
            };

            outputDiv.innerHTML = '';
            diagPrint("Starting OopisOs Diagnostics...");
            diagPrint("-------------------------------");

            diagPrint("SECTION: Filesystem Operations");
            const fsTestDir = "/tmp/__diag_fs_tests__";
            const fsTestFile = `${fsTestDir}/file.txt`;
            const fsTestContent = "Hello from FS Diag!";
            let tempFsDataForFsTest = deepCopyNode(originalFsData);
            fsData = tempFsDataForFsTest;
            await saveFileSystemData(originalCurrentUser);
            const testDirParentPathFs = fsTestDir.substring(0, fsTestDir.lastIndexOf('/')) || '/';
            const testDirNameFs = fsTestDir.substring(fsTestDir.lastIndexOf('/') + 1);
            let testDirParentNodeFs = getNodeByPath(testDirParentPathFs);
            if (testDirParentNodeFs && testDirParentNodeFs.children[testDirNameFs]) {
                delete testDirParentNodeFs.children[testDirNameFs];
                await saveFileSystemData(originalCurrentUser);
                diagPrint(`  INFO: Cleaned up ${fsTestDir} for FS tests.`);
            }
            lastCommandFailed = false; await processCommand(`mkdir ${fsTestDir}`, false);
            report("FS: Create test directory", getNodeByPath(fsTestDir)?.type === 'directory' && !lastCommandFailed);
            lastCommandFailed = false; await processCommand(`cd ${fsTestDir}`, false);
            report("FS: Change to test directory", currentPath === fsTestDir && !lastCommandFailed);
            lastCommandFailed = false; await processCommand(`touch ${fsTestFile.split('/').pop()}`, false);
            report("FS: Create test file", getNodeByPath(fsTestFile)?.type === 'file' && !lastCommandFailed);
            lastCommandFailed = false; await processCommand(`echo "${fsTestContent}" > ${fsTestFile.split('/').pop()}`, false);
            let fileNodeContentFs = getNodeByPath(fsTestFile);
            report("FS: Write content to file", fileNodeContentFs?.content === fsTestContent && !lastCommandFailed, `Expected "${fsTestContent}", got "${fileNodeContentFs?.content}"`);
            fileNodeContentFs = getNodeByPath(fsTestFile);
            report("FS: Verify file content (direct check)", fileNodeContentFs?.content === fsTestContent);
            fsData = tempFsDataForFsTest;
            const lsOutput = await handleLs([]);
            report("FS: List test file", typeof lsOutput === 'string' && lsOutput.includes(fsTestFile.split('/').pop()) && !lastCommandFailed, `ls output: ${lsOutput}`);
            await processCommand(`cd ${originalCurrentPath}`, false);
            fsData = deepCopyNode(originalFsData);
            await saveFileSystemData(originalCurrentUser);

            diagPrint("SECTION: Path Resolution (getAbsolutePath)");
            const pathTestCases = [
                { target: '.', base: '/', expected: '/' , desc: "Current dir at root"}, { target: '..', base: '/', expected: '/', desc: "Parent dir at root" }, { target: 'foo', base: '/', expected: '/foo', desc: "Simple relative from root" }, { target: '/foo/bar', base: '/baz', expected: '/foo/bar', desc: "Absolute target, ignore base" }, { target: 'bar', base: '/foo', expected: '/foo/bar', desc: "Relative from non-root" }, { target: '../bar', base: '/foo/baz', expected: '/foo/bar', desc: "Relative parent navigation" }, { target: '../../bar', base: '/foo/baz/qux', expected: '/foo/bar', desc: "Multiple parent nav" }, { target: '../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav to higher level" }, { target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav beyond root (stays at /)" }, { target: 'qux/./corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With current dir token"}, { target: 'qux//corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With double slashes"}, { target: '.', base: '/foo/bar', expected: '/foo/bar', desc: "Current dir in non-root"}, { target: '', base: '/foo/bar', expected: '/foo/bar', desc: "Empty target (like current)"}, { target: 'a/b/../../c', base: '/x/y', expected: '/x/y/c', desc: "Complex relative with backtracking"}, { target: '/a/b/../c', base: '/x', expected: '/a/c', desc: "Absolute with backtracking"}, { target: 'a/../..', base: '/x', expected: '/', desc: "Relative to root"}, { target: 'a/b', base: '/', expected: '/a/b', desc: "Simple relative from root 2"}, { target: '//a//b', base: '/', expected: '/a/b', desc: "Multiple slashes at start and middle"},
            ];
            pathTestCases.forEach(tc => {
                const actual = getAbsolutePath(tc.target, tc.base);
                report(`Path: ${tc.desc} ('${tc.target}', '${tc.base}')`, actual === tc.expected, `Expected '${tc.expected}', got '${actual}'`);
            });

            diagPrint("SECTION: User Management");
            const testUsername = "__diag_user__";
            const testPassword = "diagPassword123!";
            const wrongPassword = "wrongPassword!";
            let tempCredentials = getUserCredentials();
            if (tempCredentials[testUsername]) {
                delete tempCredentials[testUsername];
                saveUserCredentials(tempCredentials);
            }
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            diagPrint(`  INFO: Pre-cleaned test user '${testUsername}' related data.`);
            diagPrint("  Test UM.1: register new user");
            lastCommandFailed = false;
            await processCommand(`register ${testUsername} ${testPassword}`, false);
            tempCredentials = getUserCredentials();
            const userRegistered = tempCredentials[testUsername] && tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername].length === 64;
            let testUserFsExistsInDb = false;
            if(db) {
                const storedFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => rej(e.target.error);
                });
                testUserFsExistsInDb = !!(storedFs && storedFs.data);
            }
            report("Register test user", userRegistered && testUserFsExistsInDb && !lastCommandFailed,
                   `User in creds: ${!!tempCredentials[testUsername]}, Pwd hashed: ${tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername]?.length === 64}, FS in DB: ${testUserFsExistsInDb}`);
            diagPrint("  Test UM.2: login with correct password");
            lastCommandFailed = false;
            const currentUserBeforeLogin = currentUser;
            await processCommand(`login ${testUsername} ${testPassword}`, false);
            report("Login test user (correct pwd)", currentUser === testUsername && !lastCommandFailed);

            if (currentUser === testUsername) {
                diagPrint("  Test UM.3: whoami as test user");
                diagPrint(`    -- DIAG UM.3 PRE-CALL: currentUser = '${currentUser}', testUsername = '${testUsername}'`);
                const whoOutput = await handleWhoami([]); // AWAITED
                diagPrint(`    -- DIAG UM.3 POST-CALL: whoOutput = '${whoOutput}'`);
                report("whoami check", whoOutput === testUsername, `whoOutput: '${whoOutput}', testUsername: '${testUsername}'`);
            } else {
                report("whoami check", false, "Skipped due to previous login failure or currentUser mismatch.");
                currentUser = currentUserBeforeLogin;
                await loadFileSystemData(currentUser);
            }

            diagPrint("  Test UM.4: login with incorrect password");
            const currentUserBeforeWrongLogin = currentUser;
            lastCommandFailed = false;
            await processCommand(`login ${testUsername} ${wrongPassword}`, false);
            report("Login test user (incorrect pwd)", currentUser === currentUserBeforeWrongLogin && lastCommandFailed, `currentUser is ${currentUser}, expected ${currentUserBeforeWrongLogin}. lastCommandFailed: ${lastCommandFailed}`);

            diagPrint("  Test UM.5: logout from test user");
            lastCommandFailed = false;
            await processCommand("logout", false);
            report("Logout to Guest", currentUser === DEFAULT_USER && !lastCommandFailed);

            diagPrint("  Cleanup: Removing test user credentials and data");
            tempCredentials = getUserCredentials();
            if (tempCredentials[testUsername]) delete tempCredentials[testUsername];
            saveUserCredentials(tempCredentials);
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            let finalCredCheck = !getUserCredentials()[testUsername];
            let finalFsCheckInDb = true;
             if(db) {
                const finalStoredFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => rej(e.target.error);
                }).catch(()=>null);
                finalFsCheckInDb = !finalStoredFs;
            }
            report("User data cleanup", finalCredCheck && finalFsCheckInDb);

            diagPrint("-------------------------------");
            diagPrint(`Diagnostics Complete: ${passCount} PASSED, ${failCount} FAILED.`);
            diagPrint("-------------------------------");
            const finalDiagReportHTML = outputDiv.innerHTML;
            currentUser = originalCurrentUser;
            fsData = originalFsData;
            currentPath = originalCurrentPath;
            saveUserCredentials(originalCredentials);
            await saveFileSystemData(currentUser);
            outputDiv.innerHTML = originalOutputHTML;
            const diagReportContainer = document.createElement('div');
            diagReportContainer.innerHTML = finalDiagReportHTML;
            outputDiv.appendChild(diagReportContainer);
            updatePrompt();
            setTimeout(() => { outputDiv.scrollTop = outputDiv.scrollHeight; }, 50);
            isRunningDiag = false;
            return "";
        }
        // ... (Tree, Find, Du handlers unchanged)
        function handleTree(args) { /* ... */
            const targetPathArg = args[0] || '.';
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const startNode = getNodeByPath(resolvedPath);
            if (!startNode) { appendToOutput(`tree: cannot access '${targetPathArg}': No such file or directory`, true); return null; }
            if (startNode.type !== 'directory') { appendToOutput(`tree: '${targetPathArg}' is not a directory`, true); return null; }
            const outputLines = [];
            const startingDirName = resolvedPath === '/' ? '/' : resolvedPath.substring(resolvedPath.lastIndexOf('/') + 1) || resolvedPath;
            outputLines.push(startingDirName);
            function generateTreeLinesRecursive(directoryNode, prefix) {
                const childrenNames = Object.keys(directoryNode.children).sort();
                childrenNames.forEach((name, index) => {
                    const childNode = directoryNode.children[name];
                    const isLast = index === childrenNames.length - 1;
                    const connector = isLast ? "└── " : "├── ";
                    let line = prefix + connector + name;
                    if (childNode.type === 'directory') { line += "/"; }
                    outputLines.push(line);
                    if (childNode.type === 'directory') {
                        const newPrefix = prefix + (isLast ? "    " : "│   ");
                        generateTreeLinesRecursive(childNode, newPrefix);
                    }
                });
            }
            generateTreeLinesRecursive(startNode, "");
            return outputLines.join('\n');
        }
        function matchPattern(name, pattern) { /* ... */
            let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            try { const regex = new RegExp(`^${regexPattern}$`); return regex.test(name); }
            catch (e) { appendToOutput(`find: invalid pattern regex: ${pattern}`, true); return false; }
        }
        function findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) { /* ... */
            if (!currentSearchNode || currentSearchNode.type !== 'directory') { return; }
            const childrenNames = Object.keys(currentSearchNode.children).sort();
            for (const name of childrenNames) {
                const childNode = currentSearchNode.children[name];
                const childFullPath = getAbsolutePath(name, currentSearchPath);
                if (matchPattern(name, pattern)) {
                    foundItems.push(childFullPath + (childNode.type === 'directory' ? '/' : ''));
                }
                if (childNode.type === 'directory') {
                    findRecursive(childNode, childFullPath, pattern, foundItems);
                }
            }
        }
        function handleFind(args) { /* ... */
            let searchPathArg = '.'; let pattern = null; const nameOptionIndex = args.indexOf('-name');
            if (nameOptionIndex === -1) { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }
            if (nameOptionIndex === 0) {
                if (args.length < 2) { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }
                pattern = args[1];
            } else if (nameOptionIndex === 1) {
                if (args.length < 3) { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }
                searchPathArg = args[0]; pattern = args[2];
            } else { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }
            if (pattern && pattern.length >= 2) {
                const firstChar = pattern[0]; const lastChar = pattern[pattern.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    pattern = pattern.substring(1, pattern.length - 1);
                }
            }
            if (!pattern) { appendToOutput("find: missing pattern after -name", true); return null; }
            const absoluteSearchPath = getAbsolutePath(searchPathArg, currentPath);
            const startNode = getNodeByPath(absoluteSearchPath);
            if (!startNode) { appendToOutput(`find: '${searchPathArg}': No such file or directory`, true); return null; }
            if (startNode.type !== 'directory') { appendToOutput(`find: '${searchPathArg}': Not a directory`, true); return null; }
            const foundItems = [];
            findRecursive(startNode, absoluteSearchPath, pattern, foundItems);
            return foundItems.length > 0 ? foundItems.join('\n') : "";
        }
        function calculateNodeSize(node) { /* ... */
            if (node.type === 'file') { return node.content ? node.content.length : 0; }
            if (node.type === 'directory') {
                let totalSize = 0;
                for (const childName in node.children) { totalSize += calculateNodeSize(node.children[childName]); }
                return totalSize;
            }
            return 0;
        }
        function handleDu(args) { /* ... */
            const outputLines = []; let pathsToProcessInfo = [];
            if (args.length === 0) { pathsToProcessInfo.push({ originalArg: '.', resolvedPath: currentPath }); }
            else { for (const arg of args) { pathsToProcessInfo.push({ originalArg: arg, resolvedPath: getAbsolutePath(arg, currentPath) }); } }
            for (const item of pathsToProcessInfo) {
                const node = getNodeByPath(item.resolvedPath);
                if (!node) { appendToOutput(`du: cannot access '${item.originalArg}': No such file or directory`, true); continue; }
                const rawSize = calculateNodeSize(node); const formattedSize = formatBytes(rawSize);
                let displayPath = item.originalArg;
                if (node.type === 'directory' && item.originalArg === '.') { displayPath = './'; }
                else if (node.type === 'directory' && !item.originalArg.endsWith('/')) { displayPath += '/'; }
                outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`);
            }
            return outputLines.join('\n');
        }


        // --- Command Registry ---
        const commandRegistry = {
            'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch,
            'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd,
            'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep,
            'sort': handleSort,
            'sysmon': handleSysmon,
            'mv': handleMv, 'cp': handleCp,
            'clear': handleClear,
            'register': handleRegister, 'login': handleLogin, 'logout': handleLogout,
            'savestate': handleManualSaveState, 'loadstate': handleManualLoadState,
            'reset': handleReset, 'help': handleHelp, 'man': handleMan,
            'edit': handleEdit,
            'diag': handleDiag,
            'tree': handleTree,
            'find': handleFind,
            'du': handleDu
        };

        // --- UI Update Functions ---
        function updatePrompt() {
            promptUserSpan.textContent = currentUser;
            promptHostSpan.textContent = OS_NAME;
            promptPathSpan.textContent = currentPath.trim() === '' ? '/' : currentPath;
        }

        // --- Command Processing ---
        async function processCommand(commandInputText, isInteractive = true) { /* ... (ensure it awaits async handlers) ... */
            if (isEditingFile && !isRunningDiag) return true;
            lastCommandFailed = false;
            let commandSuccessful = true;

            const trimmedCommand = commandInputText.trim();
            if (isInteractive && !isRunningDiag) {
                let displayCommand = trimmedCommand;
                if (isPasswordInputActive && passwordMaskStartIndex !== -1 && trimmedCommand.length > passwordMaskStartIndex) {
                    const prefix = trimmedCommand.substring(0, passwordMaskStartIndex);
                    const suffixToMask = trimmedCommand.substring(passwordMaskStartIndex);
                    displayCommand = prefix + '*'.repeat(suffixToMask.length);
                }
                const promptText = `${currentUser}@${OS_NAME}:${promptPathSpan.textContent}> `;
                appendToOutput(`${promptText}${displayCommand}`);
            } else if (!isInteractive && !isRunningDiag) {
                 appendToOutput(`> ${trimmedCommand}`);
            }

            if (isInteractive && trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                commandHistory.push(trimmedCommand);
                if (commandHistory.length > MAX_HISTORY_SIZE) commandHistory.shift();
            }
            if (isInteractive) {
                historyIndex = commandHistory.length;
            }

            if (awaitingResetConfirmation) {
                if (trimmedCommand === 'YES') { await performFullReset(); appendToOutput("Full reset complete.", false, CSS_SUCCESS_MSG); } // await
                else { appendToOutput("Reset cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingResetConfirmation = false;
            } else if (awaitingLoadstateConfirmation) {
                 if (trimmedCommand === 'YES' && pendingManualStateToLoad) {
                    fsData = deepCopyNode(pendingManualStateToLoad.fsDataSnapshot) || { '/': { type: 'directory', children: {} } };
                    currentPath = pendingManualStateToLoad.currentPath || '/';
                    outputDiv.innerHTML = pendingManualStateToLoad.outputHTML || '';
                    hiddenInput.value = pendingManualStateToLoad.currentInput || '';
                    await saveFileSystemData(); // Await save after loading state
                    appendToOutput("Session loaded from manual save.", false, CSS_SUCCESS_MSG);
                    updateVisualInput(); updatePrompt(); outputDiv.scrollTop = outputDiv.scrollHeight;
                } else { appendToOutput("Load state cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingLoadstateConfirmation = false; pendingManualStateToLoad = null;
            } else if (awaitingRmConfirmation && !isRunningDiag) {
                if (trimmedCommand === 'YES' && itemToRemovePath) {
                    const parentPath = itemToRemovePath.substring(0, itemToRemovePath.lastIndexOf('/')) || '/';
                    const itemName = itemToRemovePath.substring(itemToRemovePath.lastIndexOf('/') + 1);
                    const parentNode = getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await saveFileSystemData()) commandSuccessful = false; // Await
                        else appendToOutput(`'${itemToRemovePath}' removed.`, false, CSS_SUCCESS_MSG);
                    } else { appendToOutput(`Error removing '${itemToRemovePath}': Item not found or parent changed.`, true); }
                } else { appendToOutput(`Removal of '${itemToRemovePath || 'item'}' cancelled.`, false, CSS_CONSOLE_LOG_MSG); }
                awaitingRmConfirmation = false; itemToRemovePath = null;
            } else {
                let commandToExecute = trimmedCommand;
                let redirectionType = null;
                let redirectionFile = null;
                const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/);
                const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/);
                if (appendMatch) {
                    redirectionType = 'append'; redirectionFile = appendMatch[1];
                    commandToExecute = commandToExecute.substring(0, appendMatch.index).trim();
                } else if (overwriteMatch) {
                    redirectionType = 'overwrite'; redirectionFile = overwriteMatch[1];
                    commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim();
                }

                if (commandToExecute !== '') {
                    const parts = commandToExecute.split(' ').filter(p => p);
                    const baseCommand = parts[0].toLowerCase();
                    let args;
                    if (baseCommand === 'echo') { args = [commandToExecute.substring(baseCommand.length).trimStart()]; }
                    else if (baseCommand === 'find') { args = parts.slice(1); }
                    else { args = parts.slice(1); }

                    const handler = commandRegistry[baseCommand];
                    if (handler) {
                        let commandOutput = null;
                        try {
                            commandOutput = await handler(args); // All handlers are potentially async now
                            if (lastCommandFailed) commandSuccessful = false;

                            if (redirectionType && redirectionFile) {
                                if (lastCommandFailed) {
                                    appendToOutput(`Error: Command '${baseCommand}' failed. Output not redirected to '${redirectionFile}'.`, true);
                                } else {
                                    const targetAbsPathForRedir = getAbsolutePath(redirectionFile, currentPath);
                                    if (targetAbsPathForRedir === '/') {
                                        appendToOutput(`Error: cannot redirect to root '/'`, true);
                                        commandSuccessful = false;
                                    } else {
                                        const parentNodeForRedir = createParentDirectoriesIfNeeded(targetAbsPathForRedir);
                                        if (!parentNodeForRedir) {
                                            commandSuccessful = false;
                                        } else {
                                            const newFileNameForRedir = targetAbsPathForRedir.substring(targetAbsPathForRedir.lastIndexOf('/') + 1);
                                            const targetNodeForRedir = parentNodeForRedir.children[newFileNameForRedir];
                                            if (targetNodeForRedir?.type === 'directory') {
                                                appendToOutput(`Error: cannot write to '${redirectionFile}': It is a directory.`, true);
                                                commandSuccessful = false;
                                            } else {
                                                let contentToWrite = "";
                                                if (commandOutput !== null && commandOutput !== undefined) { contentToWrite = String(commandOutput); }
                                                if (redirectionType === 'overwrite' || !targetNodeForRedir) {
                                                    parentNodeForRedir.children[newFileNameForRedir] = { type: 'file', content: contentToWrite };
                                                } else if (redirectionType === 'append') {
                                                    const existingContent = targetNodeForRedir?.content || "";
                                                    const separator = (existingContent && contentToWrite) ? "\n" : "";
                                                    parentNodeForRedir.children[newFileNameForRedir].content = existingContent + separator + contentToWrite;
                                                }
                                                if(!await saveFileSystemData()) commandSuccessful = false; // Await save
                                            }
                                        }
                                    }
                                }
                            } else if (commandOutput !== null && commandOutput !== undefined && !isRunningDiag) {
                                const lines = String(commandOutput).split('\n');
                                lines.forEach(line => {
                                    if (baseCommand === 'man') { /* ... */ }
                                    else if (baseCommand === 'sysmon' && line.includes(':')) { /* ... */ }
                                    else if (baseCommand === 'ls') { /* ... */ }
                                    else { appendToOutput(line); }
                                });
                            }
                            if(lastCommandFailed) commandSuccessful = false;
                        } catch (e) {
                            console.error(`Error in '${baseCommand}':`, e);
                            if (!isRunningDiag) {
                                appendToOutput(`Unexpected error in '${baseCommand}'. Check console.`, true);
                            } else {
                                appendToOutput(`  ERROR in '${baseCommand}': ${e.message}`, true, 'diag-output');
                            }
                            commandSuccessful = false;
                        }
                    } else {
                         if (!isRunningDiag) {
                            appendToOutput(`Error: Command not found: "${parts[0]}"`, true);
                        } else {
                            appendToOutput(`  ERROR: Command not found: "${parts[0]}"`, true, 'diag-output');
                        }
                        commandSuccessful = false;
                    }
                } else if (trimmedCommand === '') {
                    commandSuccessful = true;
                    lastCommandFailed = false;
                }
            }

            if (isInteractive && !isRunningDiag) {
                hiddenInput.value = '';
                isPasswordInputActive = false; passwordMaskStartIndex = -1;
                updateVisualInput();
            }
            if (!isEditingFile && !awaitingLoadstateConfirmation && !awaitingResetConfirmation && !awaitingRmConfirmation && !isRunningDiag) {
                updatePrompt();
            }
            return commandSuccessful;
        }

        // --- Event Listeners (mostly unchanged, ensure async on Enter key) ---
        terminalDiv.addEventListener('click', e => { /* ... */
            if (isEditingFile) {
                if (editorTextareaElement && e.target !== editorTextareaElement) { editorTextareaElement.focus(); }
                return;
            }
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A' && !e.target.closest('#visual-input-container')) { hiddenInput.focus(); }
            if (e.target.closest('#visual-input-container') || e.target.classList.contains('input-line')) { hiddenInput.focus(); }
        });

        hiddenInput.addEventListener('keydown', async e => { /* ... (Enter key calls await processCommand) ... */
            if (isEditingFile) { e.preventDefault(); return; }
            if (e.key === 'Enter') {
                e.preventDefault();
                await processCommand(hiddenInput.value, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--; hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                    historyIndex++; hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length; hiddenInput.value = "";
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
            } else if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'Backspace', 'Delete'].includes(e.key)) {
                setTimeout(() => hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })), 0);
            }
        });

        hiddenInput.addEventListener('input', () => { /* ... (unchanged) ... */
            if (isEditingFile) return;
            const rawInput = hiddenInput.value;
            isPasswordInputActive = false; passwordMaskStartIndex = -1;
            const passwordCommandRegex = /^(login|register)(\s+)(\S+)(\s+)(.*)$/i;
            const match = rawInput.match(passwordCommandRegex);
            if (match) {
                passwordMaskStartIndex = match[1].length + match[2].length + match[3].length + match[4].length;
                isPasswordInputActive = true;
            } else {
                const prefixRegex = /^(login|register)(\s+)(\S+)(\s*)$/i;
                const prefixMatch = rawInput.match(prefixRegex);
                if (prefixMatch) {
                    if (prefixMatch[4] && prefixMatch[4].length > 0 && /\s$/.test(rawInput)) {
                        isPasswordInputActive = true;
                        passwordMaskStartIndex = rawInput.length;
                    }
                }
            }
            updateVisualInput();
            if (!['ArrowUp', 'ArrowDown'].includes(event?.key)) {
                 historyIndex = commandHistory.length;
            }
        });


        // --- Initialization ---
        window.onload = async () => { // Made async
            console.warn("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.");
            try {
                await initDB(); // Initialize IndexedDB first
                currentUser = DEFAULT_USER;
                await loadFileSystemData(currentUser); // Load initial FS (async)
                loadAutomaticSessionState(currentUser); // Load UI state (sync)
                setTimeout(() => { if (!isEditingFile) hiddenInput.focus(); }, 100);
                console.log(`${OS_NAME} v.${OS_VERSION} (Diag User Test Fixes II) loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                appendToOutput("FATAL ERROR: OopisOs could not start. Check console.", true);
            }
        };
    </script></body>
</html>
