<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 0.9.3 - Word Wrap Wonder</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
            line-height: 1.2em;
        }

        .input-line-container {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }
        .prompt-container {
            display: flex;
            align-items: center;
            line-height: 1.2em;
            flex-shrink: 0;
            white-space: nowrap;
            padding-top: 0.1em;
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container {
            flex-grow: 1;
            min-width: 0;
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            outline: none;
            caret-color: #00ff00;
            color: #00ff00;
            width: 100%;
        }
        
        #hidden-legacy-input {
             position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;
        }

        .error-message { color: #ff4136; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .console-log-message { color: #aaaaaa; }
        .editor-message { color: #7fdbff; }
        
        .directory-item { color: #7fdbff; }
        .file-item { color: #00ff00; }

        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; margin-left: 5px;} 
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; position: relative; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        
        #editor-line-gutter {
            width: 40px; 
            padding: 10px 5px 10px 0;
            text-align: right;
            color: #555; 
            background-color: #0c0c0c; 
            overflow-y: hidden; 
            flex-shrink: 0;
            font-size: 1em; 
            line-height: 1.2em; 
            white-space: pre; 
            user-select: none; 
            box-sizing: border-box;
        }

        #editor-textarea-wrapper { border-right: 1px solid #333; padding-left:0; }
        #editor-textarea { 
            width: 100%; height: 100%; 
            background-color: #0c0c0c; color: #00dd00; 
            border: none; font-family: 'VT323', monospace; 
            font-size: 1em; line-height: 1.2em; 
            resize: none; outline: none; padding: 0 10px 0 0; 
            box-sizing: border-box;
            /* Default word wrap for textarea is pre-wrap, which is good.
               We'll control it via JS and the 'wrap' attribute or CSS classes. */
        }
        /* CSS class to disable word wrap on textarea */
        #editor-textarea.no-wrap {
            white-space: pre;
            overflow-x: auto; /* Show scrollbar when not wrapping */
        }


        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        
        /* Markdown Preview Specific Styles */
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre { background-color: #222; padding: 10px; overflow-x: auto; border-radius: 3px;} /* Default: no wrap */
        .markdown-preview pre > code { display: block; padding: 0; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }

        /* Class to enable word wrap on Markdown preview code blocks */
        .markdown-preview.word-wrap-enabled pre {
            white-space: pre-wrap;
            word-break: break-all; /* or overflow-wrap: break-word; */
        }
        
        #editor-status-bar {
            padding: 3px 10px;
            font-size: 0.85em;
            color: #888;
            border-top: 1px solid #333;
            background-color: #111; 
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
        }
        #editor-status-bar span { margin-right: 15px; }


        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            <input type="text" id="hidden-legacy-input" style="position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;">
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const Config = (() => {
            'use strict';
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore"
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "0.9.3", // Updated Version
                    DEFAULT_HOST_NAME: "OopisOs"
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                    RESERVED_USERNAMES: ["guest", "root", "admin", "system"], 
                    MIN_USERNAME_LENGTH: 3,
                    MAX_USERNAME_LENGTH: 20
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    PROMPT_CHAR: ">",
                    PROMPT_SEPARATOR: ":",
                    PROMPT_AT: "@"
                },
                STORAGE_KEYS: {
                    USER_CREDENTIALS: 'oopisOsUserCredentials',
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                    EDITOR_WORD_WRAP_ENABLED: 'oopisOsEditorWordWrapEnabled' // New storage key
                },
                CSS_CLASSES: { 
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    EDITOR_MSG: 'editor-message',
                    DIR_ITEM: 'directory-item',
                    FILE_ITEM: 'file-item',
                    OUTPUT_LINE: 'output-line'
                },
                EDITOR: {
                    DEBOUNCE_DELAY_MS: 250,
                    TAB_REPLACEMENT: "\t", 
                    CTRL_S_ACTION: 'save_exit',
                    CTRL_O_ACTION: 'exit_no_save',
                    CTRL_P_ACTION: 'toggle_preview',
                    DEFAULT_MODE: 'text',
                    MODES: {
                        TEXT: 'text',
                        MARKDOWN: 'markdown',
                        HTML: 'html'
                    },
                    EXTENSIONS_MAP: {
                        'md': 'markdown',
                        'html': 'html',
                        'htm': 'html',
                        'sh': 'text' 
                    },
                    VIEW_MODES: {
                        SPLIT: 'split',
                        EDIT_ONLY: 'edit',
                        PREVIEW_ONLY: 'preview'
                    },
                    WORD_WRAP_DEFAULT_ENABLED: true // New config for word wrap
                },
                FILESYSTEM: {
                    ROOT_PATH: '/',
                    CURRENT_DIR_SYMBOL: '.',
                    PARENT_DIR_SYMBOL: '..',
                    DEFAULT_DIRECTORY_TYPE: 'directory',
                    DEFAULT_FILE_TYPE: 'file',
                    PATH_SEPARATOR: '/'
                },
                MESSAGES: {
                    CONFIRMATION_PROMPT: "Type 'YES' (all caps) to confirm, or any other input to cancel.",
                    OPERATION_CANCELLED: "Operation cancelled.",
                    ALREADY_LOGGED_IN_AS_PREFIX: "Already logged in as '",
                    ALREADY_LOGGED_IN_AS_SUFFIX: "'.",
                    NO_ACTION_TAKEN: "No action taken.",
                    ALREADY_IN_DIRECTORY_PREFIX: "Already in '",
                    ALREADY_IN_DIRECTORY_SUFFIX: "'.",
                    DIRECTORY_EMPTY: "Directory is empty.",
                    TIMESTAMP_UPDATED_PREFIX: "Timestamp of '",
                    TIMESTAMP_UPDATED_SUFFIX: "' updated.",
                    FILE_CREATED_SUFFIX: "' created.",
                    DIRECTORY_CREATED_SUFFIX: "' created.",
                    ITEM_REMOVED_SUFFIX: "' removed.",
                    FORCIBLY_REMOVED_PREFIX: "Forcibly removed '",
                    FORCIBLY_REMOVED_SUFFIX: "'.",
                    REMOVAL_CANCELLED_PREFIX: "Removal of '",
                    REMOVAL_CANCELLED_SUFFIX: "' cancelled.",
                    MOVED_PREFIX: "Moved '",
                    MOVED_TO: "' to '",
                    MOVED_SUFFIX: "'.",
                    COPIED_PREFIX: "Copied '",
                    COPIED_TO: "' to '",
                    COPIED_SUFFIX: "'.",
                    SESSION_SAVED_FOR_PREFIX: "Session manually saved for ",
                    SESSION_LOADED_MSG: "Session loaded from manual save.",
                    LOAD_STATE_CANCELLED: "Load state cancelled.",
                    NO_MANUAL_SAVE_FOUND_PREFIX: "No manually saved state found for ",
                    WELCOME_PREFIX: "Welcome, ",
                    WELCOME_SUFFIX: "! Type 'help' for commands.",
                    EXPORTING_PREFIX: "Exporting '",
                    EXPORTING_SUFFIX: "'... Check your browser downloads.",
                    BACKUP_CREATING_PREFIX: "Creating backup '",
                    BACKUP_CREATING_SUFFIX: "'... Check your browser downloads.",
                    RESTORE_CANCELLED_NO_FILE: "Restore cancelled: No file selected.",
                    RESTORE_SUCCESS_PREFIX: "Session for user '",
                    RESTORE_SUCCESS_MIDDLE: "' successfully restored from '",
                    RESTORE_SUCCESS_SUFFIX: "'.",
                    UPLOAD_NO_FILE: "Upload cancelled: No file selected.",
                    UPLOAD_INVALID_TYPE_PREFIX: "Error: Invalid file type '",
                    UPLOAD_INVALID_TYPE_SUFFIX: "'. Only .txt, .md, .html, .sh files are allowed.", 
                    UPLOAD_SUCCESS_PREFIX: "File '",
                    UPLOAD_SUCCESS_MIDDLE: "' uploaded successfully to '",
                    UPLOAD_SUCCESS_SUFFIX: "'.",
                    UPLOAD_READ_ERROR_PREFIX: "Error reading file '",
                    UPLOAD_READ_ERROR_SUFFIX: "'.",
                    NO_COMMANDS_IN_HISTORY: "No commands in history.",
                    EDITOR_DISCARD_CONFIRM: "You have unsaved changes. Discard them and exit?"
                },
                INTERNAL_ERRORS: {
                    DB_NOT_INITIALIZED_FS_SAVE: "DB not initialized for FS save",
                    DB_NOT_INITIALIZED_FS_LOAD: "DB not initialized for FS load",
                    DB_NOT_INITIALIZED_FS_DELETE: "DB not initialized for FS delete",
                    DB_NOT_INITIALIZED_FS_CLEAR: "DB not initialized for clearing all FS",
                    CORRUPTED_FS_DATA_PRE_SAVE: "Corrupted FS data before saving.",
                    REDIRECTION_FILE_NOT_SPECIFIED: "internal error: redirection file not specified.",
                    SOURCE_NOT_FOUND_IN_PARENT_PREFIX: "internal error: source '",
                    SOURCE_NOT_FOUND_IN_PARENT_MIDDLE: "' not found in parent '",
                    SOURCE_NOT_FOUND_IN_PARENT_SUFFIX: "'"
                }
            };
        })();

        // --- DOM ELEMENTS CACHE ---
        let DOM = {}; 

        // --- UTILITY FUNCTIONS ---
        const Utils = (() => {
            'use strict';
            function formatConsoleArgs(args) {
                return Array.from(args)
                    .map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg))
                    .join(' ');
            }
            function deepCopyNode(node) {
                return node ? JSON.parse(JSON.stringify(node)) : null;
            }
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            function getFileExtension(filePath) {
                if (!filePath || typeof filePath !== 'string') return '';
                const name = filePath.substring(filePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const lastDot = name.lastIndexOf('.');
                if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) { 
                    return '';
                }
                return name.substring(lastDot + 1).toLowerCase();
            }

            function createElement(tag, attributes = {}, children = []) {
                const element = document.createElement(tag);
                for (const key in attributes) {
                    if (attributes.hasOwnProperty(key)) {
                        if (key === 'textContent') {
                            element.textContent = attributes[key];
                        } else if (key === 'innerHTML') {
                            element.innerHTML = attributes[key];
                        } else if (key === 'classList' && Array.isArray(attributes[key])) {
                            attributes[key].forEach(cls => element.classList.add(cls));
                        } else if (key === 'style' && typeof attributes[key] === 'object') {
                            for (const styleProp in attributes[key]) {
                                if (attributes[key].hasOwnProperty(styleProp)) {
                                    element.style[styleProp] = attributes[key][styleProp];
                                }
                            }
                        } else if (key === 'eventListeners' && typeof attributes[key] === 'object') {
                            for (const eventType in attributes[key]) {
                                if (attributes[key].hasOwnProperty(eventType) && typeof attributes[key][eventType] === 'function') {
                                    element.addEventListener(eventType, attributes[key][eventType]);
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, attributes[key]);
                        }
                    }
                }
                children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else if (child instanceof HTMLElement) {
                        element.appendChild(child);
                    }
                });
                return element;
            }

            function validateArguments(argsArray, config = {}) {
                const argCount = argsArray.length;

                if (typeof config.exact === 'number') {
                    if (argCount !== config.exact) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected exactly ${config.exact} argument${config.exact === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                } else {
                    if (typeof config.min === 'number' && argCount < config.min) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected at least ${config.min} argument${config.min === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                    if (typeof config.max === 'number' && argCount > config.max) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected at most ${config.max} argument${config.max === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                }
                return { isValid: true };
            }
            
            function parseNumericArg(argString, options = {}) {
                const { allowFloat = false, allowNegative = false, min, max } = options;
                const num = allowFloat ? parseFloat(argString) : parseInt(argString, 10);

                if (isNaN(num)) {
                    return { value: null, error: "is not a valid number" };
                }
                if (!allowNegative && num < 0) {
                    return { value: null, error: "must be a non-negative number" };
                }
                if (min !== undefined && num < min) {
                    return { value: null, error: `must be at least ${min}` };
                }
                if (max !== undefined && num > max) {
                    return { value: null, error: `must be at most ${max}` };
                }
                return { value: num, error: null };
            }

            function validateUsernameFormat(username) {
                if (!username || typeof username !== 'string' || username.trim() === "") {
                    return { isValid: false, error: "Username cannot be empty." };
                }
                if (username.includes(" ")) {
                    return { isValid: false, error: "Username cannot contain spaces." };
                }
                if (Config.USER.RESERVED_USERNAMES.includes(username.toLowerCase())) {
                    return { isValid: false, error: `Cannot use '${username}'. This username is reserved.` };
                }
                if (username.length < Config.USER.MIN_USERNAME_LENGTH) {
                    return { isValid: false, error: `Username must be at least ${Config.USER.MIN_USERNAME_LENGTH} characters long.` };
                }
                if (username.length > Config.USER.MAX_USERNAME_LENGTH) {
                    return { isValid: false, error: `Username cannot exceed ${Config.USER.MAX_USERNAME_LENGTH} characters.` };
                }
                return { isValid: true, error: null };
            }

            function parseFlags(argsArray, flagDefinitions) {
                const flags = {};
                const remainingArgs = [];
                const definedFlags = new Set();

                flagDefinitions.forEach(def => {
                    flags[def.name] = false; 
                    if(def.short) definedFlags.add(def.short);
                    if(def.long) definedFlags.add(def.long);
                });

                for (const arg of argsArray) {
                    let isFlag = false;
                    for (const def of flagDefinitions) {
                        if (arg === def.short || arg === def.long) {
                            flags[def.name] = true;
                            isFlag = true;
                            break;
                        }
                    }
                    if (!isFlag) {
                        remainingArgs.push(arg);
                    }
                }
                return { flags, remainingArgs };
            }


            return {
                formatConsoleArgs,
                deepCopyNode,
                formatBytes,
                getFileExtension,
                createElement,
                validateArguments,
                parseNumericArg,
                validateUsernameFormat,
                parseFlags 
            };
        })();

        // --- OUTPUT MANAGER ---
        const OutputManager = (() => {
            'use strict';
            let isEditorActive = false;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;

            function setEditorActive(status) {
                isEditorActive = status;
            }

            async function appendToOutput(text, options = {}) {
                if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MSG && !options.isCompletionSuggestion) { 
                    return; 
                }
                if (!DOM.outputDiv) { 
                    originalConsoleError("OutputManager.appendToOutput: DOM.outputDiv is not defined. Message:", text);
                    return;
                }

                const { typeClass = null } = options;
                const lines = String(text).split('\n');
                const fragment = document.createDocumentFragment(); 

                for (const line of lines) {
                    const lineAttributes = {
                        classList: [Config.CSS_CLASSES.OUTPUT_LINE],
                        textContent: line
                    };
                    if (typeClass) {
                        lineAttributes.classList.push(typeClass);
                    } else if (options.isError) { 
                        lineAttributes.classList.push(Config.CSS_CLASSES.ERROR_MSG);
                    }
                    const newLineElement = Utils.createElement('div', lineAttributes);
                    fragment.appendChild(newLineElement);
                }
                DOM.outputDiv.appendChild(fragment); 
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }

            function appendHtmlToOutput(htmlContent) { 
                if (isEditorActive) return;
                if (!DOM.outputDiv) {
                    originalConsoleError("OutputManager.appendHtmlToOutput: DOM.outputDiv is not defined.");
                    return;
                }
                const blockDiv = Utils.createElement('div', { innerHTML: htmlContent });
                DOM.outputDiv.appendChild(blockDiv);
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }

            function clearOutput() {
                if (!isEditorActive && DOM.outputDiv) {
                    DOM.outputDiv.innerHTML = '';
                }
            }

            function _consoleLogOverride(...args) {
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') { 
                    appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                originalConsoleLog.apply(console, args);
            }
            function _consoleWarnOverride(...args) {
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') {
                    appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                }
                originalConsoleWarn.apply(console, args);
            }
            function _consoleErrorOverride(...args) {
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') {
                    appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                }
                originalConsoleError.apply(console, args);
            }

            function initializeConsoleOverrides() {
                if (typeof Utils === 'undefined' || typeof Utils.formatConsoleArgs !== 'function') {
                    originalConsoleError("OutputManager: Cannot initialize console overrides, Utils or Utils.formatConsoleArgs is not defined.");
                    return; 
                }
                console.log = _consoleLogOverride;
                console.warn = _consoleWarnOverride;
                console.error = _consoleErrorOverride;
            }

            return {
                setEditorActive,
                appendToOutput,
                appendHtmlToOutput,
                clearOutput,
                initializeConsoleOverrides 
            };
        })();

        // --- LOCAL STORAGE MANAGER ---
        const StorageManager = (() => {
            'use strict';
            function loadItem(key, itemName, defaultValue = null) { // Renamed from loadJSON as it can store non-JSON
                try {
                    const storedValue = localStorage.getItem(key);
                    if (storedValue !== null) { // Check for null explicitly
                        if (key === Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED) { // Handle boolean specifically
                            return storedValue === 'true';
                        }
                        // Attempt to parse if it looks like JSON, otherwise return as string
                        try {
                            return JSON.parse(storedValue);
                        } catch (e) {
                            return storedValue; // Return as string if not JSON
                        }
                    }
                } catch (e) {
                     if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') { 
                        OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                     } else {
                        console.warn(`StorageManager: OutputManager not available. ${itemName} for '${key}' corrupted.`);
                     }
                }
                return defaultValue;
            }
            function saveItem(key, data, itemName) { // Renamed from saveJSON
                try {
                    const valueToStore = (typeof data === 'object' && data !== null) ? JSON.stringify(data) : String(data);
                    localStorage.setItem(key, valueToStore);
                    return true;
                } catch (e) {
                    if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                        OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else {
                        console.error(`StorageManager: OutputManager not available. Error saving ${itemName} for '${key}'.`);
                    }
                }
                return false;
            }
            function removeItem(key) { localStorage.removeItem(key); }
            function getAllLocalStorageKeys() { 
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    keys.push(localStorage.key(i));
                }
                return keys;
            }
            return { loadItem, saveItem, removeItem, getAllLocalStorageKeys }; // Updated function names
        })();
        
        // --- INDEXEDDB MANAGER ---
        const IndexedDBManager = (() => {
            'use strict';
            let dbInstance = null;
            let hasLoggedNormalInitialization = false;

            function init() { 
                return new Promise((resolve, reject) => {
                    if (dbInstance) {
                        resolve(dbInstance);
                        return;
                    }
                    const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION);
                    request.onupgradeneeded = (event) => {
                        const tempDb = event.target.result;
                        if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) {
                            tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        if (!hasLoggedNormalInitialization) {
                            if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') { 
                                 OutputManager.appendToOutput("FileSystem DB initialized.", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            } else {
                                console.log("FileSystem DB initialized (OutputManager not ready for terminal log).");
                            }
                            hasLoggedNormalInitialization = true;
                        }
                        resolve(dbInstance);
                    };
                    request.onerror = (event) => {
                        const errorMsg = "Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private Browse mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.";
                        if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                            OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        } else {
                            console.error(errorMsg); 
                        }
                        console.error("Database error details: ", event.target.error); 
                        reject(event.target.error);
                    };
                });
            }
            function getDbInstance() { 
                if (!dbInstance) {
                    const errorMsg = "Error: OopisOs file system storage is not available. Please ensure browser storage is enabled and the page is reloaded.";
                     if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                        OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else {
                        console.error(errorMsg); 
                    }
                    throw new Error("IndexedDB not initialized.");
                }
                return dbInstance;
            }
            return { init, getDbInstance };
        })();

        // --- FILE SYSTEM MANAGER ---
        const FileSystemManager = (() => {
            'use strict';
            let fsData = {}; 
            let currentPath = Config.FILESYSTEM.ROOT_PATH;

            function _getFileSystemKey(user) { return `fs_${user}`; }
            
            async function initialize(user) {
                fsData = {
                    [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} }
                };
            }
            async function save(user) {
                const db = IndexedDBManager.getDbInstance(); 
                if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_SAVE);
                }
                return new Promise((resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const dataToSave = Utils.deepCopyNode(fsData); 
                        if (!dataToSave || typeof dataToSave !== 'object' || !dataToSave[Config.FILESYSTEM.ROOT_PATH] || dataToSave[Config.FILESYSTEM.ROOT_PATH].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            console.error("Attempted to save invalid fsData structure for user:", user, dataToSave);
                            OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            return reject(new Error(Config.INTERNAL_ERRORS.CORRUPTED_FS_DATA_PRE_SAVE));
                        }
                        const request = store.put({ id: _getFileSystemKey(user), data: dataToSave });
                        request.onsuccess = () => resolve(true);
                        request.onerror = (event) => {
                            console.error(`Error saving FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            reject(event.target.error);
                        };
                    } catch (e) { 
                        console.error(`Error initiating save transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(e);
                    }
                });
            }
            async function load(user) {
                const db = IndexedDBManager.getDbInstance(); 
                 if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    await initialize(user); 
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_LOAD);
                }
                return new Promise(async (resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const request = store.get(_getFileSystemKey(user));
                        request.onsuccess = async (event) => {
                            const result = event.target.result;
                            if (result && result.data && result.data[Config.FILESYSTEM.ROOT_PATH]?.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                fsData = result.data;
                            } else {
                                const message = result ? `Warning: File system for '${user}' appears invalid or corrupted. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`;
                                const messageType = result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG;
                                OutputManager.appendToOutput(message, { typeClass: messageType });
                                await initialize(user);
                                await save(user); 
                            }
                            resolve();
                        };
                        request.onerror = async (event) => {
                            console.error(`Error loading FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            await initialize(user);
                            await save(user); 
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating load transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        await initialize(user);
                        await save(user);
                        reject(e);
                    }
                });
            }
            async function deleteUserFS(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_DELETE);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.delete(_getFileSystemKey(user));
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error deleting FS for ${user}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            async function clearAllFS() {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                     OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_CLEAR);
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.clear(); 
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error("Error clearing FileSystemsStore:", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(event.target.error);
                    };
                });
            }

            function getCurrentPath() { return currentPath; }
            function setCurrentPath(path) { currentPath = path; }
            function getFsData() { return fsData; }
            function setFsData(newData) { fsData = newData; }
            
            function getAbsolutePath(targetPath, basePath) {
                if (!targetPath) targetPath = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                let effectiveBasePath = basePath; 
                if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    effectiveBasePath = Config.FILESYSTEM.ROOT_PATH;
                }
                const baseSegments = effectiveBasePath === Config.FILESYSTEM.ROOT_PATH ? [] : effectiveBasePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s && s !== Config.FILESYSTEM.CURRENT_DIR_SYMBOL);
                let resolvedSegments = [...baseSegments];
                const targetSegments = targetPath.split(Config.FILESYSTEM.PATH_SEPARATOR);
                for (const segment of targetSegments) {
                    if (segment === '' || segment === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR) && resolvedSegments.length === 0 && segment === '') {}
                        continue;
                    }
                    if (segment === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                        if (resolvedSegments.length > 0) resolvedSegments.pop(); 
                    } else {
                        resolvedSegments.push(segment); 
                    }
                }
                if (resolvedSegments.length === 0) return Config.FILESYSTEM.ROOT_PATH;
                return Config.FILESYSTEM.PATH_SEPARATOR + resolvedSegments.join(Config.FILESYSTEM.PATH_SEPARATOR);
            }
            function getNodeByPath(path) {
                const absolutePath = getAbsolutePath(path, currentPath);
                if (absolutePath === Config.FILESYSTEM.ROOT_PATH) return fsData[Config.FILESYSTEM.ROOT_PATH];
                const segments = absolutePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                for (const segment of segments) {
                    if (currentNode && currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && currentNode.children && currentNode.children[segment]) {
                        currentNode = currentNode.children[segment];
                    } else { return null; }
                }
                return currentNode;
            }
            function createParentDirectoriesIfNeeded(fullPath) {
                if (fullPath === Config.FILESYSTEM.ROOT_PATH) return { parentNode: null, error: "Cannot create parent for root." };
                const lastSlashIndex = fullPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                const parentPath = (lastSlashIndex === 0) ? Config.FILESYSTEM.ROOT_PATH : fullPath.substring(0, lastSlashIndex);
                const newFileName = fullPath.substring(lastSlashIndex + 1); 
                if (!newFileName || newFileName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || newFileName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` };
                if (parentPath === Config.FILESYSTEM.ROOT_PATH) return { parentNode: fsData[Config.FILESYSTEM.ROOT_PATH], error: null };
                const parentPathSegments = parentPath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentDirNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                let currentBuiltParentPath = ""; 
                for (const segment of parentPathSegments) {
                    currentBuiltParentPath += Config.FILESYSTEM.PATH_SEPARATOR + segment;
                    if (!currentDirNode.children[segment]) {
                        currentDirNode.children[segment] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                    } else if (currentDirNode.children[segment].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                    }
                    currentDirNode = currentDirNode.children[segment]; 
                }
                return { parentNode: currentDirNode, error: null }; 
            }
            function calculateNodeSize(node) {
                if (!node) return 0;
                if (node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) return (node.content || "").length; 
                if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    let totalSize = 0;
                    for (const childName in node.children) totalSize += calculateNodeSize(node.children[childName]); 
                    return totalSize;
                }
                return 0; 
            }
            function validatePath(commandName, pathArg, options = {}) {
                const { expectedType = 'any', allowMissing = false, disallowRoot = false, defaultToCurrentIfEmpty = true } = options;
                let effectivePathArg = pathArg;
                if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) effectivePathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                if (effectivePathArg === undefined || effectivePathArg === null) return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
                const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath());
                const node = getNodeByPath(resolvedPath);
                if (disallowRoot && resolvedPath === Config.FILESYSTEM.ROOT_PATH) return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '${Config.FILESYSTEM.ROOT_PATH}'` };
                if (node) { 
                    if (expectedType === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_FILE_TYPE) return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                    if (expectedType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                    return { node: node, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                } else { 
                    if (allowMissing) return { node: null, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                    else return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory`, optionsUsed: options };
                }
            }

            return {
                initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath,
                getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded,
                calculateNodeSize, validatePath
            };
        })();

        // --- COMMAND HISTORY MANAGER ---
        const HistoryManager = (() => { 
            'use strict';
            let commandHistory = [];
            let historyIndex = 0; 
            function add(command) {
                const trimmedCommand = command.trim();
                if (trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                    commandHistory.push(trimmedCommand);
                    if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) {
                        commandHistory.shift(); 
                    }
                }
                historyIndex = commandHistory.length; 
            }
            function getPrevious() {
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    return commandHistory[historyIndex];
                }
                return null; 
            }
            function getNext() {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    return commandHistory[historyIndex];
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    return ""; 
                }
                return null; 
            }
            function resetIndex() { historyIndex = commandHistory.length; }
            function getFullHistory() { return [...commandHistory]; }
            function clearHistory() { commandHistory = []; historyIndex = 0;}
            function setHistory(newHistory) { commandHistory = Array.isArray(newHistory) ? [...newHistory] : []; historyIndex = commandHistory.length; }
            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();

        // --- CONFIRMATION MANAGER ---
        const ConfirmationManager = (() => { 
            'use strict';
            let awaitingConfirmation = false;
            let confirmationContext = null; 
            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
                awaitingConfirmation = true;
                confirmationContext = {
                    promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                    data: dataForAction,
                    onConfirm: onConfirmCallback,
                    onCancel: onCancelCallback
                };
                confirmationContext.promptMessageLines.forEach(line => OutputManager.appendToOutput(line, { typeClass: Config.CSS_CLASSES.WARNING_MSG }));
                OutputManager.appendToOutput(Config.MESSAGES.CONFIRMATION_PROMPT, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                TerminalUI.clearInput(); 
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput();
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }
            async function handleConfirmation(input) {
                if (!awaitingConfirmation || !confirmationContext) return false; 
                let processed = false;
                if (input.trim() === 'YES' && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                    processed = true;
                } else {
                    if (typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    }
                    processed = true;
                }
                awaitingConfirmation = false;
                confirmationContext = null;
                return processed; 
            }
            function isAwaiting() { return awaitingConfirmation; }
            return { request, handleConfirmation, isAwaiting };
        })();

        // --- EDITOR MANAGER ---
        const EditorManager = (() => { 
            'use strict';
            let isActiveState = false;
            let currentFilePath = null;
            let currentFileMode = Config.EDITOR.DEFAULT_MODE; 
            let currentViewMode = Config.EDITOR.VIEW_MODES.SPLIT; 
            let isWordWrapActive = Config.EDITOR.WORD_WRAP_DEFAULT_ENABLED; // New state for word wrap
            let debounceTimer = null; 
            
            let editorContainerDiv = null, editorControlsDiv = null, editorFilenameDisplay = null;
            let viewToggleButton = null, exportPreviewButton = null, wordWrapToggleButton = null; // Added wordWrapToggleButton
            let editorMainAreaDiv = null, editorLineGutter = null, editorTextareaWrapper = null, editorTextareaElement = null;
            let editorPreviewWrapper = null, editorPreviewPaneDiv = null;
            let editorStatusBar = null, statusBarLineCount = null, statusBarWordCount = null, statusBarCharCount = null, statusBarCursorPos = null;
            let editorInstructionsFooter = null;

            let originalContent = ""; 
            let isDirty = false;      

            function _determineMode(filePath) { const extension = Utils.getFileExtension(filePath); return Config.EDITOR.EXTENSIONS_MAP[extension] || Config.EDITOR.DEFAULT_MODE; }
            
            function _updateFilenameDisplay() {
                if (editorFilenameDisplay) {
                    editorFilenameDisplay.textContent = `File: ${currentFilePath || "Untitled"}${isDirty ? "*" : ""}`;
                }
            }

            function _updateStatusBar() {
                if (!editorTextareaElement || !editorStatusBar) return;

                const text = editorTextareaElement.value;
                const lines = text.split('\n');
                const lineCount = lines.length;
                const charCount = text.length;
                const wordCount = text.trim() === '' ? 0 : text.trim().split(/\s+/).filter(Boolean).length;

                const cursorPos = editorTextareaElement.selectionStart;
                let currentLineNum = 0; 
                let currentColNum = 0; 
                let charCounter = 0;
                for (let i = 0; i < lines.length; i++) {
                    const lineLengthWithNewline = lines[i].length + 1; 
                    if (cursorPos >= charCounter && cursorPos < charCounter + lineLengthWithNewline) {
                        currentLineNum = i;
                        currentColNum = cursorPos - charCounter;
                        break;
                    }
                    charCounter += lineLengthWithNewline;
                }
                if (cursorPos === text.length && !text.endsWith('\n')) {
                     currentLineNum = lines.length -1;
                     currentColNum = lines[lines.length-1].length;
                } else if (cursorPos === text.length && text.endsWith('\n')){
                     currentLineNum = lines.length -1; 
                     currentColNum = 0; 
                }


                if(statusBarLineCount) statusBarLineCount.textContent = `Lines: ${lineCount}`;
                if(statusBarWordCount) statusBarWordCount.textContent = `Words: ${wordCount}`;
                if(statusBarCharCount) statusBarCharCount.textContent = `Chars: ${charCount}`;
                if(statusBarCursorPos) statusBarCursorPos.textContent = `Ln: ${currentLineNum + 1}, Col: ${currentColNum + 1}`;
            }

            function _updateLineNumbers() {
                if (!editorTextareaElement || !editorLineGutter) return;
                const lines = editorTextareaElement.value.split('\n').length;
                const numbersArray = [];
                for(let i=1; i <= lines; i++) {
                    numbersArray.push(i);
                }
                editorLineGutter.textContent = numbersArray.join('\n');
                editorLineGutter.scrollTop = editorTextareaElement.scrollTop;
            }

            // --- Word Wrap Specific Functions ---
            function _loadWordWrapSetting() {
                const savedSetting = StorageManager.loadItem(Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED, "Editor word wrap setting");
                isWordWrapActive = (savedSetting !== null) ? savedSetting : Config.EDITOR.WORD_WRAP_DEFAULT_ENABLED;
            }

            function _saveWordWrapSetting() {
                StorageManager.saveItem(Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED, isWordWrapActive, "Editor word wrap setting");
            }

            function _applyWordWrapToTextarea() {
                if (!editorTextareaElement) return;
                if (isWordWrapActive) {
                    editorTextareaElement.setAttribute('wrap', 'soft'); // 'soft' is default-like, uses CSS for appearance
                    editorTextareaElement.classList.remove('no-wrap');
                } else {
                    editorTextareaElement.setAttribute('wrap', 'off');
                    editorTextareaElement.classList.add('no-wrap');
                }
            }

            function _applyWordWrapToMarkdownPreview() {
                if (!editorPreviewPaneDiv || currentFileMode !== Config.EDITOR.MODES.MARKDOWN) return;
                if (isWordWrapActive) {
                    editorPreviewPaneDiv.classList.add('word-wrap-enabled');
                } else {
                    editorPreviewPaneDiv.classList.remove('word-wrap-enabled');
                }
            }
            
            function _applyWordWrapToHtmlPreview() {
                // This is handled by _updatePreview by injecting styles into the iframe
                if (currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview(); // Re-render preview with new wrap state
                }
            }

            function _updateWordWrapToggleButtonText() {
                if (wordWrapToggleButton) {
                    wordWrapToggleButton.textContent = isWordWrapActive ? "Wrap: On" : "Wrap: Off";
                }
            }

            function _toggleWordWrap() {
                isWordWrapActive = !isWordWrapActive;
                _saveWordWrapSetting();
                _applyWordWrapToTextarea();
                _applyWordWrapToMarkdownPreview();
                _applyWordWrapToHtmlPreview(); // This will trigger _updatePreview for HTML
                _updateWordWrapToggleButtonText();
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") editorTextareaElement.focus();
            }
            // --- End Word Wrap Specific Functions ---


            function _updatePreview() {
                if (!editorTextareaElement || !editorPreviewPaneDiv) return;
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                const content = editorTextareaElement.value;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        if (typeof marked !== 'undefined') editorPreviewPaneDiv.innerHTML = marked.parse(content);
                        else editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded.";
                        _applyWordWrapToMarkdownPreview(); // Ensure class is correctly applied after content update
                    } else if (currentFileMode === Config.EDITOR.MODES.HTML) {
                        let iframe = editorPreviewPaneDiv.querySelector('iframe');
                        if (!iframe) { 
                            iframe = Utils.createElement('iframe'); 
                            editorPreviewPaneDiv.innerHTML = ''; 
                            editorPreviewPaneDiv.appendChild(iframe); 
                        }
                        // Inject word wrap styles for <pre> tags if word wrap is active
                        let injectedStyles = "";
                        if (isWordWrapActive) {
                            injectedStyles = `<style> pre { white-space: pre-wrap !important; word-break: break-all !important; overflow-wrap: break-word !important; } </style>`;
                        }
                        iframe.srcdoc = `${injectedStyles}<style>${_getPreviewStylingCSS(true)}</style>${content}`; 
                    }
                }, Config.EDITOR.DEBOUNCE_DELAY_MS);
            }

            function _handleEditorInput() {
                const currentContent = editorTextareaElement.value;
                isDirty = (currentContent !== originalContent);
                _updateFilenameDisplay();
                _updateLineNumbers();
                _updateStatusBar();
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview();
                }
            }
            
            function _handleEditorScroll() {
                 if(editorLineGutter && editorTextareaElement) {
                    editorLineGutter.scrollTop = editorTextareaElement.scrollTop;
                 }
            }
            
            function _handleEditorSelectionChange() { 
                _updateStatusBar();
            }

            function _getPreviewStylingCSS(isForHtmlIframe = false) { // Added parameter
                // Base styles for Markdown preview and potentially basic HTML preview styling
                let styles = `
                    body { font-family: 'VT323', monospace; background-color: #111; color: #ccc; margin: 20px; line-height: 1.2em; }
                    h1, h2, h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
                    p { margin-bottom: 0.5em; line-height: 1.4; }
                    code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
                    pre { background-color: #222; padding: 10px; overflow-x: auto; border-radius: 3px;} /* Default no-wrap for pre */
                    pre > code { display: block; padding: 0; }
                    ul, ol { margin-left: 20px; margin-bottom: 0.5em;}
                    blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
                    a { color: #39cccc; text-decoration: underline; }
                `;
                // If for HTML iframe, we might not need to re-declare .markdown-preview specific classes
                // but the general element styling is fine.
                // The word wrap for <pre> in HTML iframe is handled by direct injection in _updatePreview.
                if (!isForHtmlIframe) {
                     styles = `
                        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
                        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
                        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
                        .markdown-preview pre { background-color: #222; padding: 10px; overflow-x: auto; border-radius: 3px;}
                        .markdown-preview pre > code { display: block; padding: 0; }
                        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
                        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
                        .markdown-preview a { color: #39cccc; text-decoration: underline; }
                     ` + styles; // Prepend specific markdown styles
                }
                return styles;
            }


            async function exportPreviewAsHtml() {
                if (!isActiveState) return;
                let contentToExport = "";
                let baseFilename = "preview";
                if (currentFilePath) {
                    baseFilename = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const dotIndex = baseFilename.lastIndexOf('.');
                    if (dotIndex > 0) baseFilename = baseFilename.substring(0, dotIndex);
                }
                const downloadFilename = `${baseFilename}_preview.html`;

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN && editorPreviewPaneDiv) {
                    contentToExport = editorPreviewPaneDiv.innerHTML;
                } else if (currentFileMode === Config.EDITOR.MODES.HTML && editorTextareaElement) {
                    contentToExport = editorTextareaElement.value; // Export raw HTML content
                } else if (editorTextareaElement){ 
                     contentToExport = `<pre>${editorTextareaElement.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
                }

                const styles = _getPreviewStylingCSS(currentFileMode === Config.EDITOR.MODES.HTML);
                let injectedWordWrapStyles = "";
                if (isWordWrapActive && currentFileMode === Config.EDITOR.MODES.HTML) { // Add wrap styles if HTML mode and wrap is on
                     injectedWordWrapStyles = `pre { white-space: pre-wrap !important; word-break: break-all !important; overflow-wrap: break-word !important; }`;
                }


                const htmlDoc = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OopisOS Editor Preview - ${currentFilePath || 'Untitled'}</title>
    <style>
${styles}
${injectedWordWrapStyles} 
    </style>
</head>
<body>
    <div class="${currentFileMode === Config.EDITOR.MODES.MARKDOWN ? 'markdown-preview' : ''}">
${contentToExport}
    </div>
</body>
</html>`;
                try {
                    const blob = new Blob([htmlDoc], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = Utils.createElement('a', { href: url, download: downloadFilename });
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    OutputManager.appendToOutput(`Preview exported as '${downloadFilename}'`, { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                } catch (error) {
                    console.error("Error exporting preview:", error);
                    OutputManager.appendToOutput(`Error exporting preview: ${error.message}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                }
            }


            function _setupEditorLayout() {
                editorFilenameDisplay = Utils.createElement('span', { 
                    id: 'editor-filename-display', 
                    textContent: `File: ${currentFilePath || "Untitled"}${isDirty ? "*" : ""}` 
                });
                viewToggleButton = Utils.createElement('button', { 
                    id: 'editor-view-toggle', 
                    textContent: 'Toggle View', 
                    eventListeners: { click: _toggleViewMode } 
                });
                 exportPreviewButton = Utils.createElement('button', {
                    id: 'editor-export-preview',
                    textContent: 'Export HTML',
                    eventListeners: { click: exportPreviewAsHtml }
                });
                wordWrapToggleButton = Utils.createElement('button', { // Create word wrap button
                    id: 'editor-word-wrap-toggle',
                    textContent: isWordWrapActive ? "Wrap: On" : "Wrap: Off",
                    eventListeners: { click: _toggleWordWrap }
                });

                const controlsRightGroup = Utils.createElement('div', {}, [wordWrapToggleButton, viewToggleButton, exportPreviewButton]); // Add button to group
                editorControlsDiv = Utils.createElement('div', { id: 'editor-controls' }, [editorFilenameDisplay, controlsRightGroup]);


                editorLineGutter = Utils.createElement('div', { id: 'editor-line-gutter' });
                editorTextareaElement = Utils.createElement('textarea', { 
                    id: 'editor-textarea',
                    spellcheck: 'false', 
                    eventListeners: {
                        input: _handleEditorInput,
                        scroll: _handleEditorScroll,
                        click: _handleEditorSelectionChange, 
                        keyup: _handleEditorSelectionChange  
                    }
                });
                editorTextareaWrapper = Utils.createElement('div', { 
                    id: 'editor-textarea-wrapper', 
                    classList: ['editor-pane'] 
                }, [editorTextareaElement]);
                
                const mainAreaChildren = [editorLineGutter, editorTextareaWrapper];

                editorPreviewPaneDiv = Utils.createElement('div', { id: 'editor-preview-content' });
                editorPreviewWrapper = Utils.createElement('div', { 
                    id: 'editor-preview-wrapper', 
                    classList: ['editor-pane'] 
                }, [editorPreviewPaneDiv]);
                mainAreaChildren.push(editorPreviewWrapper);
                
                editorMainAreaDiv = Utils.createElement('div', { id: 'editor-main-area', style: { display: 'flex'} }, mainAreaChildren);
                _setViewModeUI(currentViewMode); 

                statusBarLineCount = Utils.createElement('span', { id: 'status-lines', textContent: 'Lines: 0'});
                statusBarWordCount = Utils.createElement('span', { id: 'status-words', textContent: 'Words: 0'});
                statusBarCharCount = Utils.createElement('span', { id: 'status-chars', textContent: 'Chars: 0'});
                statusBarCursorPos = Utils.createElement('span', { id: 'status-cursor', textContent: 'Ln: 1, Col: 1'});
                const statusBarLeft = Utils.createElement('div', {}, [statusBarCursorPos, statusBarLineCount]);
                const statusBarRight = Utils.createElement('div', {}, [statusBarWordCount, statusBarCharCount]);

                editorStatusBar = Utils.createElement('div', {id: 'editor-status-bar'}, [statusBarLeft, statusBarRight] );


                editorInstructionsFooter = Utils.createElement('div', { 
                    id: 'editor-instructions-footer',
                    textContent: `Ctrl+S: Save & Exit | Ctrl+O: Exit (confirm if unsaved) | Ctrl+P: Preview`
                });

                editorContainerDiv = Utils.createElement('div', { id: 'editor-container' }, [
                    editorControlsDiv,
                    editorMainAreaDiv,
                    editorStatusBar,
                    editorInstructionsFooter
                ]);
                
                DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv);
            }

             function _setViewModeUI(mode) { 
                currentViewMode = mode;
                const isPreviewable = currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML;

                if (!editorLineGutter || !editorTextareaWrapper || !editorPreviewWrapper || !viewToggleButton) return;

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                    editorPreviewPaneDiv.classList.add('markdown-preview');
                    _applyWordWrapToMarkdownPreview(); // Apply wrap state when mode changes
                } else {
                    editorPreviewPaneDiv.classList.remove('markdown-preview');
                }
                if (currentFileMode === Config.EDITOR.MODES.HTML) {
                     _applyWordWrapToHtmlPreview(); // Apply wrap state when mode changes
                }


                if (!isPreviewable) { 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "none";
                    editorPreviewWrapper.style.flex = "0";
                    viewToggleButton.style.display = 'none';
                    editorTextareaWrapper.style.borderRight = 'none';
                    return;
                }
                
                viewToggleButton.style.display = 'block'; 

                if (mode === Config.EDITOR.VIEW_MODES.SPLIT) { 
                    viewToggleButton.textContent = "Edit Only"; 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "block";  
                    editorPreviewWrapper.style.flex = "1"; 
                    editorTextareaWrapper.style.borderRight = '1px solid #333'; 
                } else if (mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) { 
                    viewToggleButton.textContent = "Preview Only"; 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "none"; 
                    editorPreviewWrapper.style.flex = "0";
                    editorTextareaWrapper.style.borderRight = 'none'; 
                } else if (mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY) { 
                    viewToggleButton.textContent = "Split View"; 
                    editorLineGutter.style.display = "none";
                    editorTextareaWrapper.style.display = "none";
                    editorTextareaWrapper.style.flex = "0"; 
                    editorPreviewWrapper.style.display = "block";  
                    editorPreviewWrapper.style.flex = "1"; 
                    editorTextareaWrapper.style.borderRight = 'none';
                }
            }
            function _toggleViewMode() {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                if (currentViewMode === Config.EDITOR.VIEW_MODES.SPLIT) _setViewModeUI(Config.EDITOR.VIEW_MODES.EDIT_ONLY);
                else if (currentViewMode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) _setViewModeUI(Config.EDITOR.VIEW_MODES.PREVIEW_ONLY);
                else _setViewModeUI(Config.EDITOR.VIEW_MODES.SPLIT);
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") editorTextareaElement.focus();
            }
            function enter(filePath, content) {
                if (isActiveState) { OutputManager.appendToOutput("Editor already active.", { typeClass: Config.CSS_CLASSES.EDITOR_MSG }); return; }
                
                _loadWordWrapSetting(); // Load wrap setting on editor entry

                isActiveState = true; 
                OutputManager.setEditorActive(true); 
                currentFilePath = filePath; 
                currentFileMode = _determineMode(filePath);
                originalContent = content; 
                isDirty = false;      

                currentViewMode = (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) ? Config.EDITOR.VIEW_MODES.SPLIT : Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                DOM.outputDiv.style.display = 'none'; 
                DOM.inputLineContainerDiv.style.display = 'none'; 
                
                _setupEditorLayout(); 
                
                editorTextareaElement.value = content;
                
                _applyWordWrapToTextarea(); // Apply current wrap state to textarea
                _updateWordWrapToggleButtonText(); // Update button text

                _updateFilenameDisplay(); 
                _updateLineNumbers();
                _updateStatusBar();

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) { 
                    _updatePreview(); 
                }
                editorTextareaElement.focus(); 
                editorTextareaElement.setSelectionRange(0,0); 
                editorTextareaElement.addEventListener('keydown', handleKeyDown); 
            }
            async function _performExitActions() {
                if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) DOM.terminalDiv.removeChild(editorContainerDiv);
                if (editorTextareaElement) { 
                    editorTextareaElement.removeEventListener('keydown', handleKeyDown); 
                    editorTextareaElement.removeEventListener('input', _handleEditorInput);
                    editorTextareaElement.removeEventListener('scroll', _handleEditorScroll);
                    editorTextareaElement.removeEventListener('click', _handleEditorSelectionChange);
                    editorTextareaElement.removeEventListener('keyup', _handleEditorSelectionChange);
                }
                // Nullify DOM references
                editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = exportPreviewButton = wordWrapToggleButton = null;
                editorMainAreaDiv = editorLineGutter = editorTextareaWrapper = editorTextareaElement = null;
                editorPreviewWrapper = editorPreviewPaneDiv = null;
                editorStatusBar = statusBarLineCount = statusBarWordCount = statusBarCharCount = statusBarCursorPos = null;
                editorInstructionsFooter = null;

                if (debounceTimer) clearTimeout(debounceTimer); debounceTimer = null;
                isActiveState = false; 
                OutputManager.setEditorActive(false); 
                currentFilePath = null; 
                currentFileMode = Config.EDITOR.DEFAULT_MODE;
                isDirty = false;
                originalContent = "";

                DOM.outputDiv.style.display = ''; 
                DOM.inputLineContainerDiv.style.display = '';
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                TerminalUI.focusInput(); 
                TerminalUI.updatePrompt(); 
            }

            async function exit(saveChanges = false) {
                let proceedToExit = true; 

                if (!saveChanges && isDirty) {
                    const userConfirmedDiscard = await new Promise((resolveConfirmation) => {
                        ConfirmationManager.request(
                            [Config.MESSAGES.EDITOR_DISCARD_CONFIRM],
                            null,
                            () => resolveConfirmation(true), 
                            () => resolveConfirmation(false) 
                        );
                    });

                    if (userConfirmedDiscard) {
                        OutputManager.appendToOutput(`Exited editor for '${currentFilePath || 'Untitled'}' without saving. Discarded changes.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    } else {
                        OutputManager.appendToOutput("Exit cancelled. Continue editing.", { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                        if(editorTextareaElement) editorTextareaElement.focus();
                        proceedToExit = false; 
                    }
                }

                if (!proceedToExit) {
                    return false; 
                }
                
                let saveSuccess = true;
                if (saveChanges && editorTextareaElement && currentFilePath) {
                    const newContent = editorTextareaElement.value;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath);
                    if (parentDirResult.error) { 
                        OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { typeClass: Config.CSS_CLASSES.EDITOR_MSG }); 
                        saveSuccess = false; 
                    } else {
                        const parentNode = parentDirResult.parentNode;
                        if (parentNode) {
                            const fileName = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: newContent };
                            const currentUser = UserManager.getCurrentUser();
                            if (currentUser) {
                                if (await FileSystemManager.save(currentUser.name)) {
                                    OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                    originalContent = newContent; 
                                    isDirty = false;
                                    _updateFilenameDisplay();
                                } else { 
                                    OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                    saveSuccess = false; 
                                }
                            } else { 
                                OutputManager.appendToOutput(`Error saving file: No current user context.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                saveSuccess = false; 
                            }
                        } else { 
                            OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                            saveSuccess = false; 
                        }
                    }
                } else if (!saveChanges && !isDirty) { 
                     OutputManager.appendToOutput(`Exited editor for '${currentFilePath || 'Untitled'}' without saving. No changes made.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                
                await _performExitActions();
                return saveSuccess; 
            }

            async function handleKeyDown(event) {
                if (event.key === 'Tab') {
                    event.preventDefault(); 
                    const start = editorTextareaElement.selectionStart;
                    const end = editorTextareaElement.selectionEnd;
                    editorTextareaElement.value = editorTextareaElement.value.substring(0, start) + Config.EDITOR.TAB_REPLACEMENT + editorTextareaElement.value.substring(end);
                    editorTextareaElement.selectionStart = editorTextareaElement.selectionEnd = start + Config.EDITOR.TAB_REPLACEMENT.length;
                    _handleEditorInput(); 
                    return;
                }
                if (event.ctrlKey) {
                    switch (event.key.toLowerCase()) {
                        case 's': event.preventDefault(); await exit(true); break;
                        case 'o': event.preventDefault(); await exit(false); break;
                        case 'p': 
                            event.preventDefault(); 
                            if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                                _toggleViewMode();
                            }
                            break;
                    }
                }
                setTimeout(_handleEditorSelectionChange, 0); 
            }
            return { isActive: () => isActiveState, enter, exit, exportPreviewAsHtml }; 
        })();

        // --- USER MANAGER ---
        const UserManager = (() => { 
            'use strict';
            let currentUser = { name: Config.USER.DEFAULT_NAME }; 
            function getCurrentUser() { return currentUser; }
            async function register(username) {
                const formatValidation = Utils.validateUsernameFormat(username);
                if (!formatValidation.isValid) {
                    return { success: false, error: formatValidation.error };
                }

                const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (users[username]) {
                    return { success: false, error: `User '${username}' already exists.` };
                }
                
                users[username] = {}; 
                if (StorageManager.saveItem(Config.STORAGE_KEYS.USER_CREDENTIALS, users, "User list")) {
                    await FileSystemManager.initialize(username); await FileSystemManager.save(username);
                    return { success: true, message: `User '${username}' registered. You can now login.` };
                } else {
                    return { success: false, error: "Failed to save new user credentials." };
                }
            }
            async function login(username) {
                if (currentUser.name === username) return { success: true, message: `${Config.MESSAGES.ALREADY_LOGGED_IN_AS_PREFIX}${username}${Config.MESSAGES.ALREADY_LOGGED_IN_AS_SUFFIX}`, noAction: true };
                const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (!users.hasOwnProperty(username)) return { success: false, error: "Invalid username." };
                if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username) SessionManager.saveAutomaticState(currentUser.name);
                currentUser = { name: username }; 
                HistoryManager.clearHistory(); 
                await FileSystemManager.load(username); 
                SessionManager.loadAutomaticState(username); 
                TerminalUI.updatePrompt(); 
                return { success: true, message: `Logged in as ${username}.` };
            }
            async function logout() {
                if (currentUser.name === Config.USER.DEFAULT_NAME) return { success: true, message: `Already logged in as Guest. ${Config.MESSAGES.NO_ACTION_TAKEN}`, noAction: true };
                SessionManager.saveAutomaticState(currentUser.name); 
                const prevUserName = currentUser.name;
                currentUser = { name: Config.USER.DEFAULT_NAME }; 
                HistoryManager.clearHistory();
                await FileSystemManager.load(Config.USER.DEFAULT_NAME); 
                SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME); 
                TerminalUI.updatePrompt();
                return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` };
            }
            function setCurrentUserObject(userObject) { currentUser = userObject; }
            function getDefaultUser() { return Config.USER.DEFAULT_NAME; }
            return { getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser };
        })();

        // --- SESSION MANAGER ---
        const SessionManager = (() => { 
            'use strict';
            function _getAutomaticSessionStateKey(user) { return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`; }
            function _getManualUserTerminalStateKey(user) { const userName = typeof user === 'object' && user !== null && user.name ? user.name : String(user); return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${userName}`; }
            
            function saveAutomaticState(username) {
                const currentInput = TerminalUI.getCurrentInputValue();
                const autoState = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, commandHistory: HistoryManager.getFullHistory() };
                StorageManager.saveItem(_getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`);
            }
            function loadAutomaticState(username) {
                const autoState = StorageManager.loadItem(_getAutomaticSessionStateKey(username), `Auto session for ${username}`);
                if (autoState) {
                    FileSystemManager.setCurrentPath(autoState.currentPath || Config.FILESYSTEM.ROOT_PATH);
                    if (autoState.hasOwnProperty('outputHTML')) DOM.outputDiv.innerHTML = autoState.outputHTML || '';
                    else DOM.outputDiv.innerHTML = ''; 
                    TerminalUI.setCurrentInputValue(autoState.currentInput || '');
                    HistoryManager.setHistory(autoState.commandHistory || []);
                } else { 
                    DOM.outputDiv.innerHTML = ''; TerminalUI.setCurrentInputValue('');
                    FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH); 
                    HistoryManager.clearHistory();
                    OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`);
                }
                TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                return !!autoState; 
            }
            async function saveManualState() {
                const currentUser = UserManager.getCurrentUser(); const currentInput = TerminalUI.getCurrentInputValue();
                const manualStateData = { user: currentUser.name, osVersion: Config.OS.VERSION, timestamp: new Date().toISOString(), currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()), commandHistory: HistoryManager.getFullHistory() };
                if (StorageManager.saveItem(_getManualUserTerminalStateKey(currentUser), manualStateData, `Manual save for ${currentUser.name}`)) return { success: true, message: `${Config.MESSAGES.SESSION_SAVED_FOR_PREFIX}${currentUser.name}.` };
                else return { success: false, error: "Failed to save session manually." };
            }
            async function loadManualState() {
                const currentUser = UserManager.getCurrentUser();
                const manualStateData = StorageManager.loadItem(_getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`);
                if (manualStateData) {
                    if (manualStateData.user && manualStateData.user !== currentUser.name) OutputManager.appendToOutput(`Warning: Saved state is for user '${manualStateData.user}', but current user is '${currentUser.name}'. Loading anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                    ConfirmationManager.request(
                        [`Load manually saved state for '${currentUser.name}'? This overwrites current session & filesystem.`],
                        { pendingData: manualStateData, userNameToRestoreTo: currentUser.name }, 
                        async (data) => {
                            FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                            FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                            DOM.outputDiv.innerHTML = data.pendingData.outputHTML || '';
                            TerminalUI.setCurrentInputValue(data.pendingData.currentInput || '');
                            HistoryManager.setHistory(data.pendingData.commandHistory || []);
                            await FileSystemManager.save(data.userNameToRestoreTo); 
                            OutputManager.appendToOutput(Config.MESSAGES.SESSION_LOADED_MSG, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                            TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        },
                        () => { OutputManager.appendToOutput(Config.MESSAGES.LOAD_STATE_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); }
                    );
                    return { success: true, message: "Confirmation requested for loading state." };
                } else return { success: false, message: `${Config.MESSAGES.NO_MANUAL_SAVE_FOUND_PREFIX}${currentUser.name}.` };
            }
            async function performFullReset() {
                OutputManager.clearOutput(); TerminalUI.clearInput();
                const keysToRemove = []; const allKeys = StorageManager.getAllLocalStorageKeys();
                allKeys.forEach(key => { if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) || key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) || key === Config.STORAGE_KEYS.USER_CREDENTIALS || key === Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED) keysToRemove.push(key); }); // Include word wrap key
                keysToRemove.forEach(key => StorageManager.removeItem(key));
                await OutputManager.appendToOutput("All session states, credentials, and editor settings cleared from local storage.");
                try { await FileSystemManager.clearAllFS(); await OutputManager.appendToOutput("All user filesystems cleared from DB."); } catch (error) {}
                HistoryManager.clearHistory();
                const guestUser = { name: Config.USER.DEFAULT_NAME }; UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.initialize(Config.USER.DEFAULT_NAME); await FileSystemManager.save(Config.USER.DEFAULT_NAME);       
                loadAutomaticState(Config.USER.DEFAULT_NAME); 
                await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                TerminalUI.updatePrompt();
            }
            return { saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset };
        })();

        // --- TERMINAL UI MANAGER ---
        const TerminalUI = (() => { 
            'use strict';
            let isNavigatingHistory = false; 
            function updatePrompt() {
                const user = (typeof UserManager !== 'undefined') ? UserManager.getCurrentUser() : { name: Config.USER.DEFAULT_NAME }; 
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.DEFAULT_HOST_NAME;
                const currentPathDisplay = (typeof FileSystemManager !== 'undefined') ? FileSystemManager.getCurrentPath() : Config.FILESYSTEM.ROOT_PATH; 
                DOM.promptPathSpan.textContent = (currentPathDisplay === Config.FILESYSTEM.ROOT_PATH && currentPathDisplay.length > 1) ? Config.FILESYSTEM.ROOT_PATH : currentPathDisplay;
            }
            function focusInput() { if (DOM.editableInputDiv) { DOM.editableInputDiv.focus(); if (DOM.editableInputDiv.textContent.length === 0) setCaretToEnd(DOM.editableInputDiv); }}
            function clearInput() { if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = ''; }
            function getCurrentInputValue() { return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : ''; }
            function setCurrentInputValue(value, setAtEnd = true) { 
                if (DOM.editableInputDiv) { 
                    DOM.editableInputDiv.textContent = value; 
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv); 
                }
            }
            function setCaretToEnd(element) { 
                if (!element) return; 
                const range = document.createRange();
                const sel = window.getSelection(); 
                range.selectNodeContents(element); 
                range.collapse(false); 
                sel.removeAllRanges(); 
                sel.addRange(range); 
                element.focus(); 
            }
            function setCaretPosition(element, position) {
                if (!element || typeof position !== 'number') return;
                const range = document.createRange();
                const sel = window.getSelection();
                let charCount = 0;
                let foundNode = false;

                function findTextNodeAndSet(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const nextCharCount = charCount + node.length;
                        if (!foundNode && position >= charCount && position <= nextCharCount) {
                            range.setStart(node, position - charCount);
                            range.collapse(true);
                            foundNode = true;
                        }
                        charCount = nextCharCount;
                    } else {
                        for (let i = 0; i < node.childNodes.length; i++) {
                            if (findTextNodeAndSet(node.childNodes[i])) {
                                return true; 
                            }
                            if (foundNode) break; 
                        }
                    }
                    return foundNode;
                }

                if (element.childNodes.length === 0 && position === 0) { 
                     range.setStart(element, 0);
                     range.collapse(true);
                     foundNode = true;
                } else {
                    findTextNodeAndSet(element);
                }
                

                if (foundNode) {
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else { 
                    range.selectNodeContents(element);
                    range.collapse(false); 
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                element.focus(); 
            }
            
            function setInputState(isEditable) {
                if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.contentEditable = isEditable ? 'true' : 'false';
                    DOM.editableInputDiv.style.opacity = isEditable ? '1' : '0.5';
                    if (isEditable) {
                        focusInput(); 
                    } else {
                        DOM.editableInputDiv.blur(); 
                    }
                }
            }

            function isPasswordInputActiveState() { return false; } function getPasswordContext() { return null; } function switchToPasswordInput(promptContext) { /* TODO */ } function switchToEditableInput() { /* TODO */ }
            function setIsNavigatingHistory(status) { isNavigatingHistory = status; } function getIsNavigatingHistory() { return isNavigatingHistory; }
            
            return { 
                updatePrompt, focusInput, clearInput, setCurrentInputValue, getCurrentInputValue, 
                isPasswordInputActiveState, getPasswordContext, switchToPasswordInput, switchToEditableInput, 
                setCaretToEnd, setIsNavigatingHistory, getIsNavigatingHistory,
                setCaretPosition,
                setInputState 
            };
        })();

        // --- TAB COMPLETION MANAGER ---
        const TabCompletionManager = (() => {
            'use strict';
            const PATH_COMMANDS = ['ls', 'cd', 'cat', 'edit', 'run', 'mv', 'cp', 'rm', 'mkdir', 'touch', 'export', 'find'];
            function findLongestCommonPrefix(strs) {
                if (!strs || strs.length === 0) return "";
                if (strs.length === 1) return strs[0];
                let prefix = strs[0];
                for (let i = 1; i < strs.length; i++) {
                    while (strs[i].indexOf(prefix) !== 0) {
                        prefix = prefix.substring(0, prefix.length - 1);
                        if (prefix === "") return "";
                    }
                }
                return prefix;
            }
            function getSuggestions(fullInput, cursorPos) {
                const textBeforeCursor = fullInput.substring(0, cursorPos);
                const tokens = textBeforeCursor.trimStart().split(/\s+/); 
                let currentWordPrefix = ""; 
                let isCompletingCommandName = false;
                let baseCommandForPath = "";
                const lastCharIsSpace = /\s$/.test(textBeforeCursor) || textBeforeCursor.length === 0;

                if (tokens.length === 0 || (tokens.length === 1 && !lastCharIsSpace && tokens[0] !== "")) {
                    isCompletingCommandName = true;
                    currentWordPrefix = tokens.length > 0 ? tokens[0] : "";
                } else {
                    baseCommandForPath = tokens[0].toLowerCase();
                    if (lastCharIsSpace) { 
                        currentWordPrefix = "";
                    } else { 
                        currentWordPrefix = tokens[tokens.length - 1];
                    }
                }
                
                let suggestions = [];
                if (isCompletingCommandName) {
                    const allCommands = CommandExecutor.getCommands(); 
                    if (allCommands) {
                         suggestions = Object.keys(allCommands)
                            .filter(cmdName => cmdName.startsWith(currentWordPrefix))
                            .sort();
                    }
                } else if (PATH_COMMANDS.includes(baseCommandForPath)) {
                    let effectiveBasePath = FileSystemManager.getCurrentPath();
                    let segmentToMatch = currentWordPrefix;
                    const lastSlashIndex = currentWordPrefix.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                    let pathPrefixTyped = ""; 

                    if (lastSlashIndex !== -1) {
                        pathPrefixTyped = currentWordPrefix.substring(0, lastSlashIndex + 1);
                        segmentToMatch = currentWordPrefix.substring(lastSlashIndex + 1);
                        effectiveBasePath = FileSystemManager.getAbsolutePath(pathPrefixTyped, FileSystemManager.getCurrentPath());
                    }
                    const baseNode = FileSystemManager.getNodeByPath(effectiveBasePath);
                    if (baseNode && baseNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        suggestions = Object.keys(baseNode.children)
                            .filter(name => name.startsWith(segmentToMatch))
                            .map(name => {
                                const childNode = baseNode.children[name];
                                let fullSuggestion = pathPrefixTyped + name; 
                                if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    return fullSuggestion + Config.FILESYSTEM.PATH_SEPARATOR;
                                }
                                return fullSuggestion;
                            })
                            .sort();
                    }
                }

                if (suggestions.length === 0) {
                    return { textToInsert: null, newCursorPos: cursorPos };
                }

                if (suggestions.length === 1) {
                    const completedSegment = suggestions[0];
                    let startOfWordIndex = textBeforeCursor.length - currentWordPrefix.length;
                    if (startOfWordIndex < 0) startOfWordIndex = 0; 
                    const newFullInput = textBeforeCursor.substring(0, startOfWordIndex) + completedSegment + fullInput.substring(cursorPos);
                    const newCursor = startOfWordIndex + completedSegment.length;
                    return { textToInsert: newFullInput, newCursorPos: newCursor };
                } else { 
                    const lcp = findLongestCommonPrefix(suggestions);
                    if (lcp.length > currentWordPrefix.length) {
                        let startOfWordIndex = textBeforeCursor.length - currentWordPrefix.length;
                         if (startOfWordIndex < 0) startOfWordIndex = 0;
                        const newFullInput = textBeforeCursor.substring(0, startOfWordIndex) + lcp + fullInput.substring(cursorPos);
                        const newCursor = startOfWordIndex + lcp.length;
                        return { textToInsert: newFullInput, newCursorPos: newCursor };
                    } else {
                        const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                        OutputManager.appendToOutput(suggestions.join('    '), { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG, isCompletionSuggestion: true });
                        OutputManager.appendToOutput(`${promptText}${fullInput}`, {isCompletionSuggestion: true}); 
                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        return { textToInsert: null, newCursorPos: cursorPos }; 
                    }
                }
            }
            return { getSuggestions };
        })();

        // --- COMMAND EXECUTOR ---
        const CommandExecutor = (() => { 
            'use strict';
            let lastCommandFailed = false; 
            let scriptExecutionInProgress = false; 
            
            const TokenType = { WORD: 'WORD', STRING_DQ: 'STRING_DQ', STRING_SQ: 'STRING_SQ', OPERATOR_GT: 'OPERATOR_GT', OPERATOR_GTGT: 'OPERATOR_GTGT', EOF: 'EOF' };
            class Token { constructor(type, value, position) { this.type = type; this.value = value; this.position = position; } }
            class Lexer {
                constructor(input) { this.input = input; this.position = 0; this.tokens = []; }
                tokenize() {
                    while (this.position < this.input.length) {
                        const char = this.input[this.position];
                        if (/\s/.test(char)) { this.position++; continue; }
                        if (char === '"') { this.tokens.push(this._tokenizeString('"')); continue; }
                        if (char === "'") { this.tokens.push(this._tokenizeString("'")); continue; }
                        if (char === '>') {
                            if (this.input[this.position + 1] === '>') { this.tokens.push(new Token(TokenType.OPERATOR_GTGT, '>>', this.position)); this.position += 2; }
                            else { this.tokens.push(new Token(TokenType.OPERATOR_GT, '>', this.position)); this.position++; }
                            continue;
                        }
                        let value = ''; const startPos = this.position;
                        while (this.position < this.input.length && !/\s/.test(this.input[this.position]) && this.input[this.position] !== '"' && this.input[this.position] !== "'" && this.input[this.position] !== '>') { value += this.input[this.position]; this.position++; }
                        if (value) this.tokens.push(new Token(TokenType.WORD, value, startPos));
                        else if (this.position < this.input.length) throw new Error(`Lexer Error: Unexpected character '${this.input[this.position]}' at position ${this.position}.`);
                    }
                    this.tokens.push(new Token(TokenType.EOF, null, this.position)); return this.tokens;
                }
                _tokenizeString(quoteChar) {
                    const startPos = this.position; let value = ''; this.position++; 
                    while (this.position < this.input.length && this.input[this.position] !== quoteChar) { value += this.input[this.position]; this.position++; }
                    if (this.position >= this.input.length || this.input[this.position] !== quoteChar) throw new Error(`Lexer Error: Unclosed string literal starting at position ${startPos}. Expected closing ${quoteChar}.`);
                    this.position++; return new Token(quoteChar === '"' ? TokenType.STRING_DQ : TokenType.STRING_SQ, value, startPos);
                }
            }
            class Parser {
                constructor(tokens) { this.tokens = tokens; this.position = 0; }
                _currentToken() { return this.tokens[this.position]; }
                _nextToken() { if (this.position < this.tokens.length -1) this.position++; return this._currentToken(); }
                _expectAndConsume(tokenType) { const c = this._currentToken(); if (c.type === tokenType) { this._nextToken(); return c; } throw new Error(`Parser Error: Expected token ${tokenType} but got ${c.type} ('${c.value}') at input position ${c.position}.`); }
                _parseRedirection() { const o = this._currentToken(); this._nextToken(); const f = this._currentToken(); if (f.type === TokenType.WORD || f.type === TokenType.STRING_DQ || f.type === TokenType.STRING_SQ) { this._nextToken(); return { type: o.type === TokenType.OPERATOR_GTGT ? 'append' : 'overwrite', file: f.value, operatorPosition: o.position }; } else throw new Error(`Parser Error: Expected filename (WORD or STRING) after redirection operator '${o.value}' at input position ${o.position}, but got ${f.type} ('${f.value}') at input position ${f.position}.`);}
                parse() {
                    let baseCommand = null; const args = []; const redirections = []; 
                    if (this._currentToken().type === TokenType.EOF) return { baseCommand: '', args: [], redirection: null }; 
                    const cmdToken = this._expectAndConsume(TokenType.WORD); baseCommand = cmdToken.value;
                    while (this._currentToken().type !== TokenType.EOF) {
                        const current = this._currentToken();
                        if (current.type === TokenType.WORD || current.type === TokenType.STRING_DQ || current.type === TokenType.STRING_SQ) { args.push(current.value); this._nextToken(); }
                        else if (current.type === TokenType.OPERATOR_GT || current.type === TokenType.OPERATOR_GTGT) { const r = this._parseRedirection(); if (r) redirections.push(r); }
                        else throw new Error(`Parser Error: Unexpected token ${current.type} ('${current.value}') at input position ${current.position}. Expected WORD, STRING, or redirection OPERATOR.`);
                    }
                    let finalRedirection = null;
                    if (redirections.length > 0) { if (redirections.length > 1) OutputManager.appendToOutput(`Warning: Multiple output redirection operators found. Using the last one specified: '${redirections[redirections.length - 1].file}'.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG }); finalRedirection = redirections[redirections.length - 1]; }
                    return { baseCommand, args, redirection: finalRedirection };
                }
            }

            function _prepareMoveCopyPaths(commandName, sourcePathArg, destPathArg, options = {}) {
                const { disallowSourceRoot } = options;
                const result = {
                    sourceNode: null, absSourcePath: null, sourceName: null, sourceParentNode: null,
                    destValidationNode: null, absDestPath: null, 
                    finalDestParentNode: null, finalDestName: null, absFinalDestPath: null,
                    error: null
                };

                const sourceValidation = FileSystemManager.validatePath(commandName, sourcePathArg, { 
                    disallowRoot: disallowSourceRoot, 
                    defaultToCurrentIfEmpty: false 
                });
                if (sourceValidation.error) {
                    result.error = sourceValidation.error;
                    return result;
                }
                result.sourceNode = sourceValidation.node;
                result.absSourcePath = sourceValidation.resolvedPath;
                result.sourceName = result.absSourcePath === Config.FILESYSTEM.ROOT_PATH ? 
                                   (commandName === 'cp' ? 'root_copy' : 'root') : 
                                   result.absSourcePath.substring(result.absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                
                const sourceParentPath = result.absSourcePath.substring(0, result.absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                result.sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath);
                if (!result.sourceParentNode && result.absSourcePath !== Config.FILESYSTEM.ROOT_PATH) {
                     result.error = `${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX}${result.sourceName}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE}${sourceParentPath}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX}`;
                     return result;
                }

                const destValidation = FileSystemManager.validatePath(commandName, destPathArg, { 
                    allowMissing: true, 
                    defaultToCurrentIfEmpty: false 
                });
                result.destValidationNode = destValidation.node;
                result.absDestPath = destValidation.resolvedPath;

                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    result.finalDestParentNode = destValidation.node;
                    result.finalDestName = result.sourceName; 
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(result.absDestPath);
                    if (parentDirResult.error) {
                        result.error = `${commandName}: ${parentDirResult.error}`;
                        return result;
                    }
                    result.finalDestParentNode = parentDirResult.parentNode;
                    if (!result.finalDestParentNode) {
                         result.error = `${commandName}: could not obtain parent directory for '${result.absDestPath}' (internal error)`;
                         return result;
                    }
                    result.finalDestName = result.absDestPath.substring(result.absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }
                
                let finalDestParentNodePath;
                if (result.finalDestParentNode === FileSystemManager.getFsData()[Config.FILESYSTEM.ROOT_PATH]) {
                    finalDestParentNodePath = Config.FILESYSTEM.ROOT_PATH;
                } else if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNodePath = result.absDestPath;
                } else {
                    finalDestParentNodePath = result.absDestPath.substring(0, result.absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                }
                result.absFinalDestPath = FileSystemManager.getAbsolutePath(result.finalDestName, finalDestParentNodePath);


                if (!result.finalDestName || result.finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || result.finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    result.error = `${commandName}: invalid destination name '${result.finalDestName}'`;
                    return result;
                }

                return result;
            }


            async function handleLs(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { max: 1 });
                if (!argValidation.isValid) return _createUsageError('ls', argValidation.errorDetail);

                const targetPathArg = args[0]; 
                const validation = FileSystemManager.validatePath('ls', targetPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, defaultToCurrentIfEmpty: true }); 
                if (validation.error) return { success: false, error: validation.error }; 
                const childrenNames = Object.keys(validation.node.children).sort(); 
                if (childrenNames.length === 0) return { success: true, output: Config.MESSAGES.DIRECTORY_EMPTY }; 
                let outputLines = []; 
                childrenNames.forEach(name => { 
                    const childNode = validation.node.children[name]; 
                    let line = name; 
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) line += Config.FILESYSTEM.PATH_SEPARATOR; 
                    outputLines.push(line); 
                }); 
                return { success: true, output: outputLines.join('\n') }; 
            }
            async function handleCd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('cd', argValidation.errorDetail + ". You must specify a directory.");

                const targetPathArg = args[0]; 
                const validation = FileSystemManager.validatePath('cd', targetPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, defaultToCurrentIfEmpty: false }); 
                if (validation.error) return { success: false, error: validation.error }; 
                if (validation.resolvedPath === FileSystemManager.getCurrentPath()) return { success: true, output: `${Config.MESSAGES.ALREADY_IN_DIRECTORY_PREFIX}${validation.resolvedPath}${Config.MESSAGES.ALREADY_IN_DIRECTORY_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; 
                FileSystemManager.setCurrentPath(validation.resolvedPath); 
                return { success: true, output: null }; 
            }
            async function handleMkdir(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('mkdir', argValidation.errorDetail + ". You must specify a directory name.");
                
                const fullPathArg = args[0]; 
                if (fullPathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || fullPathArg === Config.FILESYSTEM.PARENT_DIR_SYMBOL) return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` }; 
                const validation = FileSystemManager.validatePath('mkdir', fullPathArg, { allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); 
                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` }; 
                if (validation.error && !validation.optionsUsed?.allowMissing) return { success: false, error: validation.error }; 
                const targetAbsPath = validation.resolvedPath; 
                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; 
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); 
                if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` }; 
                const parentNode = parentDirResult.parentNode; 
                if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}' (internal error)` }; 
                const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1); 
                if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` }; 
                parentNode.children[dirToCreateName] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} }; 
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) { delete parentNode.children[dirToCreateName]; return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` }; } 
                return { success: true, output: `Directory '${fullPathArg}${Config.MESSAGES.DIRECTORY_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
            }
            async function handleTouch(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('touch', argValidation.errorDetail + ". You must specify a filename.");

                const fullPathArg = args[0]; 
                if (fullPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` }; 
                const validation = FileSystemManager.validatePath('touch', fullPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); 
                if (validation.error) return { success: false, error: validation.error }; 
                const targetAbsPath = validation.resolvedPath; 
                if (validation.node) return { success: true, output: `${Config.MESSAGES.TIMESTAMP_UPDATED_PREFIX}${fullPathArg}${Config.MESSAGES.TIMESTAMP_UPDATED_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; 
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); 
                if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` }; 
                const parentNode = parentDirResult.parentNode; 
                if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}' (internal error)`}; 
                const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1); 
                parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: "" }; 
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) { delete parentNode.children[newFileName]; return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` }; } 
                return { success: true, output: `File '${fullPathArg}${Config.MESSAGES.FILE_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
            }
            async function handleCat(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('cat', argValidation.errorDetail + ". You must specify a filename.");
                
                const targetPathArg = args[0]; 
                const validation = FileSystemManager.validatePath('cat', targetPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false }); 
                if (validation.error) return { success: false, error: validation.error }; 
                return { success: true, output: validation.node.content }; 
            }
            async function handleEcho(args, cmdOptions) { 
                return { success: true, output: args.join(' ') }; 
            }

            async function handleMv(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 2 });
                if (!argValidation.isValid) return _createUsageError('mv', argValidation.errorDetail + ". Specify source and destination.");

                const sourcePathArg = args[0];
                const destPathArg = args[1];

                const prep = _prepareMoveCopyPaths('mv', sourcePathArg, destPathArg, { disallowSourceRoot: true });
                if (prep.error) return { success: false, error: prep.error };

                const { sourceNode, absSourcePath, sourceName, sourceParentNode, finalDestParentNode, finalDestName, absFinalDestPath, destValidationNode } = prep;

                if (destValidationNode && destValidationNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (absSourcePath === absFinalDestPath) {
                    return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                if (finalDestParentNode.children[finalDestName]) {
                     const destDisplayPath = (destValidationNode && destValidationNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) ? destPathArg : (absFinalDestPath.substring(0, absFinalDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH);
                    return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destDisplayPath}'.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && (absFinalDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absFinalDestPath === absSourcePath)) {
                    return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one of its subdirectories ('${destPathArg}')` };
                }
                
                finalDestParentNode.children[finalDestName] = sourceNode; 
                if (sourceParentNode && sourceParentNode.children && sourceParentNode.children[sourceName]) {
                     delete sourceParentNode.children[sourceName]; 
                } else if (absSourcePath !== Config.FILESYSTEM.ROOT_PATH) { 
                    return { success: false, error: `${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX}${sourceName}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE}its parent${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX}` };
                }

                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) { 
                    if (sourceParentNode && sourceParentNode.children) sourceParentNode.children[sourceName] = sourceNode; 
                    delete finalDestParentNode.children[finalDestName]; 
                    return { success: false, error: "mv: failed to save filesystem changes." }; 
                } 
                return { success: true, output: `${Config.MESSAGES.MOVED_PREFIX}${sourcePathArg}${Config.MESSAGES.MOVED_TO}${destPathArg}${Config.MESSAGES.MOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
            }

            async function handleCp(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 2 });
                if (!argValidation.isValid) return _createUsageError('cp', argValidation.errorDetail + ". Specify source and destination.");
                
                const sourcePathArg = args[0];
                const destPathArg = args[1];

                const prep = _prepareMoveCopyPaths('cp', sourcePathArg, destPathArg, { disallowSourceRoot: false }); 
                if (prep.error) return { success: false, error: prep.error };
                
                const { sourceNode, absSourcePath, finalDestParentNode, finalDestName, absFinalDestPath, destValidationNode } = prep;

                if (destValidationNode && destValidationNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                     return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (finalDestParentNode.children[finalDestName]) {
                    return { success: false, error: `cp: destination '${finalDestName}' already exists.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && (absFinalDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absFinalDestPath === absSourcePath)) {
                    return { success: false, error: `cp: cannot copy a directory into itself or one of its own subdirectories.` };
                }

                const copiedNode = Utils.deepCopyNode(sourceNode); 
                if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` }; 
                
                finalDestParentNode.children[finalDestName] = copiedNode; 
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) { 
                    delete finalDestParentNode.children[finalDestName]; 
                    return { success: false, error: "cp: failed to save filesystem changes." }; 
                } 
                return { success: true, output: `${Config.MESSAGES.COPIED_PREFIX}${sourcePathArg}${Config.MESSAGES.COPIED_TO}${destPathArg}${Config.MESSAGES.COPIED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
            }
            
            async function handleRm(args, cmdOptions) {
                const { isInteractive, explicitForce: initialExplicitForce } = cmdOptions; 
                const CWDbeforeDeletion = FileSystemManager.getCurrentPath();
            
                const flagDefinitions = [{ name: 'force', short: '-f', long: '--force' }];
                const parsedFlagsResult = Utils.parseFlags(args, flagDefinitions);
                const explicitForceActual = initialExplicitForce || parsedFlagsResult.flags.force;
                const remainingArgs = parsedFlagsResult.remainingArgs;
                
                const argValidation = Utils.validateArguments(remainingArgs, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('rm', argValidation.errorDetail + ". Specify item to remove.");
                
                const pathArgForValidation = remainingArgs[0];
            
                const validation = FileSystemManager.validatePath('rm', pathArgForValidation, { disallowRoot: true, defaultToCurrentIfEmpty: false });
            
                if (validation.error) {
                    if (explicitForceActual && validation.error.includes("No such file or directory")) {
                        return { success: true, output: null };
                    }
                    return { success: false, error: validation.error };
                }
            
                const pathBeingDeleted = validation.resolvedPath;
                const originalNodeType = validation.node.type;
                const itemTypeDisplay = originalNodeType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? 'directory' : 'file';
            
                if (!explicitForceActual && !isInteractive) {
                    let errorMessage = `rm: cannot remove ${itemTypeDisplay} '${pathArgForValidation}'. Use -f in scripts.`;
                    if (originalNodeType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        errorMessage = `rm: cannot remove directory '${pathArgForValidation}'. Use -f in scripts for recursive removal.`;
                    }
                    return { success: false, error: errorMessage };
                }
            
                const dataForConfirm = { 
                    path: pathBeingDeleted, 
                    arg: pathArgForValidation, 
                    userName: UserManager.getCurrentUser().name, 
                    cwdBeforeDelete: CWDbeforeDeletion, 
                    nodeType: originalNodeType 
                };
            
                const adjustCwdIfNeededAndUpdatePrompt = (deletedPathAbs, currentCwdAbs, nodeTypeDeleted) => {
                    let cwdUpdateMessage = "";
                    let cwdChanged = false;
                    let newCwdForPrompt = currentCwdAbs;
                    if (nodeTypeDeleted === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        if (currentCwdAbs === deletedPathAbs) {
                            let parentOfDeleted = deletedPathAbs.substring(0, deletedPathAbs.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR));
                            if (parentOfDeleted === "" && deletedPathAbs !== Config.FILESYSTEM.ROOT_PATH) parentOfDeleted = Config.FILESYSTEM.ROOT_PATH;
                            else if (parentOfDeleted === "" && deletedPathAbs === Config.FILESYSTEM.ROOT_PATH) parentOfDeleted = Config.FILESYSTEM.ROOT_PATH; 
                            newCwdForPrompt = parentOfDeleted || Config.FILESYSTEM.ROOT_PATH; 
                            FileSystemManager.setCurrentPath(newCwdForPrompt);
                            cwdUpdateMessage = `\nCurrent directory was '${deletedPathAbs}'. Moved to '${newCwdForPrompt}'.`;
                            cwdChanged = true;
                        } else if (currentCwdAbs.startsWith(deletedPathAbs + Config.FILESYSTEM.PATH_SEPARATOR)) {
                            let newCwdTargetCalc = deletedPathAbs.substring(0, deletedPathAbs.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR));
                            if (newCwdTargetCalc === "" && deletedPathAbs !== Config.FILESYSTEM.ROOT_PATH) newCwdTargetCalc = Config.FILESYSTEM.ROOT_PATH;
                            else if (newCwdTargetCalc === "" && deletedPathAbs === Config.FILESYSTEM.ROOT_PATH) newCwdTargetCalc = Config.FILESYSTEM.ROOT_PATH;
                            if (!FileSystemManager.getNodeByPath(newCwdTargetCalc)) newCwdTargetCalc = Config.FILESYSTEM.ROOT_PATH;
                            newCwdForPrompt = newCwdTargetCalc || Config.FILESYSTEM.ROOT_PATH; 
                            FileSystemManager.setCurrentPath(newCwdForPrompt);
                            cwdUpdateMessage = `\nCurrent directory was '${currentCwdAbs}'. Moved to '${newCwdForPrompt}' as ancestor '${deletedPathAbs}' was removed.`;
                            cwdChanged = true;
                        }
                    }
                    if (cwdChanged) TerminalUI.updatePrompt();
                    return cwdUpdateMessage;
                };
            
                if (explicitForceActual) { 
                    const parentPath = pathBeingDeleted.substring(0, pathBeingDeleted.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                    const itemName = pathBeingDeleted.substring(pathBeingDeleted.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const parentNode = FileSystemManager.getNodeByPath(parentPath);
            
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        const removedNodeForRevert = Utils.deepCopyNode(parentNode.children[itemName]); 
                        delete parentNode.children[itemName];
                        if (!await FileSystemManager.save(dataForConfirm.userName)) {
                            parentNode.children[itemName] = removedNodeForRevert; 
                            return { success: false, error: `Error saving filesystem after force removing '${pathBeingDeleted}'.` };
                        } else {
                            let outputMessage = `${Config.MESSAGES.FORCIBLY_REMOVED_PREFIX}${pathArgForValidation}${Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX}`;
                            outputMessage += adjustCwdIfNeededAndUpdatePrompt(pathBeingDeleted, CWDbeforeDeletion, originalNodeType);
                            return { success: true, output: outputMessage, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                    } else {
                        return { success: false, error: `Error force removing '${pathArgForValidation}': Item not found in parent directory during deletion phase.` };
                    }
                } else { 
                    ConfirmationManager.request(
                        [`Are you sure you want to remove ${itemTypeDisplay} '${pathArgForValidation}'? This action cannot be undone.`],
                        dataForConfirm,
                        async (data) => {
                            const parentPath = data.path.substring(0, data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                            const itemName = data.path.substring(data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            const parentNode = FileSystemManager.getNodeByPath(parentPath);
                            if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                const removedNodeForRevert = Utils.deepCopyNode(parentNode.children[itemName]);
                                delete parentNode.children[itemName];
                                if (!await FileSystemManager.save(data.userName)) {
                                    parentNode.children[itemName] = removedNodeForRevert;
                                    await OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'. Removal not persisted.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                } else {
                                    let removalMessage = `'${data.arg}${Config.MESSAGES.ITEM_REMOVED_SUFFIX}`;
                                    removalMessage += adjustCwdIfNeededAndUpdatePrompt(data.path, data.cwdBeforeDelete, data.nodeType);
                                    await OutputManager.appendToOutput(removalMessage, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                }
                            } else {
                                await OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            }
                        },
                        (data) => { 
                            OutputManager.appendToOutput(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${data.arg || 'item'}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, output: null }; 
                }
            }

            async function handlePwd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('pwd', argValidation.errorDetail);
                return { success: true, output: FileSystemManager.getCurrentPath() }; 
            }
            async function handleDate(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('date', argValidation.errorDetail);
                return { success: true, output: new Date().toString() }; 
            }
            
            async function handleRun(args, cmdOptions) {
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('run', argValidation.errorDetail + ". Specify a script file.");
            
                const scriptPathArg = args[0];
                const validation = FileSystemManager.validatePath('run', scriptPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false });
                if (validation.error) return { success: false, error: validation.error };
            
                const scriptContent = validation.node.content || "";
                const scriptLines = scriptContent.split('\n');
                await OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
            
                scriptExecutionInProgress = true;
                TerminalUI.setInputState(false); 
            
                try {
                    for (let i = 0; i < scriptLines.length; i++) {
                        let lineToExecute = scriptLines[i];
                        const commentIndex = lineToExecute.indexOf('#');
                        if (commentIndex !== -1) lineToExecute = lineToExecute.substring(0, commentIndex);
                        const trimmedLine = lineToExecute.trim();
                        if (trimmedLine === '') continue;
            
                        const cmdResult = await processSingleCommand(trimmedLine, false); 
                        if (!cmdResult.success) {
                            await OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            if (cmdResult.error) await OutputManager.appendToOutput(cmdResult.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            return { success: false, error: `Script aborted at line ${i+1}`}; 
                        }
                    }
                    await OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                } finally {
                    scriptExecutionInProgress = false;
                    TerminalUI.setInputState(true); 
                    TerminalUI.updatePrompt(); 
                }
                return { success: true, output: null };
            }

            async function handleClear(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('clear', argValidation.errorDetail);
                OutputManager.clearOutput(); return { success: true, output: null }; 
            }
            async function handleRegisterCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('register', argValidation.errorDetail + ". Specify a username.");
                const username = args[0]; 
                const result = await UserManager.register(username); 
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
                else return { success: false, error: result.error }; 
            }
            async function handleLoginCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('login', argValidation.errorDetail + ". Specify a username.");
                const username = args[0]; 
                const result = await UserManager.login(username); 
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG }; 
                else return { success: false, error: result.error }; 
            }
            async function handleLogoutCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('logout', argValidation.errorDetail);
                const result = await UserManager.logout(); 
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG }; 
                else return { success: false, error: result.error || "Logout failed." }; 
            }
            async function handleSavestate(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('savestate', argValidation.errorDetail);
                const result = await SessionManager.saveManualState(); 
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
                else return { success: false, error: result.error || "Failed to save state." }; 
            }
            async function handleLoadstate(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('loadstate', argValidation.errorDetail);
                const result = await SessionManager.loadManualState(); 
                return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG }; 
            }
            async function handleReset(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('reset', argValidation.errorDetail);
                ConfirmationManager.request( ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."], null, async () => { await SessionManager.performFullReset(); }, () => { OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); } ); 
                return { success: true, output: null }; 
            }
            async function handleHelp(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { max: 1 });
                if (!argValidation.isValid) return _createUsageError('help', argValidation.errorDetail);

                const outputLines = []; 
                if (args.length === 0) { 
                    outputLines.push("Available commands (type 'help <command_name>' for more details):"); 
                    const commandNames = Object.keys(commands).sort(); 
                    const commandList = commandNames.map(cmdName => { const summary = commands[cmdName]?.summary || 'No summary available.'; return `- ${cmdName.padEnd(14, ' ')} ${summary}`; }); 
                    outputLines.push(...commandList); 
                } else { 
                    const commandName = args[0].toLowerCase(); 
                    const cmdInfo = commands[commandName]; 
                    if (cmdInfo) { 
                        outputLines.push(`COMMAND:`); 
                        outputLines.push(`    ${commandName} - ${cmdInfo.summary || 'No summary available.'}`); 
                        outputLines.push(``); 
                        if (cmdInfo.usage) { outputLines.push(`USAGE:`); outputLines.push(`    ${cmdInfo.usage}`); outputLines.push(``); } 
                        if (cmdInfo.syntax && cmdInfo.syntax !== cmdInfo.usage) { outputLines.push(`SYNTAX:`); outputLines.push(`    ${cmdInfo.syntax}`); outputLines.push(``); } 
                        if (cmdInfo.details) { outputLines.push(`DETAILS:`); const detailLines = cmdInfo.details.split('\n'); detailLines.forEach(line => outputLines.push(`    ${line}`)); outputLines.push(``); } 
                        if (cmdInfo.examples && cmdInfo.examples.length > 0) { outputLines.push(`EXAMPLES:`); cmdInfo.examples.forEach(example => { outputLines.push(`    ${example}`); }); outputLines.push(``); } 
                    } else return { success: false, error: `help: No help available for command '${commandName}'.` }; 
                } 
                return { success: true, output: outputLines.join('\n'), isHtmlOutput: false }; 
            }
            async function handleEditCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('edit', argValidation.errorDetail + ". Specify a filename.");

                if (EditorManager.isActive()) return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MSG }; 
                const targetPathArg = args[0]; 
                if (targetPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` }; 
                const validation = FileSystemManager.validatePath('edit', targetPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); 
                if (validation.error) return { success: false, error: validation.error }; 
                const content = validation.node ? validation.node.content : ""; 
                EditorManager.enter(validation.resolvedPath, content); 
                return { success: true, output: null }; 
            }
            async function handleTree(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { max: 1 });
                if (!argValidation.isValid) return _createUsageError('tree', argValidation.errorDetail);

                const targetPathArg = args[0]; 
                const validation = FileSystemManager.validatePath('tree', targetPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, defaultToCurrentIfEmpty: true }); 
                if (validation.error) return { success: false, error: validation.error }; 
                const outputLines = []; 
                const startingDirName = validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH ? Config.FILESYSTEM.ROOT_PATH : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || validation.resolvedPath; 
                outputLines.push(startingDirName); 
                function generateTreeLinesRecursive(directoryNode, prefix) { 
                    const childrenNames = Object.keys(directoryNode.children).sort(); 
                    childrenNames.forEach((name, index) => { 
                        const childNode = directoryNode.children[name]; 
                        const isLast = index === childrenNames.length - 1; 
                        const connector = isLast ? "└── " : "├── "; 
                        let line = prefix + connector + name; 
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) line += Config.FILESYSTEM.PATH_SEPARATOR; 
                        outputLines.push(line); 
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) { 
                            const newPrefix = prefix + (isLast ? "    " : "│   "); 
                            generateTreeLinesRecursive(childNode, newPrefix); 
                        } 
                    }); 
                } 
                generateTreeLinesRecursive(validation.node, ""); 
                return { success: true, output: outputLines.join('\n') }; 
            }
            async function handleExport(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('export', argValidation.errorDetail + ". Specify a filename to export.");
                
                const filePathArg = args[0]; 
                const validation = FileSystemManager.validatePath('export', filePathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false }); 
                if (validation.error) return { success: false, error: validation.error }; 
                const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || 'downloaded_file.txt'; 
                const fileContent = validation.node.content || ""; 
                const mimeType = "text/plain"; 
                try { 
                    const blob = new Blob([fileContent], { type: mimeType }); 
                    const url = URL.createObjectURL(blob); 
                    const a = Utils.createElement('a', { href: url, download: fileName }); 
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); 
                    return { success: true, output: `${Config.MESSAGES.EXPORTING_PREFIX}${fileName}${Config.MESSAGES.EXPORTING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
                } catch (error) { 
                    console.error("Export failed:", error); 
                    return { success: false, error: `Error exporting file '${fileName}': ${error.message}` }; 
                } 
            }
            async function handleBackup(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('backup', argValidation.errorDetail);

                const currentUser = UserManager.getCurrentUser(); 
                const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14); 
                const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`; 
                const backupData = { backupVersion: "1.0", osVersion: Config.OS.VERSION, user: currentUser.name, timestamp: new Date().toISOString(), filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()), currentPath: FileSystemManager.getCurrentPath(), commandHistory: HistoryManager.getFullHistory() }; 
                try { 
                    const jsonString = JSON.stringify(backupData, null, 2); 
                    const blob = new Blob([jsonString], { type: "application/json" }); 
                    const url = URL.createObjectURL(blob); 
                    const a = Utils.createElement('a', { href: url, download: backupFileName }); 
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); 
                    return { success: true, output: `${Config.MESSAGES.BACKUP_CREATING_PREFIX}${backupFileName}${Config.MESSAGES.BACKUP_CREATING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
                } catch (error) { 
                    console.error("Backup failed:", error); 
                    return { success: false, error: `Error creating backup: ${error.message}` }; 
                } 
            }
            
            async function handleRestore(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('restore', argValidation.errorDetail);
                
                const fileInput = Utils.createElement('input', { type: 'file', accept: '.json'});
                return new Promise((resolveCommand) => { 
                    fileInput.onchange = async (event) => { 
                        const file = event.target.files[0]; 
                        if (!file) { 
                            await OutputManager.appendToOutput(Config.MESSAGES.RESTORE_CANCELLED_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); 
                            resolveCommand({ success: true, output: null }); 
                            return; 
                        } 
                        const reader = new FileReader(); 
                        reader.onload = async (e) => { 
                            try { 
                                const fileContent = e.target.result; 
                                const parsedData = JSON.parse(fileContent); 
                                if (typeof parsedData !== 'object' || parsedData === null || !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') || !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') || !parsedData.hasOwnProperty('backupVersion')) { 
                                    await OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                    resolveCommand({ success: false, error: "Invalid backup file." }); 
                                    return; 
                                } 
                                if (parsedData.backupVersion !== "1.0") {
                                    await OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting restore anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG }); 
                                }
                                const dataForConfirm = { parsedData: parsedData, fileName: file.name }; 
                                ConfirmationManager.request( 
                                    [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`], 
                                    dataForConfirm, 
                                    async (data) => { 
                                        const importedUser = data.parsedData.user; 
                                        const currentActiveUser = UserManager.getCurrentUser(); 
                                        if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser) {
                                            SessionManager.saveAutomaticState(currentActiveUser.name);
                                        } 
                                        const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {}); 
                                        if (!users[importedUser]) {
                                            OutputManager.appendToOutput(`User '${importedUser}' from backup does not exist locally. Their session will be loaded. Consider registering them if login is desired later.`, {typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG});
                                        }
                                        UserManager.setCurrentUserObject({ name: importedUser }); 
                                        FileSystemManager.setFsData(Utils.deepCopyNode(data.parsedData.filesystem) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } }); 
                                        FileSystemManager.setCurrentPath(data.parsedData.currentPath || Config.FILESYSTEM.ROOT_PATH); 
                                        HistoryManager.setHistory(data.parsedData.commandHistory || []); 
                                        OutputManager.clearOutput(); 
                                        TerminalUI.clearInput(); 
                                        await FileSystemManager.save(importedUser); 
                                        await OutputManager.appendToOutput(`${Config.MESSAGES.RESTORE_SUCCESS_PREFIX}${importedUser}${Config.MESSAGES.RESTORE_SUCCESS_MIDDLE}${data.fileName}${Config.MESSAGES.RESTORE_SUCCESS_SUFFIX}`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); 
                                        TerminalUI.updatePrompt(); 
                                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                                        resolveCommand({ success: true, output: null}); 
                                    }, 
                                    () => { 
                                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); 
                                        resolveCommand({ success: true, output: null}); 
                                    } 
                                ); 
                            } catch (parseError) { 
                                console.error("Restore error - parsing JSON:", parseError); 
                                await OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                resolveCommand({ success: false, error: "Could not parse backup file."}); 
                            } 
                        }; 
                        reader.onerror = async (e) => { 
                            console.error("Restore error - reading file:", e); 
                            await OutputManager.appendToOutput("Error: Could not read the selected file.", { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                            resolveCommand({ success: false, error: "Could not read file."}); 
                        }; 
                        reader.readAsText(file); 
                    }; 
                    fileInput.click(); 
                }); 
            }

            async function handleUpload(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('upload', argValidation.errorDetail);

                const fileInput = Utils.createElement('input', { type: 'file', accept: '.txt,.md,.html,.sh'});
                return new Promise((resolveCommand) => { 
                    fileInput.onchange = async (event) => { 
                        const file = event.target.files[0]; 
                        if (!file) { 
                            await OutputManager.appendToOutput(Config.MESSAGES.UPLOAD_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); 
                            resolveCommand({ success: true, output: null }); return; 
                        } 
                        const fileName = file.name; 
                        const fileExtension = Utils.getFileExtension(fileName); 
                        const allowedExtensions = ['txt', 'md', 'html', 'sh']; 
                        if (!allowedExtensions.includes(fileExtension)) { 
                            const errorMsg = `${Config.MESSAGES.UPLOAD_INVALID_TYPE_PREFIX}${fileExtension}${Config.MESSAGES.UPLOAD_INVALID_TYPE_SUFFIX}`; 
                            await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                            resolveCommand({ success: false, error: errorMsg }); return; 
                        } 
                        const reader = new FileReader(); 
                        reader.onload = async (e) => { 
                            try { 
                                const fileContent = e.target.result; 
                                const currentDirNode = FileSystemManager.getNodeByPath(FileSystemManager.getCurrentPath()); 
                                if (currentDirNode && currentDirNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) { 
                                    currentDirNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: fileContent }; 
                                    if (await FileSystemManager.save(UserManager.getCurrentUser().name)) { 
                                        const successMsg = `${Config.MESSAGES.UPLOAD_SUCCESS_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_SUCCESS_MIDDLE}${FileSystemManager.getCurrentPath()}${Config.MESSAGES.UPLOAD_SUCCESS_SUFFIX}`; 
                                        await OutputManager.appendToOutput(successMsg, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); 
                                        resolveCommand({ success: true, output: null }); 
                                    } else { 
                                        const saveErrorMsg = `Error saving uploaded file '${fileName}' to filesystem.`; 
                                        await OutputManager.appendToOutput(saveErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                        resolveCommand({ success: false, error: saveErrorMsg }); 
                                    } 
                                } else { 
                                    const dirErrorMsg = `Error: Cannot upload file. Current path '${FileSystemManager.getCurrentPath()}' is not a valid directory.`; 
                                    await OutputManager.appendToOutput(dirErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                    resolveCommand({ success: false, error: dirErrorMsg }); 
                                } 
                            } catch (readError) { 
                                console.error("Upload error - processing file content:", readError); 
                                const errorMsg = `${Config.MESSAGES.UPLOAD_READ_ERROR_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_READ_ERROR_SUFFIX}`; 
                                await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                resolveCommand({ success: false, error: errorMsg }); 
                            } 
                        }; 
                        reader.onerror = async (e) => { 
                            console.error("Upload error - reading file:", e); 
                            const errorMsg = `${Config.MESSAGES.UPLOAD_READ_ERROR_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_READ_ERROR_SUFFIX}`; 
                            await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                            resolveCommand({ success: false, error: errorMsg }); 
                        }; 
                        reader.readAsText(file); 
                    }; 
                    fileInput.click(); 
                }); 
            }
            async function handleHistoryCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 0 });
                if (!argValidation.isValid) return _createUsageError('history', argValidation.errorDetail);
                const history = HistoryManager.getFullHistory(); 
                if (history.length === 0) return { success: true, output: Config.MESSAGES.NO_COMMANDS_IN_HISTORY }; 
                return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') }; 
            }
            
            function _parseFindArgs(args) {
                let searchPathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL; 
                let pattern = null;
                const nameOptionIndex = args.indexOf('-name');
                if (nameOptionIndex === -1) { 
                    return { error: `usage: find [path] -name "<pattern>"` }; 
                }
                if (nameOptionIndex === 0) { 
                    if (args.length < 2) return { error: "missing pattern after -name" };
                    pattern = args[1];
                    if (args.length > 2) searchPathArg = args[2]; 
                } else { 
                    searchPathArg = args.slice(0, nameOptionIndex).join(' '); 
                    if (nameOptionIndex + 1 >= args.length) return { error: "missing pattern after -name" };
                    pattern = args[nameOptionIndex + 1];
                }
                if (pattern && pattern.length >= 2) {
                    const firstChar = pattern[0];
                    const lastChar = pattern[pattern.length - 1];
                    if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                        pattern = pattern.substring(1, pattern.length - 1);
                    }
                }
                if (!pattern) return { error: "pattern cannot be empty" };
                if (searchPathArg.trim() === "") searchPathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL; 
                return { searchPathArg, pattern, error: null };
            }
            function _findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) {
                if (!currentSearchNode || currentSearchNode.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return; 
                }
                const childrenNames = Object.keys(currentSearchNode.children).sort(); 
                for (const name of childrenNames) {
                    const childNode = currentSearchNode.children[name];
                    const childFullPath = FileSystemManager.getAbsolutePath(name, currentSearchPath);
                    if (_matchFindPattern(name, pattern)) {
                        foundItems.push(childFullPath + (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? Config.FILESYSTEM.PATH_SEPARATOR : ''));
                    }
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        _findRecursive(childNode, childFullPath, pattern, foundItems);
                    }
                }
            }
            function _matchFindPattern(name, pattern) {
                let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&'); 
                regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.'); 
                const regex = new RegExp(`^${regexPattern}$`); 
                return regex.test(name);
            }
            async function handleFind(args, cmdOptions) { 
                const commandName = 'find';
                const parsedArgs = _parseFindArgs(args); 
                if (parsedArgs.error) return _createUsageError(commandName, parsedArgs.error); 
                
                const { searchPathArg, pattern } = parsedArgs;
                const validation = FileSystemManager.validatePath(commandName, searchPathArg, { expectedType: 'any', defaultToCurrentIfEmpty: true });
                let startingNode = validation.node;
                let startingPath = validation.resolvedPath;
                if (validation.error) return { success: false, error: validation.error };
                const foundItems = [];
                try {
                    if (startingNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        const fileName = startingPath.substring(startingPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        if (_matchFindPattern(fileName, pattern)) foundItems.push(startingPath);
                    } else if (startingNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        const dirName = startingPath === Config.FILESYSTEM.ROOT_PATH ? Config.FILESYSTEM.ROOT_PATH : startingPath.substring(startingPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        if (dirName && _matchFindPattern(dirName, pattern) && startingPath !== Config.FILESYSTEM.ROOT_PATH) {}
                         _findRecursive(startingNode, startingPath, pattern, foundItems);
                    }
                } catch (e) { 
                     return { success: false, error: `${commandName}: ${e.message}` };
                }
                return { success: true, output: foundItems.length > 0 ? foundItems.join('\n') : "" }; 
            }
            async function handleCheckFailCmd(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('check_fail', argValidation.errorDetail + ". Specify a command string to execute.");

                const subCommandStr = args[0]; 
                await OutputManager.appendToOutput(`check_fail: Executing '${subCommandStr}' (expected to fail)...`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); 
                const subCmdResult = await processSingleCommand(subCommandStr, false); 
                if (!subCmdResult.success) { 
                    const successMsg = `check_fail: OK - Command '${subCommandStr}' correctly failed.`; 
                    await OutputManager.appendToOutput(successMsg, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); 
                    return { success: true, output: null }; 
                } else { 
                    const errorMsg = `check_fail: TEST FAILURE - Command '${subCommandStr}' succeeded but was expected to fail.`; 
                    await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                    return { success: false, error: `TEST FAILURE: '${subCommandStr}' succeeded unexpectedly.` }; 
                } 
            }
            async function handleDelay(args, cmdOptions) { 
                const argValidation = Utils.validateArguments(args, { exact: 1 });
                if (!argValidation.isValid) return _createUsageError('delay', argValidation.errorDetail + ". Specify milliseconds.");

                const delayTimeArg = args[0];
                const numericValidation = Utils.parseNumericArg(delayTimeArg, { allowNegative: false, min: 0 });

                if (numericValidation.error) {
                    return { success: false, error: `delay: invalid delay time '${delayTimeArg}'. It ${numericValidation.error}.` };
                }
                
                const milliseconds = numericValidation.value;
                if (milliseconds > 0) { 
                    await new Promise(resolve => setTimeout(resolve, milliseconds)); 
                } 
                return { success: true, output: null }; 
            }
            
            function _createUsageError(commandName, message) { 
                const usage = commands[commandName]?.usage || `No usage information available for '${commandName}'.`; 
                const finalMessage = message || 'missing operand'; 
                return { success: false, error: `${commandName}: ${finalMessage}\nUsage: ${usage}` }; 
            }

            const commands = {
                'ls': { handler: handleLs, summary: 'Lists directory contents.', usage: 'ls [path/to/directory]', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { handler: handleCd, summary: 'Changes current directory.', usage: 'cd <path/to/directory>', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { handler: handleMkdir, summary: 'Creates a new directory, including parents.', usage: 'mkdir <path/to/new_directory_name>', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { handler: handleTouch, summary: 'Creates an empty file or updates timestamp.', usage: 'touch <path/to/filename>', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { handler: handleCat, summary: 'Displays file contents.', usage: 'cat <path/to/filename>', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { handler: handleEcho, summary: 'Displays text.', usage: 'echo [text]', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. The parser handles unquoting of string literals. To write to a file, use redirection operators > (overwrite) or >> (append).', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { handler: handleMv, summary: 'Moves or renames a file or directory.', usage: 'mv <source_path> <destination_path>', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { handler: handleCp, summary: 'Copies a file or directory.', usage: 'cp <source_path> <destination_path>', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { handler: handleRm, summary: 'Removes a file or directory (confirms unless forced).', usage: 'rm [-f|--force] <path/to/item>', syntax: 'rm [-f|--force] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation in interactive mode. In scripts, -f or --force is required to prevent accidental deletion. The -f or --force option bypasses confirmation and allows removal. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { handler: handlePwd, summary: 'Prints the current working directory path.', usage: 'pwd', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { handler: handleDate, summary: 'Displays the current date and time.', usage: 'date', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'run': { handler: handleRun, summary: 'Executes commands from a script file.', usage: 'run <path/to/scriptfile>', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history. User input is suspended while a script is running.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'clear': { handler: handleClear, summary: 'Clears the terminal screen.', usage: 'clear', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { handler: handleRegisterCmd, summary: 'Creates a new user profile.', usage: 'register <username>', syntax: 'register USERNAME', details: 'Registers a new user. Usernames are unique. The username "Guest" is reserved.', examples: ['register myuser']},
                'login': { handler: handleLoginCmd, summary: 'Logs in as a specified user.', usage: 'login <username>', syntax: 'login USERNAME', details: 'Logs in as the specified USERNAME. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser']},
                'logout': { handler: handleLogoutCmd, summary: 'Logs out the current user.', usage: 'logout', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { handler: handleSavestate, summary: 'Manually saves the current session.', usage: 'savestate', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { handler: handleLoadstate, summary: 'Loads the last manually saved session (confirms).', usage: 'loadstate', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { handler: handleReset, summary: 'Performs a full factory reset (confirms).', usage: 'reset', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states. This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { handler: handleHelp, summary: 'Displays command information.', usage: 'help [command_name]', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays detailed information for that command, including usage, syntax, a full description, and examples.', examples: ['help', 'help ls', 'help echo']},
                'edit': { handler: handleEditCmd, summary: 'Edits a text file or creates a new one.', usage: 'edit <path/to/filename>', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving, Ctrl+P to toggle preview for MD/HTML.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'tree': { handler: handleTree, summary: 'Displays directory structure as a tree.', usage: 'tree [path]', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { handler: handleFind, summary: 'Searches for files and directories.', usage: 'find [path] -name "<pattern>"', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'export': { handler: handleExport, summary: 'Exports a file to your local disk.', usage: 'export <path/to/filename>', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log'] },
                'backup': { handler: handleBackup, summary: 'Backs up current user session to a local file.', usage: 'backup', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup'] },
                'restore': { handler: handleRestore, summary: 'Restores a user session from a local backup file.', usage: 'restore', syntax: 'restore', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['restore'] },
                'upload': { handler: handleUpload, summary: 'Uploads a local file (.txt, .md, .html, .sh) to the current directory.', usage: 'upload', syntax: 'upload', details: 'Prompts you to select a local file (.txt, .md, .html, or .sh). The selected file\'s content will be saved into a new file with the same name in the current OopisOs directory. If a file with the same name already exists, it will be overwritten.', examples: ['upload'] },
                'history': { handler: handleHistoryCmd, summary: 'Displays the command history.', usage: 'history', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history'] },
                'check_fail': {  handler: handleCheckFailCmd, summary: 'Runs a command and succeeds if the command fails.', usage: 'check_fail "<command_string>"', syntax: 'check_fail "COMMAND [ARGS...]"', details: 'Executes the specified COMMAND with its ARGS, all provided as a single quoted string. If the COMMAND fails, check_fail reports success and allows script execution to continue. If the COMMAND succeeds (unexpectedly for a failure test), check_fail reports an error and will cause the calling script (via `run`) to halt. Ensure the entire command to be checked, including any of its own arguments or redirection symbols (>, >>), is enclosed in one set of quotes.', examples: ['check_fail "ls /non_existent_directory"', 'check_fail "echo text > /a/file/that/should/fail_creation"'] },
                'delay': { handler: handleDelay, summary: 'Pauses execution for a specified time.', usage: 'delay <milliseconds>', syntax: 'delay MILLISECONDS', details: 'Pauses script execution for the given number of MILLISECONDS. Useful in scripts to pace output or wait for asynchronous operations if needed (though OopisOS commands are generally awaited).', examples: ['delay 1000', 'delay 500'] }
            };
            
            async function _executeCommandHandler(parsedCommand, executionContextOptions) { 
                const commandData = commands[parsedCommand.baseCommand.toLowerCase()];
                const { isInteractive } = executionContextOptions; 
                
                if (commandData && typeof commandData.handler === 'function') {
                    try {
                        const explicitForce = parsedCommand.args.includes('-f') || parsedCommand.args.includes('--force');
                        const optionsForHandler = {
                            isInteractive: isInteractive,
                            explicitForce: explicitForce 
                        };
                        return await commandData.handler(parsedCommand.args, optionsForHandler);
                    } catch (e) { 
                        console.error(`Error in command handler for '${parsedCommand.baseCommand}':`, e);
                        return { success: false, error: `Command failed: ${e.message}` };
                    }
                } else if (parsedCommand.baseCommand) { 
                    return { success: false, error: `${parsedCommand.baseCommand}: command not found` };
                } else { 
                    return { success: true, output: "" }; 
                }
            }

            async function _processCommandOutput(parsedCommand, cmdResult, isInteractive) { 
                let finalResult = { ...cmdResult }; 
                if (parsedCommand.redirection && parsedCommand.redirection.file) {
                    const { type: redirType, file: redirFile } = parsedCommand.redirection;
                    const outputToRedirect = cmdResult.success ? (cmdResult.output || "") : (cmdResult.error || "");
                    const redirValidation = FileSystemManager.validatePath('redirection', redirFile, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false });
                    if (redirValidation.error) { 
                        await OutputManager.appendToOutput(redirValidation.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        finalResult = { success: false, error: redirValidation.error }; 
                    } else {
                        const absRedirectPath = redirValidation.resolvedPath;
                        const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absRedirectPath);
                        if (parentDirResult.error) { 
                            await OutputManager.appendToOutput(`Redirection error: ${parentDirResult.error}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            finalResult = { success: false, error: parentDirResult.error }; 
                        } else {
                            const parentNode = parentDirResult.parentNode;
                            const redirectFileName = absRedirectPath.substring(absRedirectPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            let existingContent = "";
                            if (redirType === 'append' && parentNode.children[redirectFileName]) {
                                existingContent = parentNode.children[redirectFileName].content || "";
                                if (existingContent && !existingContent.endsWith('\n') && outputToRedirect.length > 0) existingContent += '\n'; 
                            }
                            parentNode.children[redirectFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: existingContent + outputToRedirect };
                            if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                const saveErrorMsg = `Failed to save redirected output to '${redirFile}'.`;
                                await OutputManager.appendToOutput(saveErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                if (finalResult.success) finalResult.error = (finalResult.error ? finalResult.error + "\n" : "") + saveErrorMsg;
                                finalResult.success = false; 
                            }
                        }
                    }
                    if(finalResult.success && !cmdResult.isHtmlOutput) finalResult.output = null;
                } else if (!cmdResult.isHtmlOutput) { 
                    if (cmdResult.error) {
                        await OutputManager.appendToOutput(cmdResult.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else if (cmdResult.output !== null && cmdResult.output !== undefined) {
                        await OutputManager.appendToOutput(cmdResult.output, { typeClass: cmdResult.messageType || null });
                    }
                }
                return finalResult;
            }

            async function _finalizeInteractiveModeUI(originalCommandText) { 
                TerminalUI.clearInput(); 
                TerminalUI.updatePrompt(); 
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput(); 
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                if (!TerminalUI.getIsNavigatingHistory() && originalCommandText.trim() !== "") {
                    HistoryManager.resetIndex();
                }
                TerminalUI.setIsNavigatingHistory(false); 
            }

            async function processSingleCommand(rawCommandText, isInteractive = true) {
                lastCommandFailed = false; 
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false };
                
                if (scriptExecutionInProgress && isInteractive) {
                    return { success: false, error: "Script execution in progress. Input suspended."};
                }

                if (EditorManager.isActive()) return finalResult; 
                if (ConfirmationManager.isAwaiting()) { await ConfirmationManager.handleConfirmation(rawCommandText); if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); return finalResult; }
                
                const commandToEcho = rawCommandText.trim(); 
                let commandToExecute = rawCommandText.trim(); 
                
                if (isInteractive) { 
                    DOM.inputLineContainerDiv.style.visibility = 'hidden'; 
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `; 
                    await OutputManager.appendToOutput(`${promptText}${commandToEcho}`); 
                }

                if (commandToExecute === '') { if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); return finalResult; }
                if (isInteractive) HistoryManager.add(rawCommandText.trim());
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) HistoryManager.resetIndex();
                
                let parsedCommand;
                try { 
                    const lexer = new Lexer(commandToExecute); 
                    const tokens = lexer.tokenize(); 
                    const parser = new Parser(tokens); 
                    parsedCommand = parser.parse(); 
                } catch (e) { 
                    await OutputManager.appendToOutput(e.message, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                    return { success: false, error: e.message }; 
                }
                
                const executionContextOptions = { isInteractive: isInteractive };
                const cmdResult = await _executeCommandHandler(parsedCommand, executionContextOptions); 
                
                finalResult = await _processCommandOutput(parsedCommand, cmdResult, isInteractive);
                lastCommandFailed = !finalResult.success; 
                if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                return finalResult;
            }

            function getCommands() {
                return commands;
            }

            function isScriptRunning() {
                return scriptExecutionInProgress;
            }

            return {
                processSingleCommand,
                getLastCommandFailed: () => lastCommandFailed,
                getCommands,
                isScriptRunning 
            };
        })();

        // --- TERMINAL EVENT LISTENERS INITIALIZATION ---
        function initializeTerminalEventListeners() { 
            DOM.terminalDiv.addEventListener('click', e => { 
                if (EditorManager.isActive()) return; 
                if (CommandExecutor.isScriptRunning()) return; 
                if (!e.target.closest('button, a') && (!DOM.editableInputDiv || !DOM.editableInputDiv.contains(e.target))) {
                    TerminalUI.focusInput();
                }
            });
            
            const getCurrentInputTarget = () => DOM.editableInputDiv;

            document.addEventListener('keydown', async e => {
                if (CommandExecutor.isScriptRunning()) {
                    if (e.key === "Enter" || e.key === "Tab" || e.key.startsWith("Arrow")) {
                        e.preventDefault();
                    }
                    return; 
                }

                if (EditorManager.isActive()) return; 
                const activeInputTarget = getCurrentInputTarget();
                if (!activeInputTarget || (document.activeElement !== activeInputTarget && !activeInputTarget.contains(document.activeElement))) {
                    return;
                }

                TerminalUI.setIsNavigatingHistory(false); 
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    const commandText = TerminalUI.getCurrentInputValue(); 
                    await CommandExecutor.processSingleCommand(commandText, true); 
                } else if (e.key === 'ArrowUp') { 
                    e.preventDefault(); 
                    const prevCommand = HistoryManager.getPrevious(); 
                    if (prevCommand !== null) { 
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(prevCommand, true); 
                    } 
                } else if (e.key === 'ArrowDown') { 
                    e.preventDefault(); 
                    const nextCommand = HistoryManager.getNext(); 
                    if (nextCommand !== null) { 
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(nextCommand, true); 
                    } 
                } else if (e.key === 'Tab') { 
                    e.preventDefault();
                    const currentInput = TerminalUI.getCurrentInputValue();
                    const sel = window.getSelection();
                    let cursorPos = 0;
                    if (sel.rangeCount > 0) {
                        const range = sel.getRangeAt(0);
                        if (DOM.editableInputDiv.contains(range.commonAncestorContainer)) {
                             const preCaretRange = range.cloneRange();
                             preCaretRange.selectNodeContents(DOM.editableInputDiv);
                             preCaretRange.setEnd(range.endContainer, range.endOffset);
                             cursorPos = preCaretRange.toString().length;
                        } else {
                            cursorPos = currentInput.length; 
                        }
                    } else {
                         cursorPos = currentInput.length; 
                    }
                    const result = TabCompletionManager.getSuggestions(currentInput, cursorPos);
                    if (result && result.textToInsert !== null) {
                        TerminalUI.setCurrentInputValue(result.textToInsert, false); 
                        TerminalUI.setCaretPosition(DOM.editableInputDiv, result.newCursorPos); 
                    }
                }
            });
            if (DOM.editableInputDiv) { 
                DOM.editableInputDiv.addEventListener('paste', e => { 
                    e.preventDefault(); 
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain'); 
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' ')); 
                }); 
            }
        }
        
        // --- INITIALIZATION ON WINDOW LOAD ---
        window.onload = async () => {
            DOM = {
                terminalDiv: document.getElementById('terminal'),
                outputDiv: document.getElementById('output'),
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'),
                promptHostSpan: document.getElementById('prompt-host')
            };

            if (typeof Utils === 'undefined' || typeof OutputManager === 'undefined' || typeof OutputManager.initializeConsoleOverrides !== 'function') {
                const originalConsoleError = window.console.error; 
                originalConsoleError("FATAL: Core modules (Utils or OutputManager) not defined! Cannot proceed.");
                alert("FATAL ERROR: Core modules failed to load. Check console.");
                return; 
            }
            OutputManager.initializeConsoleOverrides();
            
            try {
                await OutputManager.appendToOutput("User accounts are now passwordless.");
            
                if (typeof IndexedDBManager === 'undefined' || typeof IndexedDBManager.init !== 'function') {
                     await OutputManager.appendToOutput("FATAL: IndexedDBManager not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                     console.error("FATAL: IndexedDBManager or IndexedDBManager.init is not defined!");
                     alert("FATAL ERROR: IndexedDBManager module failed to load. Check console.");
                     return;
                }
                await IndexedDBManager.init(); 
                
                if (typeof UserManager === 'undefined' || typeof UserManager.getDefaultUser !== 'function') {
                    await OutputManager.appendToOutput("FATAL: UserManager not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    console.error("FATAL: UserManager or UserManager.getDefaultUser is not defined!");
                    alert("FATAL ERROR: UserManager module failed to load. Check console.");
                    return;
                }
                const guestUser = { name: UserManager.getDefaultUser() };
                UserManager.setCurrentUserObject(guestUser);
                
                if (typeof FileSystemManager === 'undefined' || typeof SessionManager === 'undefined' || typeof TabCompletionManager === 'undefined') { 
                     await OutputManager.appendToOutput("FATAL: Core logic module (FileSystem, Session, or TabCompletion) not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                     console.error("FATAL: FileSystemManager, SessionManager, or TabCompletionManager is not defined!");
                     alert("FATAL ERROR: Core logic module failed to load. Check console.");
                     return;
                }
                await FileSystemManager.load(UserManager.getDefaultUser()); 
                SessionManager.loadAutomaticState(UserManager.getDefaultUser()); 
                
                initializeTerminalEventListeners(); 
                TerminalUI.focusInput(); 
                
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load (main try-catch):", error, error.stack); 
                if (DOM && DOM.outputDiv && OutputManager && typeof OutputManager.appendToOutput === 'function') { 
                     OutputManager.appendToOutput(`FATAL ERROR (onload): ${error.message}. Check console.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                } else {
                    alert(`FATAL ERROR (onload): ${error.message}. DOM.outputDiv is null or OutputManager not ready. Check console.`);
                }
            }
        };
    </script>
</body>
</html>