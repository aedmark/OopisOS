<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 0.4.10, 'Stranger in the Alps'</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em; 
            line-height: 1.2em;
        }

        .input-line-container { 
            display: flex; 
            align-items: flex-start; 
            width: 100%; 
        }
        .prompt-container {
            display: flex;
            align-items: center; 
            line-height: 1.2em; 
            flex-shrink: 0; 
            white-space: nowrap; 
            padding-top: 0.1em; 
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container { 
            flex-grow: 1;
            min-width: 0; 
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            outline: none;
            caret-color: #00ff00;
            color: #00ff00; 
            width: 100%; 
        }
        
        #password-input-field { 
            background-color: transparent;
            border: none;
            outline: none;
            color: #00ff00;
            font-family: 'VT323', monospace;
            font-size: 1em; 
            line-height: 1.2em;
            height: 1.2em;
            padding: 0;
            margin: 0;
            width: 100%;
            flex-grow: 1; 
        }

        #hidden-legacy-input { 
             position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; 
        }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }
        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; }
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        #editor-textarea-wrapper { border-right: 1px solid #333; }
        #editor-textarea { width: 100%; height: 100%; background-color: #0c0c0c; color: #00dd00; border: none; font-family: 'VT323', monospace; font-size: 1em; line-height: 1.2em; resize: none; outline: none; padding: 0; }
        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre > code { display: block; padding: 10px; overflow-x: auto; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }
        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }
        .diag-section-title { color: #00ffff; font-weight: bold; margin-top: 8px; margin-bottom: 3px; }
    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            <input type="text" id="hidden-legacy-input" style="position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;">
        </div>
    </div>

    <script>
        // --- CONFIG MODULE ---
        const Config = (() => {
            return {
                DATABASE: { NAME: "OopisOsDB", VERSION: 1, FS_STORE_NAME: "FileSystemsStore" },
                OS: { NAME: "OopisOs", VERSION: "0.4.10" },
                USER: { DEFAULT_NAME: "Guest" },
                TERMINAL: { MAX_HISTORY_SIZE: 50, MAX_ALIAS_EXPANSION_DEPTH: 10, DEFAULT_TYPING_SPEED: 35 },
                STORAGE_KEYS: { USER_CREDENTIALS: 'oopisOsUserCredentials', USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_', MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_', ALIAS_FILE_PATH: "/.aliases" },
                CSS_CLASSES: { ERROR_MSG: 'error-message', SUCCESS_MSG: 'success-message', CONSOLE_LOG_MSG: 'console-log-message', WARNING_MSG: 'warning-message', DIR_ITEM: 'directory-item', FILE_ITEM: 'file-item', HELP_CMD_NAME: 'help-command-name', HELP_DESC: 'help-description', OUTPUT_LINE: 'output-line', MAN_SECTION_TITLE: 'man-section-title', MAN_SECTION_CONTENT: 'man-section-content', MAN_EXAMPLE: 'man-example', SYSMON_LABEL: 'sysmon-label', EDITOR_MESSAGE: 'editor-message', DIAG_OUTPUT: 'diag-output', DIAG_SECTION: 'diag-section-title' }
            };
        })();

        // --- DOM MODULE ---
        const DOM = (() => { 
            return { 
                terminalDiv: document.getElementById('terminal'), 
                outputDiv: document.getElementById('output'), 
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'), 
                promptPathSpan: document.getElementById('prompt-path'), 
                promptHostSpan: document.getElementById('prompt-host') 
            };
        })();

        // --- UTILS MODULE ---
        const Utils = (() => { 
            function formatConsoleArgs(args) { return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' '); }
            function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }
            async function hashPassword(password) { try { const encoder = new TextEncoder(); const data = encoder.encode(password); const hashBuffer = await crypto.subtle.digest('SHA-256', data); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); } catch (error) { console.error("Password hashing failed:", error); throw new Error("Password hashing service unavailable."); } }
            function formatBytes(bytes, decimals = 2) { if (bytes === 0) return '0 B'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
            function parseNumericOption(args, optionStr, defaultValue) { let numericValue = defaultValue; const remainingArgs = [...args]; let error = null; const optionIndex = remainingArgs.indexOf(optionStr); if (optionIndex !== -1) { if (optionIndex + 1 < remainingArgs.length) { const potentialNumber = remainingArgs[optionIndex + 1]; const parsedNumber = parseInt(potentialNumber, 10); if (!isNaN(parsedNumber) && parsedNumber >= 0) { numericValue = parsedNumber; remainingArgs.splice(optionIndex, 2); } else { error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`; remainingArgs.splice(optionIndex, 2); } } else { error = `option ${optionStr} requires an argument`; remainingArgs.splice(optionIndex, 1); } } return { value: numericValue, remainingArgs, error }; }
            function findLCS(X, Y) { const m = X.length; const n = Y.length; const L = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0)); for (let i = 0; i <= m; i++) { for (let j = 0; j <= n; j++) { if (i === 0 || j === 0) L[i][j] = 0; else if (X[i - 1] === Y[j - 1]) L[i][j] = L[i - 1][j - 1] + 1; else L[i][j] = Math.max(L[i - 1][j], L[i][j - 1]); } } let index = L[m][n]; const lcs = Array(index); let i = m, j = n; while (i > 0 && j > 0) { if (X[i - 1] === Y[j - 1]) { lcs[index - 1] = X[i - 1]; i--; j--; index--; } else if (L[i - 1][j] > L[i][j - 1]) i--; else j--; } return lcs; }
            function getFileExtension(filePath) { const name = filePath.substring(filePath.lastIndexOf('/') + 1); const lastDot = name.lastIndexOf('.'); if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) return ''; return name.substring(lastDot + 1).toLowerCase(); }
            return { formatConsoleArgs, deepCopyNode, hashPassword, formatBytes, parseNumericOption, findLCS, getFileExtension };
        })();

        // --- OUTPUT MANAGER MODULE ---
        const OutputManager = (() => {
            let isEditorActive = false, isDiagRunning = false;
            const originalConsoleLog = console.log, originalConsoleWarn = console.warn, originalConsoleError = console.error;
            function setEditorActive(status) { isEditorActive = status; }
            function setDiagRunning(status) { isDiagRunning = status; }
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            async function _typeTextCinematically(element, text, speed) { for (const char of text) { element.textContent += char; DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; await sleep(speed); } }
            async function appendToOutput(text, options = {}) { if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MESSAGE && !isDiagRunning) return; const { isInstant = false, typingSpeed = Config.TERMINAL.DEFAULT_TYPING_SPEED, isError = false, typeClass = null } = options; const lines = String(text).split('\n'); const forceInstant = isError || typeClass === Config.CSS_CLASSES.WARNING_MSG || typeClass === Config.CSS_CLASSES.CONSOLE_LOG_MSG || typeClass === Config.CSS_CLASSES.DIAG_OUTPUT || typeClass === Config.CSS_CLASSES.DIAG_SECTION || (CommandExecutor && CommandExecutor.isDiagActive() && typeClass !== null); for (const line of lines) { const newLine = document.createElement('div'); newLine.classList.add(Config.CSS_CLASSES.OUTPUT_LINE); if (typeClass) newLine.classList.add(typeClass); if (isError && !typeClass) newLine.classList.add(Config.CSS_CLASSES.ERROR_MSG); DOM.outputDiv.appendChild(newLine); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; if (isInstant || forceInstant) { newLine.textContent = line; } else { await _typeTextCinematically(newLine, line, typingSpeed); } } DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }
            function appendHtmlToOutput(htmlContent) { if (isEditorActive && !isDiagRunning) return; const blockDiv = document.createElement('div'); blockDiv.innerHTML = htmlContent; DOM.outputDiv.appendChild(blockDiv); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }
            function appendStyledOutput(label, value) { if (isEditorActive) return; OutputManager.appendToOutput(`${label.padEnd(20, ' ')}${value}`, {isInstant: true, typeClass: Config.CSS_CLASSES.SYSMON_LABEL});}
            function clearOutput() { if (!isEditorActive) DOM.outputDiv.innerHTML = '';}
            console.log = (...args) => { appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); originalConsoleLog.apply(console, args); };
            console.warn = (...args) => { appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG }); originalConsoleWarn.apply(console, args); };
            console.error = (...args) => { appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { isError: true }); originalConsoleError.apply(console, args); };
            return { setEditorActive, setDiagRunning, appendToOutput, appendHtmlToOutput, appendStyledOutput, clearOutput };
        })();

        const StorageManager = (() => { function loadJSON(key, itemName, defaultValue = null) { try { const storedValue = localStorage.getItem(key); if (storedValue) return JSON.parse(storedValue); } catch (e) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG }); } return defaultValue; } function saveJSON(key, data, itemName) { try { localStorage.setItem(key, JSON.stringify(data)); return true; } catch (e) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { isInstant: true, isError: true }); } return false; }  function removeItem(key) { localStorage.removeItem(key); } function getAllLocalStorageKeys() { const keys = []; for (let i = 0; i < localStorage.length; i++) keys.push(localStorage.key(i)); return keys; } return { loadJSON, saveJSON, removeItem, getAllLocalStorageKeys }; })();
        const IndexedDBManager = (() => { let dbInstance = null; function init() { return new Promise((resolve, reject) => { if (dbInstance) { resolve(dbInstance); return; } const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION); request.onupgradeneeded = (event) => { const tempDb = event.target.result; if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' }); }; request.onsuccess = (event) => { dbInstance = event.target.result; if (!CommandExecutor || !CommandExecutor.isDiagActive() && !window.diagInitializedForOutput) { OutputManager.appendToOutput("FileSystem DB initialized.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); window.diagInitializedForOutput = true; } resolve(dbInstance); }; request.onerror = (event) => { console.error("Database error: ", event.target.error); OutputManager.appendToOutput("Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private browsing mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.", { isInstant: true, isError: true }); reject(event.target.error); }; }); }  function getDbInstance() { if (!dbInstance) { OutputManager.appendToOutput("Error: OopisOs file system storage is not available. Please ensure browser storage is enabled.", { isInstant: true, isError: true }); throw new Error("IndexedDB not initialized."); } return dbInstance; }  return { init, getDbInstance }; })();
        const FileSystemManager = (() => { let fsData = {}, currentPath = '/'; function getFileSystemKey(user) { return `fs_${user}`; } async function initialize(user) { fsData = { '/': { type: 'directory', children: {} } }; await save(user); } async function save(user) { const db = IndexedDBManager.getDbInstance(); if (!db) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { isInstant: true, isError: true }); return Promise.reject("DB not initialized for FS save"); } return new Promise((resolve, reject) => { try { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const dataToSave = Utils.deepCopyNode(fsData); if (!dataToSave || typeof dataToSave !== 'object' || !dataToSave['/'] || dataToSave['/'].type !== 'directory') { console.error("Attempted to save invalid fsData structure for user:", user, dataToSave); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { isInstant: true, isError: true }); return reject(new Error("Corrupted FS data before saving.")); } const request = store.put({ id: getFileSystemKey(user), data: dataToSave }); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error(`Error saving FS for ${user}:`, event.target.error); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { isInstant: true, isError: true }); reject(event.target.error); }; } catch (e) { console.error(`Error initiating save transaction for ${user}:`, e); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { isInstant: true, isError: true }); reject(e); } }); } async function load(user) { const db = IndexedDBManager.getDbInstance(); if (!db) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { isInstant: true, isError: true }); fsData = { '/': { type: 'directory', children: {} } }; return Promise.reject("DB not initialized for FS load"); } return new Promise(async (resolve, reject) => { try { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.get(getFileSystemKey(user)); request.onsuccess = async (event) => { const result = event.target.result; if (result && result.data && result.data['/']?.type === 'directory') fsData = result.data; else { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(result ? `Warning: File system for '${user}' appears invalid. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`, { isInstant: true, typeClass: result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG }); await initialize(user); } resolve(); }; request.onerror = async (event) => { console.error(`Error loading FS for ${user}:`, event.target.error); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG }); await initialize(user); reject(event.target.error); }; } catch (e) { console.error(`Error initiating load transaction for ${user}:`, e); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG }); await initialize(user); reject(e); } }); } async function deleteUserFS(user) { const db = IndexedDBManager.getDbInstance(); if (!db) return Promise.reject("DB not initialized for FS delete"); return new Promise((resolve, reject) => { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.delete(getFileSystemKey(user)); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error(`Error deleting FS for ${user}:`, event.target.error); reject(event.target.error); }; }); } async function clearAllFS() { const db = IndexedDBManager.getDbInstance(); if (!db) { OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { isInstant: true, isError: true }); return Promise.reject("DB not initialized for clearing all FS"); } return new Promise((resolve, reject) => { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.clear(); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error("Error clearing FileSystemsStore:", event.target.error); OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { isInstant: true, isError: true }); reject(event.target.error); }; }); }  function getCurrentPath() { return currentPath; } function setCurrentPath(path) { currentPath = path; } function getFsData() { return fsData; } function setFsData(newData) { fsData = newData; } function getAbsolutePath(targetPath, basePath) { if (!targetPath) targetPath = '.'; if (targetPath.startsWith('/')) basePath = '/'; const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s && s !== '.'); let resolvedSegments = [...baseSegments]; const targetSegments = targetPath.split('/'); for (const segment of targetSegments) { if (segment === '' || segment === '.') { if (targetPath.startsWith('/') && resolvedSegments.length === 0 && segment === '') {} continue; } if (segment === '..') { if (resolvedSegments.length > 0) resolvedSegments.pop(); } else resolvedSegments.push(segment); } if (targetPath.startsWith('/') && resolvedSegments.length === 0) return '/'; return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/'); } function getNodeByPath(path) { const absolutePath = getAbsolutePath(path, currentPath); if (absolutePath === '/') return fsData['/']; const segments = absolutePath.substring(1).split('/').filter(s => s); let currentNode = fsData['/']; for (const segment of segments) { if (currentNode && currentNode.type === 'directory' && currentNode.children && currentNode.children[segment]) currentNode = currentNode.children[segment]; else return null; } return currentNode; } function createParentDirectoriesIfNeeded(fullPath) { if (fullPath === '/') return { parentNode: null, error: "Cannot create parent for root." }; const lastSlashIndex = fullPath.lastIndexOf('/'); if (lastSlashIndex === -1 && fullPath.startsWith('/')) return { parentNode: fsData['/'], error: null }; if (lastSlashIndex === -1 && !fullPath.startsWith('/')) return { parentNode: fsData['/'], error: null }; const parentPath = lastSlashIndex === 0 ? '/' : fullPath.substring(0, lastSlashIndex); const newFileName = fullPath.substring(lastSlashIndex + 1); if (!newFileName || newFileName === "." || newFileName === "..") return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` }; if (parentPath === '/') return { parentNode: fsData['/'], error: null }; const parentPathSegments = parentPath.substring(1).split('/').filter(s => s); let currentDirNode = fsData['/']; let currentBuiltParentPath = ""; for (const segment of parentPathSegments) { currentBuiltParentPath += "/" + segment; if (!currentDirNode.children[segment]) currentDirNode.children[segment] = { type: 'directory', children: {} }; else if (currentDirNode.children[segment].type !== 'directory') return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` }; currentDirNode = currentDirNode.children[segment]; } return { parentNode: currentDirNode, error: null }; } function calculateNodeSize(node) { if (!node) return 0; if (node.type === 'file') return (node.content || "").length; if (node.type === 'directory') { let totalSize = 0; for (const childName in node.children) totalSize += calculateNodeSize(node.children[childName]); return totalSize; } return 0; } function validatePath(commandName, pathArg, options = {}) { const { expectedType = 'any', allowMissing = false, disallowRoot = false, defaultToCurrentIfEmpty = true } = options; let effectivePathArg = pathArg; if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) effectivePathArg = '.'; if (effectivePathArg === undefined || effectivePathArg === null) return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` }; const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath()); const node = getNodeByPath(resolvedPath); if (disallowRoot && resolvedPath === '/') return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '/'` }; if (node) { if (expectedType === 'file' && node.type !== 'file') return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` }; if (expectedType === 'directory' && node.type !== 'directory') return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` }; return { node: node, resolvedPath: resolvedPath, error: null }; } else { if (allowMissing) return { node: null, resolvedPath: resolvedPath, error: null }; else return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory` }; } } return { initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath, getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded, calculateNodeSize, validatePath }; })();
        const AliasManager = (() => { let userAliases = {}; async function load(currentUser) { userAliases = {}; const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH; const aliasFileNode = FileSystemManager.getNodeByPath(aliasFilePath); if (aliasFileNode && aliasFileNode.type === 'file') { try { const parsed = JSON.parse(aliasFileNode.content); if (typeof parsed === 'object' && parsed !== null) userAliases = parsed; } catch (e) {} } } async function save(currentUser) { const aliasJsonString = JSON.stringify(userAliases, null, 2); const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH; const fsData = FileSystemManager.getFsData(); const rootNode = fsData['/']; if (rootNode && rootNode.children) { const aliasFileName = aliasFilePath.substring(1); rootNode.children[aliasFileName] = { type: 'file', content: aliasJsonString }; await FileSystemManager.save(currentUser); } else OutputManager.appendToOutput("Error: Could not save aliases due to an internal file system inconsistency. Please report this issue.", { isInstant: true, isError: true }); }  async function expand(commandInputText, depth = 0) { if (depth > Config.TERMINAL.MAX_ALIAS_EXPANSION_DEPTH) { OutputManager.appendToOutput(`alias: Maximum expansion depth exceeded (possible loop).`, { isInstant: true, isError: true }); return commandInputText; } const parts = commandInputText.trim().split(' '); const potentialAlias = parts[0]; if (userAliases.hasOwnProperty(potentialAlias)) { const aliasValue = userAliases[potentialAlias]; const remainingArgs = parts.slice(1).join(' '); const expandedCommand = (aliasValue + (remainingArgs ? ' ' + remainingArgs : '')).trim(); const nextPotentialAlias = expandedCommand.split(' ')[0]; if (userAliases.hasOwnProperty(nextPotentialAlias) && nextPotentialAlias !== potentialAlias) return await expand(expandedCommand, depth + 1); return expandedCommand; } return commandInputText; } function getAliases() { return userAliases; } function setAlias(name, value) { userAliases[name] = value; } function removeAlias(name) { delete userAliases[name]; } function hasAlias(name) { return userAliases.hasOwnProperty(name); } return { load, save, expand, getAliases, setAlias, removeAlias, hasAlias }; })();
        const HistoryManager = (() => { let commandHistory = [], historyIndex = 0; function add(command) { if (command.trim() && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command.trim())) { commandHistory.push(command.trim()); if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) commandHistory.shift(); } historyIndex = commandHistory.length; } function getPrevious() { if (commandHistory.length > 0 && historyIndex > 0) { historyIndex--; return commandHistory[historyIndex]; } return null; } function getNext() { if (historyIndex < commandHistory.length - 1) { historyIndex++; return commandHistory[historyIndex]; } else if (historyIndex >= commandHistory.length - 1) { historyIndex = commandHistory.length; return ""; } return null; } function resetIndex() { historyIndex = commandHistory.length; } function getFullHistory() { return [...commandHistory]; } function clearHistory() { commandHistory = []; historyIndex = 0; } function setHistory(newHistory) { commandHistory = Array.isArray(newHistory) ? [...newHistory] : []; historyIndex = commandHistory.length; } return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory }; })();
        const ConfirmationManager = (() => { let awaitingConfirmation = false, confirmationContext = null; function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) { awaitingConfirmation = true; confirmationContext = { promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines], data: dataForAction, onConfirm: onConfirmCallback, onCancel: onCancelCallback }; confirmationContext.promptMessageLines.forEach(line => OutputManager.appendToOutput(line, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG })); OutputManager.appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG }); } async function handleConfirmation(input) { if (!awaitingConfirmation) return false; let processed = false; if (input.trim() === 'YES' && confirmationContext && typeof confirmationContext.onConfirm === 'function') { await confirmationContext.onConfirm(confirmationContext.data); processed = true; } else { if (confirmationContext && typeof confirmationContext.onCancel === 'function') confirmationContext.onCancel(confirmationContext.data); else OutputManager.appendToOutput("Operation cancelled.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); processed = true; } awaitingConfirmation = false; confirmationContext = null; return processed; } function isAwaiting() { return awaitingConfirmation; } return { request, handleConfirmation, isAwaiting }; })();
        const EditorManager = (() => { let isActiveState = false; let currentFilePath = null; let currentMode = 'text'; let debounceTimer = null; let editorContainerDiv = null; let editorControlsDiv = null; let editorFilenameDisplay = null; let viewToggleButton = null; let editorMainAreaDiv = null; let editorTextareaWrapper = null; let editorTextareaElement = null; let editorPreviewWrapper = null; let editorPreviewPaneDiv = null; let editorInstructionsFooter = null; let currentViewMode = 'split';  function _getFileExtension(filePath) { const name = filePath.substring(filePath.lastIndexOf('/') + 1); const lastDot = name.lastIndexOf('.'); if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) return ''; return name.substring(lastDot + 1).toLowerCase(); } function _determineMode(filePath) { const extension = _getFileExtension(filePath); if (extension === 'md') return 'markdown'; if (extension === 'html' || extension === 'htm') return 'html'; return 'text'; } function _updatePreview() { if (!editorTextareaElement || !editorPreviewPaneDiv) return; const content = editorTextareaElement.value; if (debounceTimer) clearTimeout(debounceTimer); debounceTimer = setTimeout(() => { if (currentMode === 'markdown') { if (typeof marked !== 'undefined') { editorPreviewPaneDiv.innerHTML = marked.parse(content); } else { editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded."; } } else if (currentMode === 'html') { let iframe = editorPreviewPaneDiv.querySelector('iframe'); if (!iframe) { iframe = document.createElement('iframe'); editorPreviewPaneDiv.innerHTML = ''; editorPreviewPaneDiv.appendChild(iframe); } iframe.srcdoc = content; } }, 250); } function _setupEditorLayout() { editorContainerDiv = document.createElement('div'); editorContainerDiv.id = 'editor-container'; editorControlsDiv = document.createElement('div'); editorControlsDiv.id = 'editor-controls'; editorFilenameDisplay = document.createElement('span'); editorFilenameDisplay.id = 'editor-filename-display'; editorFilenameDisplay.textContent = `File: ${currentFilePath}`; viewToggleButton = document.createElement('button'); viewToggleButton.id = 'editor-view-toggle'; viewToggleButton.addEventListener('click', _toggleViewMode); editorControlsDiv.appendChild(editorFilenameDisplay); editorControlsDiv.appendChild(viewToggleButton); editorContainerDiv.appendChild(editorControlsDiv); editorMainAreaDiv = document.createElement('div'); editorMainAreaDiv.id = 'editor-main-area'; editorTextareaWrapper = document.createElement('div'); editorTextareaWrapper.id = 'editor-textarea-wrapper'; editorTextareaWrapper.classList.add('editor-pane'); editorTextareaElement = document.createElement('textarea'); editorTextareaElement.id = 'editor-textarea'; editorTextareaWrapper.appendChild(editorTextareaElement); editorMainAreaDiv.appendChild(editorTextareaWrapper); if (currentMode === 'markdown' || currentMode === 'html') { editorPreviewWrapper = document.createElement('div'); editorPreviewWrapper.id = 'editor-preview-wrapper'; editorPreviewWrapper.classList.add('editor-pane'); editorPreviewPaneDiv = document.createElement('div'); editorPreviewPaneDiv.id = 'editor-preview-content'; if (currentMode === 'markdown') { editorPreviewPaneDiv.classList.add('markdown-preview'); } editorPreviewWrapper.appendChild(editorPreviewPaneDiv); editorMainAreaDiv.appendChild(editorPreviewWrapper); viewToggleButton.textContent = "Edit Only"; editorTextareaWrapper.style.flex = "1"; editorPreviewWrapper.style.flex = "1"; editorPreviewWrapper.style.display = "block"; editorTextareaWrapper.style.borderRight = '1px solid #333'; } else { viewToggleButton.style.display = 'none'; editorTextareaWrapper.style.borderRight = 'none'; } editorContainerDiv.appendChild(editorMainAreaDiv); editorInstructionsFooter = document.createElement('div'); editorInstructionsFooter.id = 'editor-instructions-footer'; editorInstructionsFooter.textContent = `Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving | Ctrl+P: Toggle Preview (MD/HTML)`; editorContainerDiv.appendChild(editorInstructionsFooter); DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv); } function _toggleViewMode() { if (currentMode !== 'markdown' && currentMode !== 'html') return; if (currentViewMode === 'split') { currentViewMode = 'edit'; viewToggleButton.textContent = "Preview Only"; editorTextareaWrapper.style.flex = "2"; editorPreviewWrapper.style.display = "none"; editorTextareaWrapper.style.borderRight = 'none'; } else if (currentViewMode === 'edit') { currentViewMode = 'preview'; viewToggleButton.textContent = "Split View"; editorTextareaWrapper.style.display = "none"; editorPreviewWrapper.style.flex = "2"; editorPreviewWrapper.style.display = "block"; } else { currentViewMode = 'split'; viewToggleButton.textContent = "Edit Only"; editorTextareaWrapper.style.display = "block"; editorTextareaWrapper.style.flex = "1"; editorPreviewWrapper.style.flex = "1"; editorPreviewWrapper.style.display = "block"; editorTextareaWrapper.style.borderRight = '1px solid #333'; } editorTextareaElement.focus(); } function enter(filePath, content) { if (isActiveState) { OutputManager.appendToOutput("Editor already active.", { isInstant: true, typeClass: Config.CSS_CLASSES.EDITOR_MESSAGE }); return; } isActiveState = true; OutputManager.setEditorActive(true); currentFilePath = filePath; currentMode = _determineMode(filePath); currentViewMode = (currentMode === 'markdown' || currentMode === 'html') ? 'split' : 'text'; DOM.outputDiv.style.display = 'none'; DOM.inputLineContainerDiv.style.display = 'none'; _setupEditorLayout(); editorTextareaElement.value = content; if (currentMode === 'markdown' || currentMode === 'html') { _updatePreview(); editorTextareaElement.addEventListener('input', _updatePreview); } editorTextareaElement.focus(); editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length); editorTextareaElement.addEventListener('keydown', handleKeyDown); } async function exit(saveChanges = false) { let success = true; if (saveChanges && editorTextareaElement && currentFilePath) { const newContent = editorTextareaElement.value; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath); if (parentDirResult.error) { OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { isInstant: true, isError: true }); success = false; } else { const parentNode = parentDirResult.parentNode; if (parentNode) { const fileName = currentFilePath.substring(currentFilePath.lastIndexOf('/') + 1); parentNode.children[fileName] = { type: 'file', content: newContent }; const currentUser = UserManager.getCurrentUser(); if (currentUser) { if (await FileSystemManager.save(currentUser.name)) OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); else { OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { isInstant: true, isError: true }); success = false; } } else { OutputManager.appendToOutput(`Error saving file: No current user context.`, { isInstant: true, isError: true }); success = false; } } else { OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { isInstant: true, isError: true }); success = false; } } } else if (currentFilePath) OutputManager.appendToOutput(`Exited editor for '${currentFilePath}' without saving.`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) { DOM.terminalDiv.removeChild(editorContainerDiv); } if (editorTextareaElement) { editorTextareaElement.removeEventListener('keydown', handleKeyDown); editorTextareaElement.removeEventListener('input', _updatePreview); } editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = null; editorMainAreaDiv = editorTextareaWrapper = editorTextareaElement = null; editorPreviewWrapper = editorPreviewPaneDiv = editorInstructionsFooter = null; if(debounceTimer) clearTimeout(debounceTimer); debounceTimer = null; isActiveState = false; OutputManager.setEditorActive(false); currentFilePath = null; currentMode = 'text'; DOM.outputDiv.style.display = ''; DOM.inputLineContainerDiv.style.display = ''; DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; TerminalUI.focusInput(); TerminalUI.updatePrompt(); return success; } async function handleKeyDown(event) { if (event.key === 'Tab') { event.preventDefault(); const start = this.selectionStart, end = this.selectionEnd; this.value = this.value.substring(0, start) + "\t" + this.value.substring(end); this.selectionStart = this.selectionEnd = start + 1; return; } if (event.ctrlKey && event.key.toLowerCase() === 's') { event.preventDefault(); await exit(true); } else if (event.ctrlKey && event.key.toLowerCase() === 'o') { event.preventDefault(); await exit(false); } else if (event.ctrlKey && event.key.toLowerCase() === 'p') { event.preventDefault(); _toggleViewMode(); } } return { isActive: () => isActiveState, enter, exit }; })();
        const UserManager = (() => { let currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; function getCurrentUser() { return currentUser; }  async function register(username, password) { const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); if (credentials[username]) return { success: false, error: `User '${username}' already exists.` }; if (username.toLowerCase() === Config.USER.DEFAULT_NAME.toLowerCase()) return { success: false, error: `Cannot register '${Config.USER.DEFAULT_NAME}'. This username is reserved.` }; if (username.includes(" ") || password.includes(" ")) return { success: false, error: "Username and password cannot contain spaces." }; try { const hashedPassword = await Utils.hashPassword(password); credentials[username] = hashedPassword; if (StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, credentials, "User creds")) { await FileSystemManager.initialize(username); await AliasManager.load(username); return { success: true, message: `User '${username}' registered. You can now login.` }; } else return { success: false, error: "Failed to save new user credentials." }; } catch (error) { return { success: false, error: `Registration failed for '${username}': ${error.message}` }; } } async function login(username, password) { if (currentUser.name === username && (!CommandExecutor || !CommandExecutor.isDiagActive())) return { success: true, message: `Already logged in as '${username}'.`, noAction: true }; const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); const storedPasswordHash = credentials[username]; if (!storedPasswordHash) return { success: false, error: "Invalid username or password." }; try { const enteredPasswordHash = await Utils.hashPassword(password); if (storedPasswordHash === enteredPasswordHash) { if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username && (!CommandExecutor || !CommandExecutor.isDiagActive())) SessionManager.saveAutomaticState(currentUser.name); currentUser = { name: username, credentials }; HistoryManager.clearHistory(); await FileSystemManager.load(username); await AliasManager.load(username); if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.loadAutomaticState(username); TerminalUI.updatePrompt(); return { success: true, message: `Logged in as ${username}.` }; } else return { success: false, error: "Invalid username or password." }; } catch (error) { return { success: false, error: `Login failed: ${error.message}` }; } } async function logout() { if (currentUser.name === Config.USER.DEFAULT_NAME) return { success: true, message: "Already logged in as Guest. No action taken.", noAction: true }; if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.saveAutomaticState(currentUser.name); const prevUserName = currentUser.name; currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; HistoryManager.clearHistory(); await FileSystemManager.load(Config.USER.DEFAULT_NAME); await AliasManager.load(Config.USER.DEFAULT_NAME); if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME); TerminalUI.updatePrompt(); return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` }; } function setCurrentUserObject(userObject) { currentUser = userObject; } function getDefaultUser() { return Config.USER.DEFAULT_NAME; } return { getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser }; })();
        const SessionManager = (() => { function getAutomaticSessionStateKey(user) { return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`; } function getManualUserTerminalStateKey(user) { return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${user.name || user}`; } function saveAutomaticState(username) { const currentInput = TerminalUI.isPasswordInputActiveState() ? '' : TerminalUI.getCurrentInputValue(); const autoState = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, commandHistory: HistoryManager.getFullHistory() }; StorageManager.saveJSON(getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`); } function loadAutomaticState(username) { const autoState = StorageManager.loadJSON(getAutomaticSessionStateKey(username), `Auto session for ${username}`); const isDiag = CommandExecutor && CommandExecutor.isDiagActive(); if (autoState) { FileSystemManager.setCurrentPath(autoState.currentPath || '/'); if (!isDiag && autoState.hasOwnProperty('outputHTML')) DOM.outputDiv.innerHTML = autoState.outputHTML || ''; else if (!isDiag && !autoState.hasOwnProperty('outputHTML')) if(!isDiag) DOM.outputDiv.innerHTML = ''; TerminalUI.setCurrentInputValue(autoState.currentInput || ''); HistoryManager.setHistory(autoState.commandHistory || []); } else { if (!isDiag) DOM.outputDiv.innerHTML = ''; TerminalUI.setCurrentInputValue(''); FileSystemManager.setCurrentPath('/'); HistoryManager.clearHistory(); if (!isDiag) OutputManager.appendToOutput(`Welcome, ${username}! Type 'help' for commands.`, { isInstant: true }); }  TerminalUI.updatePrompt(); if (!isDiag) DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; return !!autoState; } async function saveManualState() { const currentUser = UserManager.getCurrentUser(); const currentInput = TerminalUI.isPasswordInputActiveState() ? '' : TerminalUI.getCurrentInputValue(); const pendingData = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()), commandHistory: HistoryManager.getFullHistory() }; if (StorageManager.saveJSON(getManualUserTerminalStateKey(currentUser), pendingData, `Manual save for ${currentUser.name}`)) return { success: true, message: `Session manually saved for ${currentUser.name}.` }; return { success: false, error: "Failed to save session." }; } async function loadManualState() { const currentUser = UserManager.getCurrentUser(); const pendingData = StorageManager.loadJSON(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`); if (pendingData) { ConfirmationManager.request( ["Load manually saved state? This overwrites current session & filesystem."], { pendingData: pendingData, userName: currentUser.name }, async (data) => { FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { '/': { type: 'directory', children: {} } }); FileSystemManager.setCurrentPath(data.pendingData.currentPath || '/'); DOM.outputDiv.innerHTML = data.pendingData.outputHTML || ''; TerminalUI.setCurrentInputValue(data.pendingData.currentInput || ''); HistoryManager.setHistory(data.pendingData.commandHistory || []); await FileSystemManager.save(data.userName); OutputManager.appendToOutput("Session loaded from manual save.", { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }, () => { OutputManager.appendToOutput("Load state cancelled.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); } ); return { success: true, message: "Confirmation requested for loading state." }; } else return { success: false, message: `No manually saved state found for ${currentUser.name}.` }; } async function performFullReset() { OutputManager.clearOutput(); TerminalUI.clearInput(); const keysToRemove = []; const allKeys = StorageManager.getAllLocalStorageKeys(); allKeys.forEach(key => { if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) || key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) || key === Config.STORAGE_KEYS.USER_CREDENTIALS) keysToRemove.push(key); }); keysToRemove.forEach(key => StorageManager.removeItem(key)); await OutputManager.appendToOutput("All session states and credentials cleared from local storage.", { isInstant: true }); try { await FileSystemManager.clearAllFS(); await OutputManager.appendToOutput("All user filesystems cleared from DB.", { isInstant: true }); } catch (error) { /* Handled by FSManager */ } HistoryManager.clearHistory(); const guestUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; UserManager.setCurrentUserObject(guestUser); await FileSystemManager.initialize(Config.USER.DEFAULT_NAME); await AliasManager.load(Config.USER.DEFAULT_NAME); loadAutomaticState(Config.USER.DEFAULT_NAME); await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); TerminalUI.updatePrompt(); } return { saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset }; })();

        // --- TERMINAL UI MODULE (REFACTORED FOR CONTENTEDITABLE) ---
        const TerminalUI = (() => {
            let isNavigatingHistory = false;
            let currentPasswordPromptContext = null; 

            function updatePrompt() {
                const user = UserManager.getCurrentUser();
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.NAME;
                DOM.promptPathSpan.textContent = FileSystemManager.getCurrentPath().trim() === '' ? '/' : FileSystemManager.getCurrentPath();
            }

            function focusInput() {
                const passwordField = document.getElementById('password-input-field');
                if (passwordField && passwordField.style.display !== 'none') {
                    passwordField.focus();
                } else if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.focus();
                    if (DOM.editableInputDiv.textContent.length === 0) {
                        setCaretToEnd(DOM.editableInputDiv);
                    }
                }
            }

            function clearInput() {
                if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = '';
                const passField = document.getElementById('password-input-field');
                if (passField) passField.value = '';
            }
            
            function getCurrentInputValue() {
                const passField = document.getElementById('password-input-field');
                if (passField && passField.style.display !== 'none') return passField.value;
                return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : '';
            }

            function setCurrentInputValue(value, setAtEnd = true) {
                const passField = document.getElementById('password-input-field');
                if (passField && passField.style.display !== 'none') {
                    // Not setting password field from history for now
                } else if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.textContent = value;
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv);
                }
            }
            
            function setCaretToEnd(element) {
                if (!element) return;
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(element);
                range.collapse(false); 
                sel.removeAllRanges();
                sel.addRange(range);
            }

            function switchToPasswordInput(promptContext) {
                currentPasswordPromptContext = promptContext;
                DOM.editableInputDiv.style.display = 'none';
                
                let passField = document.getElementById('password-input-field');
                if (!passField) {
                    passField = document.createElement('input');
                    passField.type = 'password';
                    passField.id = 'password-input-field';
                    DOM.editableInputContainerDiv.appendChild(passField);
                }
                passField.style.display = 'block';
                passField.value = '';
                passField.focus();
            }

            function switchToEditableInput() {
                const passField = document.getElementById('password-input-field');
                if (passField) {
                    passField.style.display = 'none';
                }
                DOM.editableInputDiv.style.display = 'block'; 
                currentPasswordPromptContext = null;
                focusInput(); 
            }
            
            function isPasswordInputActiveState() { 
                return !!currentPasswordPromptContext;
            }

            function getPasswordContext() {
                return currentPasswordPromptContext;
            }

            return { 
                updatePrompt, focusInput, clearInput, 
                setCurrentInputValue, getCurrentInputValue,
                isPasswordInputActiveState, getPasswordContext,
                switchToPasswordInput, switchToEditableInput,
                setCaretToEnd,
                setIsNavigatingHistory: (status) => { isNavigatingHistory = status; }, 
                getIsNavigatingHistory: () => isNavigatingHistory
            };
        })();
        
        // --- COMMAND EXECUTOR MODULE ---
        const CommandExecutor = (() => {
            let lastCommandFailed = false; 
            let isDiagActive = false; 
            
            const commandHelpData = { 
                'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms unless forced).', syntax: 'rm [-f] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation. The -f or --force option bypasses confirmation (used internally by scripts). The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
                'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
                'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
                'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
                'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { usage: 'register <username> [password]', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME [PASSWORD]', details: 'Registers a new user. If PASSWORD is not provided, you will be prompted for it. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage.', examples: ['register myuser', 'register newuser strongpass123']},
                'login': { usage: 'login <username> [password]', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME [PASSWORD]', details: 'Logs in as the specified USERNAME. If PASSWORD is not provided, you will be prompted for it. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser', 'login anotheruser mysecretpass']},
                'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
                'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
                'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving, Ctrl+P to toggle preview for MD/HTML.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
                'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
                'head': { usage: 'head [-n N] <filename>', summary: 'Displays the beginning of a file.', syntax: 'head [-n N] FILE', details: 'Prints the first N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt']},
                'tail': { usage: 'tail [-n N] <filename>', summary: 'Displays the end of a file.', syntax: 'tail [-n N] FILE', details: 'Prints the last N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt']},
                'export': { usage: 'export <path/to/filename>', summary: 'Exports a file to your local disk.', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log']},
                'backup': { usage: 'backup', summary: 'Backs up current user session to a local file.', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup']},
                'import': { usage: 'import', summary: 'Imports a user session from a local backup file.', syntax: 'import', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['import']},
                'wc': {  usage: 'wc [-l] [-w] [-c] <filename>', summary: 'Counts lines, words, and bytes in a file.', syntax: 'wc [OPTION]... [FILE]', details: 'Prints newline, word, and byte counts for the specified FILE. A word is a non-zero-length sequence of characters delimited by white space. With no OPTION, prints all three counts.\n  -c, --bytes         print the byte counts\n  -l, --lines         print the newline counts\n  -w, --words         print the word counts', examples: ['wc myfile.txt', 'wc -l story.txt', 'wc -w -c report.doc', 'wc -lwc data.csv']},
                'diff': { usage: 'diff <file1> <file2>', summary: 'Compares two files line by line.', syntax: 'diff FILE1 FILE2', details: 'Compares FILE1 and FILE2 line by line and outputs the differences. Common lines are prefixed with two spaces. Lines unique to FILE1 are prefixed with "< ". Lines unique to FILE2 are prefixed with "> ".', examples: ['diff old_version.txt new_version.txt', 'diff /config/main.conf /config/backup.conf']},
                'history': { usage: 'history', summary: 'Displays the command history.', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history']},
                'alias': { usage: 'alias [name[=value] ...]', summary: 'Define or display aliases.', syntax: 'alias [NAME[=VALUE]...]', details: '`alias` with no arguments prints the list of aliases in the form `name=\'value\'`.\n`alias name` prints the alias for `name`.\n`alias name=value` defines an alias. `value` can be a string containing commands. If `value` contains spaces, it should be quoted.\n`alias name=` unsets the alias `name`.', examples: ['alias', 'alias ll', "alias ll='ls -alF'", "alias mydocs='cd /home/user/documents'", "alias lsl="]},
                'unalias': { usage: 'unalias <name>', summary: 'Remove an alias.', syntax: 'unalias NAME', details: 'Removes the alias specified by NAME from the current user\'s alias list.', examples: ['unalias ll']}
            };
            
            // --- ALL COMMAND HANDLERS DEFINED HERE (BEFORE commandRegistry) ---
            async function handleLs(args) { const targetPathArg = args[0]; const validation = FileSystemManager.validatePath("ls", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true }); if (validation.error) return { success: false, error: validation.error }; const childrenNames = Object.keys(validation.node.children).sort(); if (childrenNames.length === 0) return { success: true, output: "Directory is empty." }; let outputLines = []; childrenNames.forEach(name => { const childNode = validation.node.children[name]; let line = name; if (childNode.type === 'directory') line += '/'; outputLines.push(line); }); return { success: true, output: outputLines.join('\n') }; }
            async function handleCd(args) { const targetPathArg = args[0]; if (targetPathArg === undefined) return { success: false, error: "cd: missing operand\nUsage: cd <directory>" }; const validation = FileSystemManager.validatePath("cd", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; if (validation.resolvedPath === FileSystemManager.getCurrentPath()) return { success: true, output: `Already in '${validation.resolvedPath}'.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; FileSystemManager.setCurrentPath(validation.resolvedPath); TerminalUI.updatePrompt(); return { success: true, output: null }; }
            async function handleMkdir(args) { const fullPathArg = args[0]; if (!fullPathArg) return { success: false, error: "mkdir: missing operand\nUsage: mkdir <directory_name>" }; if (fullPathArg === '.' || fullPathArg === '..') return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` }; const validation = FileSystemManager.validatePath("mkdir", fullPathArg, { allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error && validation.node && validation.node.type === 'file') return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` }; if (validation.error && validation.resolvedPath === '/') return { success: false, error: validation.error }; if (validation.error && !validation.node && !validation.allowMissing) return { success: false, error: validation.error }; const targetAbsPath = validation.resolvedPath; if (validation.node && validation.node.type === 'directory') return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.` , messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG}; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}'` }; const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` }; parentNode.children[dirToCreateName] = { type: 'directory', children: {} }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` }; return { success: true, output: `Directory '${fullPathArg}' created.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; }
            async function handleTouch(args) { const fullPathArg = args[0]; if (!fullPathArg) return { success: false, error: "touch: missing file operand\nUsage: touch <filename>" }; if (fullPathArg.endsWith('/')) return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` }; const validation = FileSystemManager.validatePath("touch", fullPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const targetAbsPath = validation.resolvedPath; if (validation.node) return { success: true, output: `Timestamp of '${fullPathArg}' updated.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}'`}; const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); parentNode.children[newFileName] = { type: 'file', content: "" }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` }; return { success: true, output: `File '${fullPathArg}' created.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; }
            async function handleCat(args) { const targetPathArg = args[0]; if (!targetPathArg) return { success: false, error: "cat: missing file operand\nUsage: cat <filename>" }; const validation = FileSystemManager.validatePath("cat", targetPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; return { success: true, output: validation.node.content }; }
            async function handleEcho(args) { let outputString = args.join(' '); if (outputString.length >= 2) { const firstChar = outputString[0], lastChar = outputString[outputString.length - 1]; if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) outputString = outputString.substring(1, outputString.length - 1); } return { success: true, output: outputString }; }
            async function handleMv(args) { if (args.length < 2) return { success: false, error: "mv: missing source and/or destination operands" }; const sourcePathArg = args[0], destPathArg = args[1]; const sourceValidation = FileSystemManager.validatePath("mv", sourcePathArg, {disallowRoot: true, defaultToCurrentIfEmpty: false}); if (sourceValidation.error) return { success: false, error: sourceValidation.error }; const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation; const destValidation = FileSystemManager.validatePath("mv", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false }); if (destValidation.node && destValidation.node.type === 'file') return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` }; if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) return { success: false, error: destValidation.error }; let absDestPath = destValidation.resolvedPath; const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/'; const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1); const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath); if (!sourceParentNode || !sourceParentNode.children || !sourceParentNode.children[sourceName]) return { success: false, error: `mv: internal error: source '${sourceName}' not found in parent '${sourceParentPath}'` }; let finalDestParentNode, finalDestName; if (destValidation.node && destValidation.node.type === 'directory') { finalDestParentNode = destValidation.node; finalDestName = sourceName; absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath); } else { const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath); if(parentDirResult.error) return { success: false, error: `mv: ${parentDirResult.error}` }; finalDestParentNode = parentDirResult.parentNode; if (!finalDestParentNode) return { success: false, error: `mv: could not obtain parent for '${absDestPath}'`}; finalDestName = absDestPath.substring(absDestPath.lastIndexOf('/') + 1); } if (!finalDestName || finalDestName === "." || finalDestName === "..") return { success: false, error: `mv: invalid destination name '${finalDestName}'` }; if (absSourcePath === absDestPath) return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; if (finalDestParentNode.children[finalDestName]) return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destValidation.node ? destPathArg : absDestPath.substring(0, absDestPath.lastIndexOf('/')) || '/' }'.` }; if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one ofits subdirectories ('${destPathArg}')` }; finalDestParentNode.children[finalDestName] = sourceNode; delete sourceParentNode.children[sourceName]; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: "mv: failed to save filesystem changes." }; return { success: true, output: `Moved '${sourcePathArg}' to '${destPathArg}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; }
            async function handleCp(args) { if (args.length < 2) return { success: false, error: "cp: missing source and/or destination operands" }; const sourcePathArg = args[0], destPathArg = args[1]; const sourceValidation = FileSystemManager.validatePath("cp", sourcePathArg, {disallowRoot: false, defaultToCurrentIfEmpty: false}); if (sourceValidation.error) return { success: false, error: sourceValidation.error }; const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation; const destValidation = FileSystemManager.validatePath("cp", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false }); if (destValidation.node && destValidation.node.type === 'file') return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` }; if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) return { success: false, error: destValidation.error }; let absDestPath = destValidation.resolvedPath; const sourceName = absSourcePath === '/' ? 'root_copy' : absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1); let finalDestParentNode, finalDestName; if (destValidation.node && destValidation.node.type === 'directory') { finalDestParentNode = destValidation.node; finalDestName = sourceName; absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath); } else { const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath); if(parentDirResult.error) return { success: false, error: `cp: ${parentDirResult.error}` }; finalDestParentNode = parentDirResult.parentNode; if (!finalDestParentNode) return { success: false, error: `cp: could not obtain parent for '${absDestPath}'`}; finalDestName = absDestPath.substring(absDestPath.lastIndexOf('/') + 1); } if (!finalDestName || finalDestName === "." || finalDestName === "..") return { success: false, error: `cp: invalid destination name '${finalDestName}'` }; if (finalDestParentNode.children[finalDestName]) return { success: false, error: `cp: destination '${finalDestName}' already exists.` }; if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) return { success: false, error: `cp: cannot copy a directory into itself or one of its subdirectories.` }; const copiedNode = Utils.deepCopyNode(sourceNode); if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` }; finalDestParentNode.children[finalDestName] = copiedNode; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: "cp: failed to save filesystem changes." }; return { success: true, output: `Copied '${sourcePathArg}' to '${destPathArg}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; }
            async function handleRm(args, cmdOptions = {}) { const { force = false } = cmdOptions; let targetPathArg = args[0]; let effectiveForce = force; const remainingArgs = [...args]; let pathArgForValidation = targetPathArg; const forceFlagIndex = remainingArgs.findIndex(arg => arg === '-f' || arg === '--force'); if (forceFlagIndex !== -1) { effectiveForce = true; remainingArgs.splice(forceFlagIndex, 1); pathArgForValidation = remainingArgs[0]; } if (!pathArgForValidation) return { success: false, error: "rm: missing operand\nUsage: rm [-f] <file_or_directory>" }; const validation = FileSystemManager.validatePath("rm", pathArgForValidation, { disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) { if (effectiveForce && validation.error.includes("No such file or directory")) return { success: true, output: null }; return { success: false, error: validation.error }; } const itemType = validation.node.type === 'directory' ? 'directory' : 'file'; const dataForConfirm = { path: validation.resolvedPath, arg: pathArgForValidation, userName: UserManager.getCurrentUser().name }; if (effectiveForce) { const parentPath = dataForConfirm.path.substring(0, dataForConfirm.path.lastIndexOf('/')) || '/'; const itemName = dataForConfirm.path.substring(dataForConfirm.path.lastIndexOf('/') + 1); const parentNode = FileSystemManager.getNodeByPath(parentPath); if (parentNode && parentNode.children && parentNode.children[itemName]) { delete parentNode.children[itemName]; if(!await FileSystemManager.save(dataForConfirm.userName)) return { success: false, error: `Error saving filesystem after force removing '${dataForConfirm.path}'.` }; else return { success: true, output: `Forcibly removed '${pathArgForValidation}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } else return { success: false, error: `Error force removing '${dataForConfirm.path}': Item not found or parent changed.` }; } else { ConfirmationManager.request( [`Are you sure you want to remove ${itemType} '${pathArgForValidation}'? This action cannot be undone.`], dataForConfirm, async (data) => { const parentPath = data.path.substring(0, data.path.lastIndexOf('/')) || '/'; const itemName = data.path.substring(data.path.lastIndexOf('/') + 1); const parentNode = FileSystemManager.getNodeByPath(parentPath); if (parentNode && parentNode.children && parentNode.children[itemName]) { delete parentNode.children[itemName]; if(!await FileSystemManager.save(data.userName)) await OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'.`, { isInstant: true, isError: true }); else await OutputManager.appendToOutput(`'${data.path}' removed.`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); } else await OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, { isInstant: true, isError: true }); }, (data) => { OutputManager.appendToOutput(`Removal of '${data.arg || 'item'}' cancelled.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); } ); return { success: true, output: null }; } }
            async function handlePwd(args) { return { success: true, output: FileSystemManager.getCurrentPath() };}
            async function handleDate(args) { return { success: true, output: new Date().toString() };}
            async function handleWhoami(args) { return { success: true, output: UserManager.getCurrentUser().name };}
            async function handleGrep(args) { if (args.length < 2) return { success: false, error: "grep: usage: grep PATTERN FILE" }; const filePathArg = args[args.length - 1]; let pattern = args.slice(0, args.length - 1).join(' '); if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) pattern = pattern.substring(1, pattern.length - 1); if (!pattern) return { success: false, error: "grep: pattern cannot be empty" }; const validation = FileSystemManager.validatePath("grep", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || ""; const lines = fileContent.split('\n'); const matchingLines = lines.filter(line => line.includes(pattern)); return { success: true, output: matchingLines.length > 0 ? matchingLines.join('\n') : "" }; }
            async function handleRun(args) { const scriptPathArg = args[0]; if (!scriptPathArg) return { success: false, error: "run: missing script file operand" }; const validation = FileSystemManager.validatePath("run", scriptPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const scriptContent = validation.node.content || ""; const scriptLines = scriptContent.split('\n'); await OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); (async () => { for (let i = 0; i < scriptLines.length; i++) { const line = scriptLines[i], trimmedLine = line.trim(); if (trimmedLine === '' || trimmedLine.startsWith('#')) continue; const cmdResult = await processSingleCommand(trimmedLine, false); if (!cmdResult.success) { await OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, { isError: true }); if (cmdResult.error) await OutputManager.appendToOutput(cmdResult.error, { isError: true }); return; } } await OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); })(); return { success: true, output: null }; }
            async function handleSysmon(args) { const currentUser = UserManager.getCurrentUser(); const output = [ "** OopisOs System Monitor v6.9 - Sub-Etha Edition **", "----------------------------------------------------", `Registered User:    ${currentUser.name} (Probably you, unless you stole this login!)`, `OopisOs Version:    ${Config.OS.VERSION}`, "", "==[ MAIN PROCESSOR UNIT (MPU) ]==", `  Type:             QualmCore 9001 (Modular Edition)`, `  Architecture:     Mostly Wishful Thinking with a Dash of RISC-y Business`, `  Conceptual Cores: 1 (It's trying its best, okay?)`, `  Clock Speed:      ~1 OopoHertz (Can reach 5 on a good day, with a tailwind)`, "", "==[ RANDOM ACCESS MUD (RAM) ]==",  `  Type:             DJHAR (Don't Jiggle; Highly Agitated Ram)`, `  Capacity:         640 KiloSegs (Should be enough for anyone, right?)`,  `  Current Load:     Probably too high. Did you try turning it off and on again?`, "", "==[ STORAGE (Probably Borrowed) ]==", `  Primary Drive:    The ol' IndexedDB Drive (Capacity: Browser's Whim)`, `  Space Used:       Enough to make you question your life choices.`, `  Space Free:       Less than you'd hope. Consider deleting 'that' folder.`, "", "==[ VISUAL DISPLAY UNIT (VDU) ]==", `  Model:            GreenScreen Deluxe (Now with 50 shades of green!)`, `  Resolution:       Optimistically Text-Mode`, `  Burn-in Status:   Impressive. You've been at this a while, huh?`, "----------------------------------------------------", "System Status:      'Nominally Operational'. (Whatever that means.)" ]; let styledOutput = ""; output.forEach(line => { const parts = line.split(':'); if (parts.length > 1 && line.trim().startsWith(parts[0].trim()))  styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.SYSMON_LABEL}">${parts[0].padEnd(20, ' ')}:</span><span>${parts.slice(1).join(':').trim()}</span></div>`; else styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">${line}</div>`; }); OutputManager.appendHtmlToOutput(styledOutput); return { success: true, output: null, isHtmlOutput: true }; }
            async function handleSort(args) { const filePathArg = args[0]; if (!filePathArg) return { success: false, error: "sort: missing file operand" }; const validation = FileSystemManager.validatePath("sort", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || ""; if (fileContent.trim() === "") return { success: true, output: "" }; const lines = fileContent.split('\n'); lines.sort(); return { success: true, output: lines.join('\n') }; }
            async function handleClear() { OutputManager.clearOutput(); return { success: true, output: null }; }
            async function handleSavestate() { const result = await SessionManager.saveManualState(); if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error || "Failed to save state." }; }
            async function handleLoadstate() { const result = await SessionManager.loadManualState(); return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG }; }
            async function handleReset() { ConfirmationManager.request( ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."], null, async () => { await SessionManager.performFullReset(); }, () => { OutputManager.appendToOutput("Reset cancelled.", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); } ); return { success: true, output: null }; }
            async function handleRegisterCmd(args) {
                if (args.length === 1 && args[0]) { 
                    await OutputManager.appendToOutput(`Password for ${args[0]}: `, { isInstant: true });
                    TerminalUI.switchToPasswordInput({ commandName: 'register', username: args[0] });
                    return { success: true, output: null, awaitingPassword: true }; 
                } else if (args.length >= 2) { 
                    const [username, password] = args;
                    const result = await UserManager.register(username, password);
                    TerminalUI.switchToEditableInput(); 
                    if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    else return { success: false, error: result.error };
                } else {
                    return { success: false, error: "Usage: register <username> [password]" };
                }
            }
            async function handleLoginCmd(args) {
                if (args.length === 1 && args[0]) { 
                    await OutputManager.appendToOutput(`Password for ${args[0]}: `, { isInstant: true });
                    TerminalUI.switchToPasswordInput({ commandName: 'login', username: args[0] });
                    return { success: true, output: null, awaitingPassword: true }; 
                } else if (args.length >= 2) { 
                    const [username, password] = args;
                    const result = await UserManager.login(username, password);
                     TerminalUI.switchToEditableInput(); 
                    if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                    else return { success: false, error: result.error };
                } else {
                    return { success: false, error: "Usage: login <username> [password]" };
                }
            }
            async function handleLogoutCmd() { const result = await UserManager.logout(); if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error || "Logout failed." }; }
            async function handleHelp(args) { let outputLines = []; if (!args.length) { outputLines.push("Available commands (type 'help <command>' or 'man <command>'):"); const commandNames = Object.keys(commandRegistry).sort(); commandNames.forEach(cmdName => { const summary = commandHelpData[cmdName]?.summary || 'No summary available.'; outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`); }); } else { const commandName = args[0].toLowerCase(); const helpInfo = commandHelpData[commandName]; if (helpInfo) { outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`); outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`); outputLines.push(`  For more details, type: man ${commandName}`); } else return { success: false, error: `No help available for '${commandName}'. Try 'man ${commandName}'.` }; } return { success: true, output: outputLines.join('\n') }; }
            async function handleMan(args) { function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");} if (args.length === 0) return { success: true, output: "What manual page do you want? (e.g., man ls)", messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; const commandName = args[0].toLowerCase(); const manData = commandHelpData[commandName]; if (manData) { let manOutputHtmlLines = []; manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">NAME</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">SYNOPSIS</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">DESCRIPTION</span></div>`); const detailLines = (manData.details || 'No detailed description available.').split('\n'); detailLines.forEach(line => { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`); }); if (manData.examples && manData.examples.length > 0) { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">EXAMPLES</span></div>`); manData.examples.forEach(example => { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">        <span class="${Config.CSS_CLASSES.MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`); }); } manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); OutputManager.appendHtmlToOutput(manOutputHtmlLines.join('')); return { success: true, output: null, isHtmlOutput: true }; } else return { success: false, error: `No manual entry for ${commandName}` }; }
            async function handleEditCmd(args) { if (EditorManager.isActive()) return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MESSAGE }; const targetPathArg = args[0]; if (!targetPathArg) return { success: false, error: "edit: missing file operand" }; if (targetPathArg.endsWith('/')) return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` }; const validation = FileSystemManager.validatePath("edit", targetPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const content = validation.node ? validation.node.content : ""; EditorManager.enter(validation.resolvedPath, content); return { success: true, output: null }; }
            async function handleDiag(args) { isDiagActive = true; OutputManager.setDiagRunning(true); let passCount = 0, failCount = 0; window.diagInitializedForOutput = false; const originalCurrentUser = UserManager.getCurrentUser(); const originalFsData = Utils.deepCopyNode(FileSystemManager.getFsData()); const originalCurrentPath = FileSystemManager.getCurrentPath(); const originalUserCredentials = Utils.deepCopyNode(StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {})); const originalOutputHTML = DOM.outputDiv.innerHTML; const originalCommandHistory = HistoryManager.getFullHistory(); const diagPrint = async (message, typeClass = Config.CSS_CLASSES.DIAG_OUTPUT) => { await OutputManager.appendToOutput(message, { isInstant: true, typeClass: typeClass }); }; const report = async (testName, success, details = "", expected = null, actual = null) => { let detailStr = details; if (!success && expected !== null && actual !== null) { detailStr += ` (Expected: <${expected}>, Got: <${actual}>)`; } if (success) passCount++; else failCount++; await diagPrint(`  ${success ? 'PASS' : 'FAIL'}: ${testName}${detailStr ? ` - ${detailStr}` : ''}`); return success; }; const createTestFile = async (filePath, content) => { const escapedContent = content.replace(/"/g, '\\"'); const echoResult = await processSingleCommand(`echo "${escapedContent}" > ${filePath}`, false); if (!echoResult.success) { await diagPrint(`  WARN: Failed to create test file ${filePath} for diag. Error: ${echoResult.error || 'Unknown error'}`); } }; OutputManager.clearOutput(); await diagPrint("Starting OopisOs Diagnostics...", Config.CSS_CLASSES.DIAG_SECTION); await diagPrint("-------------------------------"); try { await IndexedDBManager.init(); } catch (e) { await diagPrint("  CRITICAL: Diag cannot proceed, IndexedDB init failed."); isDiagActive = false; OutputManager.setDiagRunning(false); return {success: false, error: "Diag DB init failed"}; } const fsTestUser = "__diag_cmd_user__"; const fsTestBaseDir = "/tmp/__diag_cmd_tests__"; const diagUserPass = "diagTestPass123"; let loginResult = await UserManager.login(fsTestUser, diagUserPass); if (!loginResult.success || loginResult.error === "Invalid username or password.") { await UserManager.register(fsTestUser, diagUserPass); loginResult = await UserManager.login(fsTestUser, diagUserPass); } if (!loginResult.success) { await diagPrint("  CRITICAL: Diag user setup failed."); isDiagActive = false; OutputManager.setDiagRunning(false); return { success: false, error: "Diag user setup failed." }; } await processSingleCommand(`rm ${fsTestBaseDir}`, false); await processSingleCommand(`mkdir ${fsTestBaseDir}`, false); await processSingleCommand(`cd ${fsTestBaseDir}`, false); await diagPrint("\nSECTION: Filesystem Path & Node Tests", Config.CSS_CLASSES.DIAG_SECTION); const pathTests = [ { name: "Current dir at root", target: '.', base: '/', expected: '/' }, { name: "Parent dir at root", target: '..', base: '/', expected: '/' }, { name: "Simple relative from root", target: 'foo', base: '/', expected: '/foo' }, { name: "Absolute target, ignore base", target: '/foo/bar', base: '/baz', expected: '/foo/bar' }, { name: "Relative .. from /foo/baz", target: '../bar', base: '/foo/baz', expected: '/foo/bar' }, { name: "Relative ../../ to root", target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar' }, { name: "Empty target (current dir)", target: '', base: '/foo', expected: '/foo' }, { name: "Trailing slash", target: 'dir/', base: '/foo', expected: '/foo/dir' }, { name: "Multiple slashes", target: '//a//b/', base: '/', expected: '/a/b' }  ]; for (const tc of pathTests) { const actual = FileSystemManager.getAbsolutePath(tc.target, tc.base); await report(tc.name, actual === tc.expected, "", String(tc.expected), String(actual)); } await createTestFile("testfile.txt", "content"); let node = FileSystemManager.getNodeByPath("testfile.txt"); await report("getNodeByPath existing file", node && node.type === 'file' && node.content === "content"); node = FileSystemManager.getNodeByPath("nonexistent.txt"); await report("getNodeByPath non-existent", node === null); let validation = FileSystemManager.validatePath("testcmd", "testfile.txt", {expectedType: 'file'}); await report("validatePath existing file", validation.error === null && validation.node !== null); validation = FileSystemManager.validatePath("testcmd", "testfile.txt", {expectedType: 'directory'}); await report("validatePath existing file as dir", validation.error !== null); validation = FileSystemManager.validatePath("testcmd", "newdir", {allowMissing: true}); await report("validatePath non-existent allowMissing", validation.error === null && validation.node === null); await diagPrint("\nSECTION: Alias Tests", Config.CSS_CLASSES.DIAG_SECTION); await processSingleCommand("alias myls='ls -l'", false); await report("Alias creation", AliasManager.hasAlias("myls") && AliasManager.getAliases()["myls"] === "ls -l", "", "ls -l", AliasManager.getAliases()["myls"]); let expanded = await AliasManager.expand("myls /some/path"); await report("Alias expansion", expanded === "ls -l /some/path", "", "ls -l /some/path", expanded); await processSingleCommand("unalias myls", false); await report("Alias deletion", !AliasManager.hasAlias("myls")); await diagPrint("\nSECTION: Redirection Tests", Config.CSS_CLASSES.DIAG_SECTION); await processSingleCommand("echo 'redirect test' > redir.txt", false); node = FileSystemManager.getNodeByPath("redir.txt"); await report("Redirection overwrite (>)", node && node.content === "redirect test", "", "redirect test", node ? node.content : "null"); await processSingleCommand("echo 'append test' >> redir.txt", false); node = FileSystemManager.getNodeByPath("redir.txt"); await report("Redirection append (>>)", node && node.content === "redirect test\nappend test", "", "redirect test\nappend test", node ? node.content : "null"); await diagPrint("\nSECTION: File Content Commands (wc, head, tail, diff)", Config.CSS_CLASSES.DIAG_SECTION); const wcFile = "wc_test.txt", wcContent = "one two three\nfour five\n\nsix seven eight nine ten"; await createTestFile(wcFile, wcContent); let elWcDef = 4, elWcL = 3, ew = 10, eb = wcContent.length;  let wcRes = await processSingleCommand(`wc ${wcFile}`, false); await report("wc default", wcRes.success && wcRes.output && wcRes.output.trim() === `${String(elWcDef).padStart(7)} ${String(ew).padStart(7)} ${String(eb).padStart(7)} ${wcFile}`.trim(), "", `${String(elWcDef).padStart(7)} ${String(ew).padStart(7)} ${String(eb).padStart(7)} ${wcFile}`.trim(), wcRes.output ? wcRes.output.trim() : 'null'); wcRes = await processSingleCommand(`wc -l ${wcFile}`, false); await report("wc -l", wcRes.success && wcRes.output && wcRes.output.trim() === `${String(elWcL).padStart(7)} ${wcFile}`.trim(), "", `${String(elWcL).padStart(7)} ${wcFile}`.trim(), wcRes.output ? wcRes.output.trim() : 'null'); const headTailContent = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\nLine 11\nLine 12"; await createTestFile("ht_file.txt", headTailContent); await createTestFile("empty_file.txt", ""); let htRes = await processSingleCommand("head ht_file.txt", false); await report("head default (10 lines)", htRes.success && htRes.output === headTailContent.split('\n').slice(0,10).join('\n')); htRes = await processSingleCommand("head -n 3 ht_file.txt", false); await report("head -n 3", htRes.success && htRes.output === "Line 1\nLine 2\nLine 3"); htRes = await processSingleCommand("head -n 15 ht_file.txt", false); await report("head -n 15 (more than lines)", htRes.success && htRes.output === headTailContent); htRes = await processSingleCommand("head empty_file.txt", false); await report("head empty file", htRes.success && htRes.output === ""); htRes = await processSingleCommand("tail ht_file.txt", false); await report("tail default (10 lines)", htRes.success && htRes.output === headTailContent.split('\n').slice(2).join('\n')); htRes = await processSingleCommand("tail -n 3 ht_file.txt", false); await report("tail -n 3", htRes.success && htRes.output === "Line 10\nLine 11\nLine 12"); htRes = await processSingleCommand("tail -n 15 ht_file.txt", false); await report("tail -n 15 (more than lines)", htRes.success && htRes.output === headTailContent); htRes = await processSingleCommand("tail empty_file.txt", false); await report("tail empty file", htRes.success && htRes.output === ""); await createTestFile("diff1.txt", "apple\nbanana\ncherry"); await createTestFile("diff2.txt", "apple\nbanana\ncherry"); await createTestFile("diff3.txt", "apple\ndate\nbanana\ncherry"); await createTestFile("diff4.txt", "apple\ncherry"); await createTestFile("diff5.txt", "apple\nblueberry\ncherry"); let diffRes = await processSingleCommand("diff diff1.txt diff2.txt", false); await report("diff identical", diffRes.success && diffRes.output === ""); diffRes = await processSingleCommand("diff diff1.txt diff3.txt", false); await report("diff addition in file2", diffRes.success && diffRes.output === "> date", "", "> date", diffRes.output); diffRes = await processSingleCommand("diff diff1.txt diff4.txt", false); await report("diff deletion in file2 (seen as removed from file1)", diffRes.success && diffRes.output === "< banana", "", "< banana", diffRes.output); diffRes = await processSingleCommand("diff diff1.txt diff5.txt", false); await report("diff changed line", diffRes.success && diffRes.output === "< banana\n> blueberry", "", "< banana\n> blueberry", diffRes.output); await processSingleCommand(`cd /tmp`, false); await processSingleCommand(`rm ${fsTestBaseDir.substring(fsTestBaseDir.lastIndexOf('/') + 1)}`, false); UserManager.setCurrentUserObject(originalCurrentUser); StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, originalUserCredentials, "User creds"); FileSystemManager.setFsData(originalFsData); await FileSystemManager.save(originalCurrentUser.name); FileSystemManager.setCurrentPath(originalCurrentPath); await AliasManager.load(originalCurrentUser.name); await diagPrint("\n-------------------------------"); await diagPrint(`Diagnostics Complete: ${passCount} PASSED, ${failCount} FAILED.`); await diagPrint("-------------------------------"); const finalDiagReportHTML = DOM.outputDiv.innerHTML; DOM.outputDiv.innerHTML = originalOutputHTML; const diagReportContainer = document.createElement('div'); diagReportContainer.innerHTML = finalDiagReportHTML; DOM.outputDiv.appendChild(diagReportContainer); HistoryManager.setHistory(originalCommandHistory); TerminalUI.updatePrompt(); TerminalUI.focusInput(); setTimeout(() => { DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }, 50); isDiagActive = false; OutputManager.setDiagRunning(false); window.diagInitializedForOutput = false; return { success: true, output: null }; }
            async function handleTree(args) { const targetPathArg = args[0]; const validation = FileSystemManager.validatePath("tree", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true }); if (validation.error) return { success: false, error: validation.error }; const outputLines = []; const startingDirName = validation.resolvedPath === '/' ? '/' : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || validation.resolvedPath; outputLines.push(startingDirName); function generateTreeLinesRecursive(directoryNode, prefix) { const childrenNames = Object.keys(directoryNode.children).sort(); childrenNames.forEach((name, index) => { const childNode = directoryNode.children[name]; const isLast = index === childrenNames.length - 1; const connector = isLast ? " " : " "; let line = prefix + connector + name; if (childNode.type === 'directory') line += "/"; outputLines.push(line); if (childNode.type === 'directory') { const newPrefix = prefix + (isLast ? "    " : "   "); generateTreeLinesRecursive(childNode, newPrefix); } }); } generateTreeLinesRecursive(validation.node, ""); return { success: true, output: outputLines.join('\n') }; }
            function matchPattern(name, pattern) { let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&'); regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.'); try { const regex = new RegExp(`^${regexPattern}$`); return regex.test(name); } catch (e) { throw new Error(`Invalid pattern regex: ${pattern}`); } }
            function findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) { if (!currentSearchNode || currentSearchNode.type !== 'directory') return; const childrenNames = Object.keys(currentSearchNode.children).sort(); for (const name of childrenNames) { const childNode = currentSearchNode.children[name]; const childFullPath = FileSystemManager.getAbsolutePath(name, currentSearchPath); if (matchPattern(name, pattern)) foundItems.push(childFullPath + (childNode.type === 'directory' ? '/' : '')); if (childNode.type === 'directory') findRecursive(childNode, childFullPath, pattern, foundItems); } }
            async function handleFind(args) { let searchPathArg = '.', pattern = null; const nameOptionIndex = args.indexOf('-name'); if (nameOptionIndex === -1) return { success: false, error: "find: usage: find [path] -name \"<pattern>\"" }; if (nameOptionIndex === 0) { searchPathArg = '.'; if (args.length < 2) return { success: false, error: "find: missing pattern after -name" }; pattern = args[1]; } else if (nameOptionIndex > 0) { searchPathArg = args.slice(0, nameOptionIndex).join(' '); if (nameOptionIndex + 1 >= args.length) return { success: false, error: "find: missing pattern after -name"}; pattern = args[nameOptionIndex + 1]; } else return { success: false, error: "find: invalid arguments for -name" }; if (pattern && pattern.length >= 2) { const firstChar = pattern[0], lastChar = pattern[pattern.length - 1]; if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) pattern = pattern.substring(1, pattern.length - 1); } if (!pattern) return { success: false, error: "find: pattern cannot be empty" }; const validation = FileSystemManager.validatePath("find", searchPathArg, {defaultToCurrentIfEmpty: true}); if(validation.error) return { success: false, error: validation.error }; const foundItems = []; try { if (validation.node.type === 'directory') findRecursive(validation.node, validation.resolvedPath, pattern, foundItems); else if (validation.node.type === 'file') { const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1); if (matchPattern(fileName, pattern)) foundItems.push(validation.resolvedPath); } } catch (e) { return { success: false, error: `find: ${e.message}` }; } return { success: true, output: foundItems.length > 0 ? foundItems.join('\n') : "" }; }
            async function handleDu(args) { const outputLines = []; let pathsToProcess = args.length > 0 ? args : ['.']; for (const pathArg of pathsToProcess) { const validation = FileSystemManager.validatePath("du", pathArg, {defaultToCurrentIfEmpty: (args.length === 0)}); if (validation.error) { await OutputManager.appendToOutput(validation.error, { isError: true }); lastCommandFailed = true; continue; } const rawSize = FileSystemManager.calculateNodeSize(validation.node); const formattedSize = Utils.formatBytes(rawSize); let displayPath = pathArg; if (validation.node.type === 'directory' && pathArg === '.') displayPath = './'; else if (validation.node.type === 'directory' && !pathArg.endsWith('/') && pathArg !== '/') displayPath += '/'; outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`); } return { success: !lastCommandFailed, output: outputLines.join('\n') }; }
            async function handleHead(args) { const defaultNumLines = 10, commandName = "head"; const options = Utils.parseNumericOption(args, "-n", defaultNumLines); let numLines = options.value, errorMessages = []; if (options.error) errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`); const filePathArg = options.remainingArgs[0]; if (!filePathArg && options.remainingArgs.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-n N] <filename>` }; if (options.remainingArgs.length > 1) return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` }; const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || "", lines = fileContent.split('\n'), outputLines = lines.slice(0, numLines); const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n'); const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null; return { success: true, output: finalOutput, messageType: messageType }; }
            async function handleTail(args) { const defaultNumLines = 10, commandName = "tail"; const options = Utils.parseNumericOption(args, "-n", defaultNumLines); let numLines = options.value, errorMessages = []; if (options.error) errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`); const filePathArg = options.remainingArgs[0]; if (!filePathArg && options.remainingArgs.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-n N] <filename>` }; if (options.remainingArgs.length > 1) return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` }; const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || "", lines = fileContent.split('\n'), outputLines = lines.slice(Math.max(0, lines.length - numLines)); const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n'); const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null; return { success: true, output: finalOutput, messageType: messageType }; }
            async function handleExport(args) { const filePathArg = args[0]; if (!filePathArg) return { success: false, error: "export: missing file operand" }; const validation = FileSystemManager.validatePath("export", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || 'downloaded_file.txt', fileContent = validation.node.content || "", mimeType = "text/plain"; try { const blob = new Blob([fileContent], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); return { success: true, output: `Exporting '${fileName}'... Check your browser downloads.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } catch (error) { console.error("Export failed:", error); return { success: false, error: `Error exporting file '${fileName}': ${error.message}` }; } }
            async function handleBackup(args) { const currentUser = UserManager.getCurrentUser(); const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14); const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`; const backupData = { backupVersion: "1.0", osVersion: Config.OS.VERSION, user: currentUser.name, timestamp: new Date().toISOString(), filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()), currentPath: FileSystemManager.getCurrentPath(), commandHistory: HistoryManager.getFullHistory() }; try { const jsonString = JSON.stringify(backupData, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = backupFileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); return { success: true, output: `Creating backup '${backupFileName}'... Check your browser downloads.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } catch (error) { console.error("Backup failed:", error); return { success: false, error: `Error creating backup: ${error.message}` }; } }
            async function handleImport(args) { const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.json'; return new Promise((resolveCommand) => { fileInput.onchange = async (event) => { const file = event.target.files[0]; if (!file) { await OutputManager.appendToOutput("Import cancelled: No file selected.", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); resolveCommand({ success: true, output: null }); return; } const reader = new FileReader(); reader.onload = async (e) => { try { const fileContent = e.target.result; const parsedData = JSON.parse(fileContent); if (typeof parsedData !== 'object' || parsedData === null || !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') || !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') || !parsedData.hasOwnProperty('backupVersion')) { await OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", { isError: true }); resolveCommand({ success: false, error: "Invalid backup file." }); return; } if (parsedData.backupVersion !== "1.0") await OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG }); const dataForConfirm = { parsedData: parsedData, fileName: file.name }; ConfirmationManager.request( [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`], dataForConfirm, async (data) => { const importedUser = data.parsedData.user; const currentActiveUser = UserManager.getCurrentUser(); if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser && !isDiagActive) SessionManager.saveAutomaticState(currentActiveUser.name); UserManager.setCurrentUserObject({ name: importedUser, credentials: StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}) }); FileSystemManager.setFsData(Utils.deepCopyNode(data.parsedData.filesystem) || { '/': { type: 'directory', children: {} } }); FileSystemManager.setCurrentPath(data.parsedData.currentPath || '/'); HistoryManager.setHistory(data.parsedData.commandHistory || []); OutputManager.clearOutput(); TerminalUI.clearInput(); await FileSystemManager.save(importedUser); await AliasManager.load(importedUser); const userCredentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); if (!userCredentials[importedUser] && importedUser !== Config.USER.DEFAULT_NAME) await OutputManager.appendToOutput(`Warning: User '${importedUser}' from backup does not have credentials. Session restored, but login for this user is not possible without registering.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG }); await OutputManager.appendToOutput(`Session for user '${importedUser}' successfully imported and restored from '${data.fileName}'.`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG }); TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; resolveCommand({ success: true, output: null}); }, () => { OutputManager.appendToOutput("Import cancelled.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); resolveCommand({ success: true, output: null}); } ); } catch (parseError) { console.error("Import error - parsing JSON:", parseError); await OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", { isError: true }); resolveCommand({ success: false, error: "Could not parse backup file."}); } }; reader.onerror = async (e) => { console.error("Import error - reading file:", e); await OutputManager.appendToOutput("Error: Could not read the selected file.", { isError: true }); resolveCommand({ success: false, error: "Could not read file."}); }; reader.readAsText(file); }; fileInput.click(); }); }
            async function handleWc(args) { const commandName = "wc"; let showLines = false, showWords = false, showBytes = false, optionsSpecified = false; const tempArgs = [...args], filesToProcess = []; while (tempArgs.length > 0 && tempArgs[0].startsWith('-')) { const option = tempArgs.shift(); optionsSpecified = true; for (const char of option.substring(1)) { switch (char) { case 'l': showLines = true; break; case 'w': showWords = true; break; case 'c': showBytes = true; break; default: return { success: false, error: `${commandName}: invalid option -- '${char}'\nUsage: ${commandName} [-lwc] [file...]` }; } } } filesToProcess.push(...tempArgs); if (filesToProcess.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-lwc] [file...]` }; const defaultAll = !optionsSpecified; let totalLines = 0, totalWords = 0, totalBytes = 0; const outputResults = []; let anyFileFailed = false; for (const filePathArg of filesToProcess) { const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) { await OutputManager.appendToOutput(validation.error, { isError: true }); anyFileFailed = true; continue; } const fileContent = validation.node.content || ""; let lineCountForDisplay; const newlineOnlyCount = (fileContent.match(/\n/g) || []).length; if (fileContent === "") lineCountForDisplay = 0; else if (showLines && optionsSpecified) lineCountForDisplay = newlineOnlyCount; else { lineCountForDisplay = newlineOnlyCount; if (fileContent.length > 0 && !fileContent.endsWith('\n')) lineCountForDisplay++; } const words = fileContent.trim() === "" ? 0 : fileContent.trim().split(/\s+/).filter(Boolean).length; const bytes = fileContent.length; totalLines += lineCountForDisplay; totalWords += words; totalBytes += bytes; let resultLine = ""; if (showLines || defaultAll) resultLine += `${String(lineCountForDisplay).padStart(7)} `; if (showWords || defaultAll) resultLine += `${String(words).padStart(7)} `; if (showBytes || defaultAll) resultLine += `${String(bytes).padStart(7)} `; resultLine += filePathArg; outputResults.push(resultLine); } if (filesToProcess.length > 1 && !anyFileFailed) { let totalLineStr = ""; if (showLines || defaultAll) totalLineStr += `${String(totalLines).padStart(7)} `; if (showWords || defaultAll) totalLineStr += `${String(totalWords).padStart(7)} `; if (showBytes || defaultAll) totalLineStr += `${String(totalBytes).padStart(7)} `; totalLineStr += "total"; outputResults.push(totalLineStr); } return { success: !anyFileFailed, output: outputResults.join('\n') }; }
            async function handleDiff(args) { const commandName = "diff"; if (args.length !== 2) return { success: false, error: `${commandName}: missing operand. Requires two file arguments.\nUsage: ${commandName} <file1> <file2>` }; const file1PathArg = args[0], file2PathArg = args[1]; const validation1 = FileSystemManager.validatePath(commandName, file1PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation1.error) return { success: false, error: validation1.error }; const validation2 = FileSystemManager.validatePath(commandName, file2PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation2.error) return { success: false, error: validation2.error }; const lines1 = (validation1.node.content || "").split('\n'), lines2 = (validation2.node.content || "").split('\n'); const lcsArray = Utils.findLCS(lines1, lines2); let ptr1 = 0, ptr2 = 0, ptrLcs = 0; const diffOutput = []; let differencesFound = false; while (ptr1 < lines1.length || ptr2 < lines2.length) { const line1Exists = ptr1 < lines1.length, line2Exists = ptr2 < lines2.length, lcsExists = ptrLcs < lcsArray.length; if (lcsExists && line1Exists && lines1[ptr1] === lcsArray[ptrLcs] && line2Exists && lines2[ptr2] === lcsArray[ptrLcs]) { ptr1++; ptr2++; ptrLcs++; } else { differencesFound = true; if (line1Exists && (!lcsExists || lines1[ptr1] !== lcsArray[ptrLcs])) { if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) { diffOutput.push(`< ${lines1[ptr1]}`); diffOutput.push(`> ${lines2[ptr2]}`); ptr1++; ptr2++; } else { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; } } else if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; } else { if (ptr1 < lines1.length) { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; } else if (ptr2 < lines2.length) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; } else break; } } } return { success: true, output: differencesFound ? diffOutput.join('\n') : "" }; }
            async function handleHistoryCmd(args) { const history = HistoryManager.getFullHistory(); if (history.length === 0) return { success: true, output: "No commands in history." }; return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') }; }
            async function handleAliasCmd(args) { const commandName = "alias", currentUser = UserManager.getCurrentUser().name; if (args.length === 0) { const aliases = AliasManager.getAliases(); if (Object.keys(aliases).length === 0) return { success: true, output: "No aliases defined." }; const output = []; for (const name in aliases) { let value = aliases[name]; if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) value = `'${value.replace(/'/g, "'\\''")}'`; output.push(`${name}=${value}`); } return { success: true, output: output.join('\n') }; } const firstArg = args.join(" "), assignmentIndex = firstArg.indexOf('='); if (assignmentIndex === -1) { const aliasName = args[0]; if (AliasManager.hasAlias(aliasName)) { let value = AliasManager.getAliases()[aliasName]; if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) value = `'${value.replace(/'/g, "'\\''")}'`; return { success: true, output: `alias ${aliasName}=${value}` }; } else return { success: false, error: `${commandName}: ${aliasName}: not found` }; } else { const aliasName = firstArg.substring(0, assignmentIndex).trim(); let commandString = firstArg.substring(assignmentIndex + 1).trim(); if (!aliasName) return { success: false, error: `${commandName}: invalid alias name.` }; if (aliasName.includes(" ")) return { success: false, error: `${commandName}: alias name cannot contain spaces.` }; if (commandRegistry.hasOwnProperty(aliasName) && aliasName !== "alias" && aliasName !== "unalias") return { success: false, error: `${commandName}: '${aliasName}' is a built-in command. Cannot create alias.` }; if (commandString === "") { if (AliasManager.hasAlias(aliasName)) { AliasManager.removeAlias(aliasName); await AliasManager.save(currentUser); return { success: true, output: `${aliasName} alias unset.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } return { success: true, output: null }; } if ((commandString.startsWith("'") && commandString.endsWith("'")) || (commandString.startsWith('"') && commandString.endsWith('"'))) commandString = commandString.substring(1, commandString.length - 1); if (aliasName === commandString.split(' ')[0]) return { success: false, error: `${commandName}: cannot alias '${aliasName}' to itself directly.` }; AliasManager.setAlias(aliasName, commandString); await AliasManager.save(currentUser); return { success: true, output: `Alias '${aliasName}' set.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } }
            async function handleUnaliasCmd(args) { const commandName = "unalias", currentUser = UserManager.getCurrentUser().name; if (args.length !== 1) return { success: false, error: `${commandName}: usage: unalias <name>` }; const aliasName = args[0]; if (AliasManager.hasAlias(aliasName)) { AliasManager.removeAlias(aliasName); await AliasManager.save(currentUser); return { success: true, output: `Alias '${aliasName}' removed.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } else return { success: false, error: `${commandName}: ${aliasName}: not found` }; }

            // --- COMMAND REGISTRY (defined AFTER all handlers) ---
            const commandRegistry = { 
                'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch, 
                'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd,
                'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep,
                'sort': handleSort, 'sysmon': handleSysmon, 'mv': handleMv, 'cp': handleCp,
                'clear': handleClear, 'register': handleRegisterCmd, 'login': handleLoginCmd,
                'logout': handleLogoutCmd, 'savestate': handleSavestate, 'loadstate': handleLoadstate,
                'reset': handleReset, 'help': handleHelp, 'man': handleMan, 'edit': handleEditCmd,
                'diag': handleDiag, 'tree': handleTree, 'find': handleFind, 'du': handleDu,
                'head': handleHead, 'tail': handleTail, 'export': handleExport, 'backup': handleBackup,
                'import': handleImport, 'wc': handleWc, 'diff': handleDiff, 'history': handleHistoryCmd,
                'alias': handleAliasCmd, 'unalias': handleUnaliasCmd
            };

            // --- INTERNAL HELPER FUNCTIONS (defined AFTER commandRegistry) ---
            function _parseInputAndRedirection(originalInputText, expandedCommandText) { let commandToExecute = expandedCommandText, redirectionType = null, redirectionFile = null; const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/); if (appendMatch) { redirectionType = 'append'; redirectionFile = appendMatch[1]; commandToExecute = commandToExecute.substring(0, appendMatch.index).trim(); } else { const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/); if (overwriteMatch) { redirectionType = 'overwrite'; redirectionFile = overwriteMatch[1]; commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim(); } } const parts = commandToExecute.split(' ').filter(p => p); const baseCommand = parts[0] ? parts[0].toLowerCase() : ''; let args; if (baseCommand === 'alias' && commandToExecute.includes('=')) args = [commandToExecute.substring(baseCommand.length).trimStart()]; else args = parts.slice(1); return { baseCommand, args, redirection: redirectionType ? { type: redirectionType, file: redirectionFile } : null, originalInput: originalInputText, executedCommand: expandedCommandText }; }
            
            async function _executeCommandHandler(parsedCommand, cmdOptions = {}) {
                const handler = commandRegistry[parsedCommand.baseCommand]; // Now commandRegistry is defined
                if (handler) {
                    try {
                        return await handler(parsedCommand.args, cmdOptions);
                    } catch (e) {
                        console.error(`Critical error in '${parsedCommand.baseCommand}':`, e);
                        return { success: false, error: `Unexpected critical error executing '${parsedCommand.baseCommand}'. Check console.`, output: null };
                    }
                } else {
                    return { success: false, error: `Error: Command not found: "${parsedCommand.baseCommand}"`, output: null };
                }
            }

            async function _processCommandOutput(parsedCommand, cmdResult, isInteractive) {
                let overallSuccess = cmdResult.success;
                if (!cmdResult.success && cmdResult.error) {
                    await OutputManager.appendToOutput(cmdResult.error, { isError: true }); 
                    lastCommandFailed = true;
                }
                if (cmdResult.output !== null && cmdResult.output !== undefined && !cmdResult.awaitingPassword) { 
                    if (parsedCommand.redirection) {
                        const redirResult = await _handleRedirection(parsedCommand.baseCommand, cmdResult.output, parsedCommand.redirection);
                        if (!redirResult.success) {
                            await OutputManager.appendToOutput(redirResult.error, { isError: true }); 
                            lastCommandFailed = true;
                            overallSuccess = false;
                        }
                    } else if (!cmdResult.isHtmlOutput) {
                        await OutputManager.appendToOutput(String(cmdResult.output), {
                            isError: !cmdResult.success, 
                            typeClass: cmdResult.messageType 
                        });
                    }
                }
                if (lastCommandFailed) overallSuccess = false;
                return { ...cmdResult, success: overallSuccess };
            }

            async function _finalizeInteractiveModeUI() {
                if (!TerminalUI.isPasswordInputActiveState()){ 
                    TerminalUI.clearInput();
                    TerminalUI.updatePrompt(); 
                    TerminalUI.focusInput();
                }
                DOM.inputLineContainerDiv.style.visibility = 'visible';
            }
            
            async function _handleRedirection(commandName, commandOutputContent, redirection) { if (!redirection || !redirection.file) return { success: false, error: `${commandName}: internal error: redirection file not specified.` }; const validation = FileSystemManager.validatePath(commandName, redirection.file, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) { if (validation.node && validation.node.type === 'directory') return { success: false, error: `${commandName}: cannot redirect to '${redirection.file}': It is a directory.` }; else return { success: false, error: validation.error }; } const targetAbsPath = validation.resolvedPath; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `${commandName}: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `${commandName}: error obtaining parent directory for redirection target '${redirection.file}'.` }; const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); const targetNode = parentNode.children[newFileName]; let contentToWrite = (commandOutputContent !== null && commandOutputContent !== undefined) ? String(commandOutputContent) : ""; if (redirection.type === 'overwrite' || !targetNode) parentNode.children[newFileName] = { type: 'file', content: contentToWrite }; else if (redirection.type === 'append' && targetNode.type === 'file') { const existingContent = targetNode.content || ""; const separator = (existingContent && contentToWrite) ? "\n" : ""; parentNode.children[newFileName].content = existingContent + separator + contentToWrite; } else return { success: false, error: `${commandName}: cannot write to '${redirection.file}': Unexpected target type or situation.` }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `${commandName}: failed to save redirected output to '${redirection.file}'.` }; return { success: true }; }

            async function processSingleCommand(rawCommandText, isInteractive = true) {
                lastCommandFailed = false;
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false, awaitingPassword: false };

                if (EditorManager.isActive() && !isDiagActive) return finalResult;
                if (ConfirmationManager.isAwaiting()) {
                    await ConfirmationManager.handleConfirmation(rawCommandText);
                     if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }

                let commandToExecute = rawCommandText.trim();
                let executedCommandTextForDisplay = commandToExecute; 

                if (TerminalUI.isPasswordInputActiveState()) {
                    const context = TerminalUI.getPasswordContext();
                    const password = rawCommandText.trim(); 
                    await OutputManager.appendToOutput("*".repeat(password.length), {isInstant: true}); 
                    
                    commandToExecute = `${context.commandName} ${context.username} ${password}`; 
                    executedCommandTextForDisplay = `${context.commandName} ${context.username} ******`; 
                    TerminalUI.switchToEditableInput(); 
                }


                if (isInteractive && !TerminalUI.isPasswordInputActiveState()) { 
                    DOM.inputLineContainerDiv.style.visibility = 'hidden';
                    const promptText = `${DOM.promptUserSpan.textContent}@${DOM.promptHostSpan.textContent}:${DOM.promptPathSpan.textContent}> `;
                    await OutputManager.appendToOutput(`${promptText}${executedCommandTextForDisplay}`, { isInstant: true });
                }


                if (commandToExecute === '' && !TerminalUI.isPasswordInputActiveState()) { 
                    if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }
                
                if (isInteractive && !TerminalUI.isPasswordInputActiveState()) { 
                    HistoryManager.add(rawCommandText.trim()); 
                }
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) {
                     HistoryManager.resetIndex();
                }
                
                const expandedCommandText = await AliasManager.expand(commandToExecute);
                if (commandToExecute !== expandedCommandText && isInteractive && !TerminalUI.isPasswordInputActiveState()) {
                    await OutputManager.appendToOutput(`> ${expandedCommandText}`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }

                const parsedCommand = _parseInputAndRedirection(rawCommandText.trim(), expandedCommandText);
                const cmdOptions = { force: (parsedCommand.baseCommand === 'rm' && !isInteractive) || (parsedCommand.args.includes('-f') || parsedCommand.args.includes('--force')) };
                const cmdResult = await _executeCommandHandler(parsedCommand, cmdOptions);
                
                finalResult = await _processCommandOutput(parsedCommand, cmdResult, isInteractive);
                
                if (isInteractive && !cmdResult.awaitingPassword) {
                    await _finalizeInteractiveModeUI();
                } else if (isInteractive && cmdResult.awaitingPassword) {
                    DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                    TerminalUI.focusInput(); 
                }
                return finalResult;
            }

            return { processSingleCommand, isDiagActive: () => isDiagActive, getLastCommandFailed: () => lastCommandFailed };
        })();

        // --- GLOBAL EVENT LISTENERS & INITIALIZATION ---
        function initializeTerminalEventListeners() {
            DOM.terminalDiv.addEventListener('click', e => { 
                if (EditorManager.isActive()) { return; }
                if (!e.target.closest('button, a') || e.target.closest('.input-line-container')) {
                    TerminalUI.focusInput();
                }
            });

            const currentInputTarget = () => document.getElementById('password-input-field') || DOM.editableInputDiv;

            document.addEventListener('keydown', async e => {
                if (EditorManager.isActive()) return;

                const target = currentInputTarget();
                if (document.activeElement !== target) return; 

                TerminalUI.setIsNavigatingHistory(false);

                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    const commandText = TerminalUI.getCurrentInputValue();
                    await CommandExecutor.processSingleCommand(commandText, true); 
                    if (!TerminalUI.isPasswordInputActiveState()) {
                        TerminalUI.clearInput();
                    }
                } else if (e.key === 'ArrowUp') { 
                    if (!TerminalUI.isPasswordInputActiveState()) { 
                        e.preventDefault(); 
                        const prevCommand = HistoryManager.getPrevious(); 
                        if (prevCommand !== null) { 
                            TerminalUI.setIsNavigatingHistory(true);
                            TerminalUI.setCurrentInputValue(prevCommand, true); 
                        }
                    }
                } else if (e.key === 'ArrowDown') { 
                     if (!TerminalUI.isPasswordInputActiveState()) {
                        e.preventDefault(); 
                        const nextCommand = HistoryManager.getNext(); 
                        if (nextCommand !== null) { 
                            TerminalUI.setIsNavigatingHistory(true);
                            TerminalUI.setCurrentInputValue(nextCommand, true); 
                        }
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    if (DOM.editableInputDiv && document.activeElement === DOM.editableInputDiv) {
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        const range = selection.getRangeAt(0);
                        const tabNode = document.createTextNode('\t'); 
                        range.deleteContents(); 
                        range.insertNode(tabNode);
                        range.setStartAfter(tabNode);
                        range.setEndAfter(tabNode);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            });
            
            if (DOM.editableInputDiv) {
                DOM.editableInputDiv.addEventListener('paste', e => {
                    if (TerminalUI.isPasswordInputActiveState()) {
                        e.preventDefault(); 
                        return;
                    }
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' ')); 
                });
            }
        }
        
        window.diagInitializedForOutput = false; 
        window.onload = async () => { 
            await OutputManager.appendToOutput("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.", { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
            try {
                await IndexedDBManager.init();
                const guestUser = { name: UserManager.getDefaultUser(), credentials: {} }; UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.load(UserManager.getDefaultUser()); await AliasManager.load(UserManager.getDefaultUser());
                SessionManager.loadAutomaticState(UserManager.getDefaultUser()); 
                initializeTerminalEventListeners(); 
                TerminalUI.focusInput(); 
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                await OutputManager.appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details and browser storage settings.", { isInstant: true, isError: true }); 
            }
        };
    </script>
</body>
</html>
