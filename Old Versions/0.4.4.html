<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOs v.0.4.4 (Config Refactor)</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
        }

        .input-line { display: flex; align-items: center; width: 100%; }
        .prompt-user { margin-right: 2px; color: #7fdbff; }
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #visual-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        #input-before-cursor, #input-after-cursor {
            white-space: pre;
            display: inline-block;
        }
        .cursor {
            width: 10px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #hidden-input { position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .file-item { }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }

        /* Editor specific styles */
        #editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #editor-textarea {
            flex-grow: 1;
            width: 100%;
            background-color: #0c0c0c;
            color: #00dd00;
            border: 1px solid #222;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            resize: none;
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 4px;
            overflow-y: auto;
        }
        #editor-instructions {
            padding: 5px 0;
            font-size: 0.9em;
            text-align: center;
            color: #aaa;
            flex-shrink: 0;
        }
        .diag-output-block { /* No specific styles needed yet, but class is there */ }
        .diag-section-title { /* Style for diag section headers */
            color: #00ffff; /* Cyan */
            font-weight: bold;
            margin-top: 8px;
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line">
                <span id="prompt-user" class="prompt-user"></span>
                <span class="prompt-separator">@</span>
                <span id="prompt-host" class="prompt-host">OopisOs</span>
                <span class="prompt-separator">:</span>
                <span id="prompt-path" class="prompt-path"></span>
                <span class="prompt-char">&gt;</span>
                <div id="visual-input-container">
                    <span id="input-before-cursor"></span>
                    <div class="cursor"></div>
                    <span id="input-after-cursor"></span>
                </div>
            </div>
            <input type="text" id="hidden-input" autofocus autocapitalize="none" autocorrect="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- CONFIG MODULE ---
        const Config = (() => {
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore",
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "0.4.4.0", // Updated OS Version
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    MAX_ALIAS_EXPANSION_DEPTH: 10,
                },
                STORAGE_KEYS: { 
                    USER_CREDENTIALS: 'oopisOsUserCredentials',
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                    ALIAS_FILE_PATH: "/.aliases" 
                },
                CSS_CLASSES: { 
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    DIR_ITEM: 'directory-item',
                    FILE_ITEM: 'file-item',
                    HELP_CMD_NAME: 'help-command-name',
                    HELP_DESC: 'help-description',
                    OUTPUT_LINE: 'output-line',
                    MAN_SECTION_TITLE: 'man-section-title',
                    MAN_SECTION_CONTENT: 'man-section-content',
                    MAN_EXAMPLE: 'man-example',
                    SYSMON_LABEL: 'sysmon-label',
                    EDITOR_MESSAGE: 'editor-message', 
                    DIAG_OUTPUT: 'diag-output',
                    DIAG_SECTION: 'diag-section-title' 
                }
            };
        })();

        // --- DOM MODULE ---
        const DOM = (() => { 
            return {
                terminalDiv: document.getElementById('terminal'), outputDiv: document.getElementById('output'),
                standardInputLineDiv: document.getElementById('terminal').querySelector('.input-line'),
                inputBeforeCursorSpan: document.getElementById('input-before-cursor'), inputAfterCursorSpan: document.getElementById('input-after-cursor'),
                hiddenInput: document.getElementById('hidden-input'), promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'), promptHostSpan: document.getElementById('prompt-host')
            };
        })();

        // --- UTILS MODULE ---
        const Utils = (() => { 
            function formatConsoleArgs(args) { return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' '); }
            function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }
            async function hashPassword(password) { try { const encoder = new TextEncoder(); const data = encoder.encode(password); const hashBuffer = await crypto.subtle.digest('SHA-256', data); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); } catch (error) { console.error("Password hashing failed:", error); throw new Error("Password hashing service unavailable."); } }
            function formatBytes(bytes, decimals = 2) { if (bytes === 0) return '0 B'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
            function parseNumericOption(args, optionStr, defaultValue) { let numericValue = defaultValue; const remainingArgs = [...args]; let error = null; const optionIndex = remainingArgs.indexOf(optionStr); if (optionIndex !== -1) { if (optionIndex + 1 < remainingArgs.length) { const potentialNumber = remainingArgs[optionIndex + 1]; const parsedNumber = parseInt(potentialNumber, 10); if (!isNaN(parsedNumber) && parsedNumber >= 0) { numericValue = parsedNumber; remainingArgs.splice(optionIndex, 2); } else { error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`; remainingArgs.splice(optionIndex, 2); } } else { error = `option ${optionStr} requires an argument`; remainingArgs.splice(optionIndex, 1); } } return { value: numericValue, remainingArgs, error }; }
            function findLCS(X, Y) { const m = X.length; const n = Y.length; const L = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0)); for (let i = 0; i <= m; i++) { for (let j = 0; j <= n; j++) { if (i === 0 || j === 0) L[i][j] = 0; else if (X[i - 1] === Y[j - 1]) L[i][j] = L[i - 1][j - 1] + 1; else L[i][j] = Math.max(L[i - 1][j], L[i][j - 1]); } } let index = L[m][n]; const lcs = Array(index); let i = m, j = n; while (i > 0 && j > 0) { if (X[i - 1] === Y[j - 1]) { lcs[index - 1] = X[i - 1]; i--; j--; index--; } else if (L[i - 1][j] > L[i][j - 1]) i--; else j--; } return lcs; }
            return { formatConsoleArgs, deepCopyNode, hashPassword, formatBytes, parseNumericOption, findLCS };
        })();

        // --- OUTPUT MANAGER MODULE ---
        const OutputManager = (() => { 
            let isEditorActive = false, isDiagRunning = false; 
            function setEditorActive(status) { isEditorActive = status; } function setDiagRunning(status) { isDiagRunning = status; }
            function appendToOutput(text, isError = false, typeClass = null) { if (isEditorActive && typeClass !== Config.CSS_CLASSES.EDITOR_MESSAGE && typeClass !== Config.CSS_CLASSES.DIAG_OUTPUT && typeClass !== Config.CSS_CLASSES.DIAG_SECTION) return; const newLine = document.createElement('div'); newLine.classList.add(Config.CSS_CLASSES.OUTPUT_LINE); if (typeClass) newLine.classList.add(typeClass); if (isError && !typeClass) newLine.classList.add(Config.CSS_CLASSES.ERROR_MSG); newLine.textContent = text; DOM.outputDiv.appendChild(newLine); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }
            function appendHtmlToOutput(htmlContent) { if (isEditorActive && !isDiagRunning) return; const blockDiv = document.createElement('div'); blockDiv.innerHTML = htmlContent; DOM.outputDiv.appendChild(blockDiv); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }
            function appendStyledOutput(label, value) { if (isEditorActive) return; const line = document.createElement('div'); line.classList.add(Config.CSS_CLASSES.OUTPUT_LINE); const labelSpan = document.createElement('span'); labelSpan.classList.add(Config.CSS_CLASSES.SYSMON_LABEL); labelSpan.textContent = label.padEnd(20, ' '); const valueSpan = document.createElement('span'); valueSpan.textContent = value; line.appendChild(labelSpan); line.appendChild(valueSpan); DOM.outputDiv.appendChild(line); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }
            function clearOutput() { if (!isEditorActive) DOM.outputDiv.innerHTML = '';}
            const originalConsoleLog = console.log, originalConsoleWarn = console.warn, originalConsoleError = console.error;
            console.log = (...args) => { if (!isEditorActive) appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); originalConsoleLog.apply(console, args); };
            console.warn = (...args) => { if (!isEditorActive) appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, false, Config.CSS_CLASSES.WARNING_MSG); originalConsoleWarn.apply(console, args); };
            console.error = (...args) => { if (!isEditorActive) appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, true, Config.CSS_CLASSES.ERROR_MSG); originalConsoleError.apply(console, args); };
            return { setEditorActive, setDiagRunning, appendToOutput, appendHtmlToOutput, appendStyledOutput, clearOutput };
        })();

        // --- STORAGE MANAGER MODULE (localStorage) ---
        const StorageManager = (() => { 
            function loadJSON(key, itemName, defaultValue = null) { try { const storedValue = localStorage.getItem(key); if (storedValue) return JSON.parse(storedValue); } catch (e) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, false, Config.CSS_CLASSES.WARNING_MSG); } return defaultValue; }
            function saveJSON(key, data, itemName) { try { localStorage.setItem(key, JSON.stringify(data)); return true; } catch (e) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Critical Error: Could not save ${itemName} for '${key}'.`, true, Config.CSS_CLASSES.ERROR_MSG); } return false; }
            function removeItem(key) { localStorage.removeItem(key); } function getAllLocalStorageKeys() { const keys = []; for (let i = 0; i < localStorage.length; i++) keys.push(localStorage.key(i)); return keys; }
            return { loadJSON, saveJSON, removeItem, getAllLocalStorageKeys };
        })();

        // --- INDEXEDDB MANAGER MODULE ---
        const IndexedDBManager = (() => { 
            let dbInstance = null;
            function init() { return new Promise((resolve, reject) => { if (dbInstance) { resolve(dbInstance); return; } const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION); request.onupgradeneeded = (event) => { const tempDb = event.target.result; if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' }); }; request.onsuccess = (event) => { dbInstance = event.target.result; if (!CommandExecutor || !CommandExecutor.isDiagActive() && !window.diagInitializedForOutput) { OutputManager.appendToOutput("FileSystem DB initialized.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); window.diagInitializedForOutput = true; } resolve(dbInstance); }; request.onerror = (event) => { console.error("Database error: ", event.target.error); OutputManager.appendToOutput("Critical Error: Could not initialize FileSystem DB.", true, Config.CSS_CLASSES.ERROR_MSG); reject(event.target.error); }; }); }
            function getDbInstance() { if (!dbInstance) { OutputManager.appendToOutput("Error: IndexedDB not initialized.", true, Config.CSS_CLASSES.ERROR_MSG); throw new Error("IndexedDB not initialized."); } return dbInstance; }
            return { init, getDbInstance };
        })();

        // --- FILESYSTEM MANAGER MODULE ---
        const FileSystemManager = (() => { 
            let fsData = {}, currentPath = '/'; 
            function getFileSystemKey(user) { return `fs_${user}`; }
            async function initialize(user) { fsData = { '/': { type: 'directory', children: {} } }; await save(user); }
            async function save(user) { const db = IndexedDBManager.getDbInstance(); if (!db) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput("Error: Filesystem DB not available for saving.", true, Config.CSS_CLASSES.ERROR_MSG); return Promise.reject("DB not initialized for FS save"); } return new Promise((resolve, reject) => { try { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const dataToSave = Utils.deepCopyNode(fsData); if (!dataToSave || typeof dataToSave !== 'object' || !dataToSave['/'] || dataToSave['/'].type !== 'directory') { console.error("Attempted to save invalid fsData structure for user:", user, dataToSave); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Critical Error: Corrupted FS data for ${user} before saving. Save aborted.`, true, Config.CSS_CLASSES.ERROR_MSG); return reject(new Error("Corrupted FS data before saving.")); } const request = store.put({ id: getFileSystemKey(user), data: dataToSave }); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error(`Error saving FS for ${user}:`, event.target.error); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Critical Error: Could not save FS for ${user}.`, true, Config.CSS_CLASSES.ERROR_MSG); reject(event.target.error); }; } catch (e) { console.error(`Error initiating save transaction for ${user}:`, e); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Critical Error: Could not save FS for ${user} (transaction error).`, true, Config.CSS_CLASSES.ERROR_MSG); reject(e); } }); }
            async function load(user) { const db = IndexedDBManager.getDbInstance(); if (!db) { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput("Error: Filesystem DB not available for loading.", true, Config.CSS_CLASSES.ERROR_MSG); fsData = { '/': { type: 'directory', children: {} } }; return Promise.reject("DB not initialized for FS load"); } return new Promise(async (resolve, reject) => { try { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.get(getFileSystemKey(user)); request.onsuccess = async (event) => { const result = event.target.result; if (result && result.data && result.data['/']?.type === 'directory') fsData = result.data; else { if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(result ? `Invalid FS for ${user}. Reinitializing.` : `No FS for ${user}. Initializing.`, false, result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG); await initialize(user); } resolve(); }; request.onerror = async (event) => { console.error(`Error loading FS for ${user}:`, event.target.error); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: FS for '${user}' corrupted or unavailable. Initializing new FS.`, false, Config.CSS_CLASSES.WARNING_MSG); await initialize(user); reject(event.target.error); }; } catch (e) { console.error(`Error initiating load transaction for ${user}:`, e); if (!CommandExecutor || !CommandExecutor.isDiagActive()) OutputManager.appendToOutput(`Warning: FS for '${user}' corrupted (transaction error). Initializing new FS.`, false, Config.CSS_CLASSES.WARNING_MSG); await initialize(user); reject(e); } }); }
            async function deleteUserFS(user) { const db = IndexedDBManager.getDbInstance(); if (!db) return Promise.reject("DB not initialized for FS delete"); return new Promise((resolve, reject) => { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.delete(getFileSystemKey(user)); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error(`Error deleting FS for ${user}:`, event.target.error); reject(event.target.error); }; }); }
            async function clearAllFS() { const db = IndexedDBManager.getDbInstance(); if (!db) { OutputManager.appendToOutput("Error: Filesystem DB not available for clearing all FS.", true, Config.CSS_CLASSES.ERROR_MSG); return Promise.reject("DB not initialized for clearing all FS"); } return new Promise((resolve, reject) => { const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite'); const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME); const request = store.clear(); request.onsuccess = () => resolve(true); request.onerror = (event) => { console.error("Error clearing FileSystemsStore:", event.target.error); OutputManager.appendToOutput("Error clearing all user filesystems from DB.", true, Config.CSS_CLASSES.ERROR_MSG); reject(event.target.error); }; }); }
            function getCurrentPath() { return currentPath; } function setCurrentPath(path) { currentPath = path; } function getFsData() { return fsData; } function setFsData(newData) { fsData = newData; }
            function getAbsolutePath(targetPath, basePath) { if (!targetPath) targetPath = '.'; if (targetPath.startsWith('/')) basePath = '/'; const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s && s !== '.'); let resolvedSegments = [...baseSegments]; const targetSegments = targetPath.split('/'); for (const segment of targetSegments) { if (segment === '' || segment === '.') { if (targetPath.startsWith('/') && resolvedSegments.length === 0 && segment === '') {} continue; } if (segment === '..') { if (resolvedSegments.length > 0) resolvedSegments.pop(); } else resolvedSegments.push(segment); } if (targetPath.startsWith('/') && resolvedSegments.length === 0) return '/'; return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/'); }
            function getNodeByPath(path) { const absolutePath = getAbsolutePath(path, currentPath); if (absolutePath === '/') return fsData['/']; const segments = absolutePath.substring(1).split('/').filter(s => s); let currentNode = fsData['/']; for (const segment of segments) { if (currentNode && currentNode.type === 'directory' && currentNode.children && currentNode.children[segment]) currentNode = currentNode.children[segment]; else return null; } return currentNode; }
            function createParentDirectoriesIfNeeded(fullPath) { if (fullPath === '/') return { parentNode: null, error: "Cannot create parent for root." }; const lastSlashIndex = fullPath.lastIndexOf('/'); if (lastSlashIndex === -1 && fullPath.startsWith('/')) return { parentNode: fsData['/'], error: null }; if (lastSlashIndex === -1 && !fullPath.startsWith('/')) return { parentNode: fsData['/'], error: null }; const parentPath = lastSlashIndex === 0 ? '/' : fullPath.substring(0, lastSlashIndex); const newFileName = fullPath.substring(lastSlashIndex + 1); if (!newFileName || newFileName === "." || newFileName === "..") return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` }; if (parentPath === '/') return { parentNode: fsData['/'], error: null }; const parentPathSegments = parentPath.substring(1).split('/').filter(s => s); let currentDirNode = fsData['/']; let currentBuiltParentPath = ""; for (const segment of parentPathSegments) { currentBuiltParentPath += "/" + segment; if (!currentDirNode.children[segment]) currentDirNode.children[segment] = { type: 'directory', children: {} }; else if (currentDirNode.children[segment].type !== 'directory') return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` }; currentDirNode = currentDirNode.children[segment]; } return { parentNode: currentDirNode, error: null }; }
            function calculateNodeSize(node) { if (!node) return 0; if (node.type === 'file') return (node.content || "").length; if (node.type === 'directory') { let totalSize = 0; for (const childName in node.children) totalSize += calculateNodeSize(node.children[childName]); return totalSize; } return 0; }
            function validatePath(commandName, pathArg, options = {}) { const { expectedType = 'any', allowMissing = false, disallowRoot = false, defaultToCurrentIfEmpty = true } = options; let effectivePathArg = pathArg; if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) effectivePathArg = '.'; if (effectivePathArg === undefined || effectivePathArg === null) return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` }; const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath()); const node = getNodeByPath(resolvedPath); if (disallowRoot && resolvedPath === '/') return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '/'` }; if (node) { if (expectedType === 'file' && node.type !== 'file') return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` }; if (expectedType === 'directory' && node.type !== 'directory') return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` }; return { node: node, resolvedPath: resolvedPath, error: null }; } else { if (allowMissing) return { node: null, resolvedPath: resolvedPath, error: null }; else return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory` }; } }
            return { initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath, getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded, calculateNodeSize, validatePath };
        })();

        // --- ALIAS MANAGER MODULE ---
        const AliasManager = (() => { 
            let userAliases = {}; 
            async function load(currentUser) { userAliases = {}; const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH; const aliasFileNode = FileSystemManager.getNodeByPath(aliasFilePath); if (aliasFileNode && aliasFileNode.type === 'file') { try { const parsed = JSON.parse(aliasFileNode.content); if (typeof parsed === 'object' && parsed !== null) userAliases = parsed; } catch (e) { /* Silently ignore */ } } }
            async function save(currentUser) { const aliasJsonString = JSON.stringify(userAliases, null, 2); const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH; const fsData = FileSystemManager.getFsData(); const rootNode = fsData['/']; if (rootNode && rootNode.children) { const aliasFileName = aliasFilePath.substring(1); rootNode.children[aliasFileName] = { type: 'file', content: aliasJsonString }; await FileSystemManager.save(currentUser); } else OutputManager.appendToOutput("Critical error: Could not save aliases. Root directory not found.", true, Config.CSS_CLASSES.ERROR_MSG); }
            async function expand(commandInputText, depth = 0) { if (depth > Config.TERMINAL.MAX_ALIAS_EXPANSION_DEPTH) { OutputManager.appendToOutput(`alias: Maximum expansion depth exceeded (possible loop).`, true, Config.CSS_CLASSES.ERROR_MSG); return commandInputText; } const parts = commandInputText.trim().split(' '); const potentialAlias = parts[0]; if (userAliases.hasOwnProperty(potentialAlias)) { const aliasValue = userAliases[potentialAlias]; const remainingArgs = parts.slice(1).join(' '); const expandedCommand = (aliasValue + (remainingArgs ? ' ' + remainingArgs : '')).trim(); const nextPotentialAlias = expandedCommand.split(' ')[0]; if (userAliases.hasOwnProperty(nextPotentialAlias) && nextPotentialAlias !== potentialAlias) return await expand(expandedCommand, depth + 1); return expandedCommand; } return commandInputText; }
            function getAliases() { return userAliases; } function setAlias(name, value) { userAliases[name] = value; } function removeAlias(name) { delete userAliases[name]; } function hasAlias(name) { return userAliases.hasOwnProperty(name); }
            return { load, save, expand, getAliases, setAlias, removeAlias, hasAlias };
        })();

        // --- HISTORY MANAGER MODULE ---
        const HistoryManager = (() => { 
            let commandHistory = [], historyIndex = 0; 
            function add(command) { if (command.trim() && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command.trim())) { commandHistory.push(command.trim()); if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) commandHistory.shift(); } historyIndex = commandHistory.length; }
            function getPrevious() { if (commandHistory.length > 0 && historyIndex > 0) { historyIndex--; return commandHistory[historyIndex]; } return null; }
            function getNext() { if (historyIndex < commandHistory.length - 1) { historyIndex++; return commandHistory[historyIndex]; } else if (historyIndex >= commandHistory.length - 1) { historyIndex = commandHistory.length; return ""; } return null; }
            function resetIndex() { historyIndex = commandHistory.length; } function getFullHistory() { return [...commandHistory]; } function clearHistory() { commandHistory = []; historyIndex = 0; } function setHistory(newHistory) { commandHistory = Array.isArray(newHistory) ? [...newHistory] : []; historyIndex = commandHistory.length; }
            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();
        
        // --- CONFIRMATION MANAGER MODULE ---
        const ConfirmationManager = (() => { 
            let awaitingConfirmation = false, confirmationContext = null;
            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) { awaitingConfirmation = true; confirmationContext = { promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines], data: dataForAction, onConfirm: onConfirmCallback, onCancel: onCancelCallback }; confirmationContext.promptMessageLines.forEach(line => OutputManager.appendToOutput(line, false, Config.CSS_CLASSES.WARNING_MSG)); OutputManager.appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, Config.CSS_CLASSES.WARNING_MSG); }
            async function handleConfirmation(input) { if (!awaitingConfirmation) return false; let processed = false; if (input.trim() === 'YES' && confirmationContext && typeof confirmationContext.onConfirm === 'function') { await confirmationContext.onConfirm(confirmationContext.data); processed = true; } else { if (confirmationContext && typeof confirmationContext.onCancel === 'function') confirmationContext.onCancel(confirmationContext.data); else OutputManager.appendToOutput("Operation cancelled.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); processed = true; } awaitingConfirmation = false; confirmationContext = null; return processed; }
            function isAwaiting() { return awaitingConfirmation; }
            return { request, handleConfirmation, isAwaiting };
        })();

        // --- EDITOR MANAGER MODULE ---
        const EditorManager = (() => { 
            let isEditingFile = false, editingFilePath = null, editorWrapperDiv = null, editorTextareaElement = null, editorInstructionsDiv = null;
            function isActive() { return isEditingFile; }
            function enter(filePath, content) { if (isEditingFile) { OutputManager.appendToOutput("Editor already active. Ctrl+S to save, Ctrl+O to quit.", false, Config.CSS_CLASSES.EDITOR_MESSAGE); return; } isEditingFile = true; OutputManager.setEditorActive(true); editingFilePath = filePath; DOM.outputDiv.style.display = 'none'; DOM.standardInputLineDiv.style.display = 'none'; DOM.hiddenInput.blur(); editorWrapperDiv = document.createElement('div'); editorWrapperDiv.id = 'editor-wrapper'; editorTextareaElement = document.createElement('textarea'); editorTextareaElement.id = 'editor-textarea'; editorTextareaElement.value = content; editorInstructionsDiv = document.createElement('div'); editorInstructionsDiv.id = 'editor-instructions'; editorInstructionsDiv.textContent = `Editing: ${filePath} | Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving`; editorWrapperDiv.appendChild(editorTextareaElement); editorWrapperDiv.appendChild(editorInstructionsDiv); DOM.terminalDiv.insertBefore(editorWrapperDiv, DOM.standardInputLineDiv); editorTextareaElement.focus(); editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length); editorTextareaElement.addEventListener('keydown', handleKeyDown); }
            async function exit(saveChanges = false) { let success = true; if (saveChanges && editorTextareaElement && editingFilePath) { const newContent = editorTextareaElement.value; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(editingFilePath); if (parentDirResult.error) { OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, true, Config.CSS_CLASSES.ERROR_MSG); success = false; } else { const parentNode = parentDirResult.parentNode; if (parentNode) { const fileName = editingFilePath.substring(editingFilePath.lastIndexOf('/') + 1); parentNode.children[fileName] = { type: 'file', content: newContent }; const currentUser = UserManager.getCurrentUser(); if (currentUser) { if (await FileSystemManager.save(currentUser.name)) OutputManager.appendToOutput(`File '${editingFilePath}' saved.`, false, Config.CSS_CLASSES.SUCCESS_MSG); else { OutputManager.appendToOutput(`Error saving file '${editingFilePath}'. Changes might be lost.`, true, Config.CSS_CLASSES.ERROR_MSG); success = false; } } else { OutputManager.appendToOutput(`Error saving file: No current user context.`, true, Config.CSS_CLASSES.ERROR_MSG); success = false; } } else { OutputManager.appendToOutput(`Failed to save '${editingFilePath}'. Could not obtain parent directory.`, true, Config.CSS_CLASSES.ERROR_MSG); success = false; } } } else if (editingFilePath) OutputManager.appendToOutput(`Exited editor for '${editingFilePath}' without saving.`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); if (editorWrapperDiv && editorWrapperDiv.parentNode === DOM.terminalDiv) DOM.terminalDiv.removeChild(editorWrapperDiv); if (editorTextareaElement) editorTextareaElement.removeEventListener('keydown', handleKeyDown); editorWrapperDiv = null; editorTextareaElement = null; editorInstructionsDiv = null; isEditingFile = false; OutputManager.setEditorActive(false); editingFilePath = null; DOM.outputDiv.style.display = ''; DOM.standardInputLineDiv.style.display = ''; DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; DOM.hiddenInput.focus(); TerminalUI.updatePrompt(); return success; }
            async function handleKeyDown(event) { if (event.key === 'Tab') { event.preventDefault(); const start = this.selectionStart, end = this.selectionEnd; this.value = this.value.substring(0, start) + "\t" + this.value.substring(end); this.selectionStart = this.selectionEnd = start + 1; return; } if (event.ctrlKey && event.key === 's') { event.preventDefault(); await exit(true); } else if (event.ctrlKey && (event.key === 'o' || event.key === 'O')) { event.preventDefault(); await exit(false); } }
            function focusEditor() { if (isEditingFile && editorTextareaElement) editorTextareaElement.focus(); } function getEditorTextarea() { return editorTextareaElement; } function getEditorWrapperDiv() { return editorWrapperDiv; }
            return { isActive, enter, exit, focusEditor, getEditorTextarea, getEditorWrapperDiv };
        })();

        // --- TERMINAL UI MODULE ---
        const TerminalUI = (() => { 
            let isPasswordInputActive = false, passwordMaskStartIndex = -1, isNavigatingHistory = false; 
            function updatePrompt() { const user = UserManager.getCurrentUser(); DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME; DOM.promptHostSpan.textContent = Config.OS.NAME; DOM.promptPathSpan.textContent = FileSystemManager.getCurrentPath().trim() === '' ? '/' : FileSystemManager.getCurrentPath(); }
            function setPasswordInputActive(status, startIndex = -1) { isPasswordInputActive = status; passwordMaskStartIndex = startIndex; } function getPasswordInputActive() { return {isActive: isPasswordInputActive, startIndex: passwordMaskStartIndex}; }
            function updateVisualInput() { const inputValue = DOM.hiddenInput.value, cursorPos = DOM.hiddenInput.selectionStart; let visualString = inputValue; if (isPasswordInputActive && passwordMaskStartIndex !== -1 && inputValue.length > passwordMaskStartIndex) { const prefix = inputValue.substring(0, passwordMaskStartIndex), suffixToMask = inputValue.substring(passwordMaskStartIndex); visualString = prefix + '*'.repeat(suffixToMask.length); } DOM.inputBeforeCursorSpan.textContent = visualString.substring(0, cursorPos); DOM.inputAfterCursorSpan.textContent = visualString.substring(cursorPos); }
            function clearHiddenInput() { DOM.hiddenInput.value = ''; isPasswordInputActive = false; passwordMaskStartIndex = -1; updateVisualInput(); }
            function setHiddenInputValue(value, setCursorToEnd = false) { DOM.hiddenInput.value = value; DOM.hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); if (setCursorToEnd) setTimeout(() => { const len = DOM.hiddenInput.value.length; DOM.hiddenInput.setSelectionRange(len, len); DOM.hiddenInput.focus(); }, 0); }
            function setIsNavigatingHistory(status) { isNavigatingHistory = status; } function getIsNavigatingHistory() { return isNavigatingHistory; }
            return { updatePrompt, updateVisualInput, setPasswordInputActive, getPasswordInputActive, clearHiddenInput, setHiddenInputValue, setIsNavigatingHistory, getIsNavigatingHistory };
        })();
        
        // --- USER MANAGER MODULE ---
        const UserManager = (() => { 
            let currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; 
            function getCurrentUser() { return currentUser; } 
            async function register(username, password) { const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); if (credentials[username]) return { success: false, error: `User '${username}' already exists.` }; if (username.toLowerCase() === Config.USER.DEFAULT_NAME.toLowerCase()) return { success: false, error: `Cannot register '${Config.USER.DEFAULT_NAME}'. This username is reserved.` }; if (username.includes(" ") || password.includes(" ")) return { success: false, error: "Username and password cannot contain spaces." }; try { const hashedPassword = await Utils.hashPassword(password); credentials[username] = hashedPassword; if (StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, credentials, "User creds")) { await FileSystemManager.initialize(username); await AliasManager.load(username); return { success: true, message: `User '${username}' registered. You can now login.` }; } else return { success: false, error: "Failed to save new user credentials." }; } catch (error) { return { success: false, error: `Registration failed for '${username}': ${error.message}` }; } }
            async function login(username, password) { if (currentUser.name === username && (!CommandExecutor || !CommandExecutor.isDiagActive())) return { success: true, message: `Already logged in as '${username}'.`, noAction: true }; const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); const storedPasswordHash = credentials[username]; if (!storedPasswordHash) return { success: false, error: "Invalid username or password." }; try { const enteredPasswordHash = await Utils.hashPassword(password); if (storedPasswordHash === enteredPasswordHash) { if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username && (!CommandExecutor || !CommandExecutor.isDiagActive())) SessionManager.saveAutomaticState(currentUser.name); currentUser = { name: username, credentials }; HistoryManager.clearHistory(); await FileSystemManager.load(username); await AliasManager.load(username); if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.loadAutomaticState(username); TerminalUI.updatePrompt(); return { success: true, message: `Logged in as ${username}.` }; } else return { success: false, error: "Invalid username or password." }; } catch (error) { return { success: false, error: `Login failed: ${error.message}` }; } }
            async function logout() { if (currentUser.name === Config.USER.DEFAULT_NAME) return { success: true, message: "Already logged in as Guest. No action taken.", noAction: true }; if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.saveAutomaticState(currentUser.name); const prevUserName = currentUser.name; currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; HistoryManager.clearHistory(); await FileSystemManager.load(Config.USER.DEFAULT_NAME); await AliasManager.load(Config.USER.DEFAULT_NAME); if (!CommandExecutor || !CommandExecutor.isDiagActive()) SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME); TerminalUI.updatePrompt(); return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` }; }
            function setCurrentUserObject(userObject) { currentUser = userObject; } function getDefaultUser() { return Config.USER.DEFAULT_NAME; }
            return { getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser };
        })();
        
        // --- SESSION MANAGER MODULE ---
        const SessionManager = (() => { 
            function getAutomaticSessionStateKey(user) { return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`; }
            function getManualUserTerminalStateKey(user) { return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${user.name || user}`; }
            function saveAutomaticState(username) { const autoState = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: DOM.hiddenInput.value, commandHistory: HistoryManager.getFullHistory() }; StorageManager.saveJSON(getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`); }
            function loadAutomaticState(username) { const autoState = StorageManager.loadJSON(getAutomaticSessionStateKey(username), `Auto session for ${username}`); const isDiag = CommandExecutor && CommandExecutor.isDiagActive(); if (autoState) { FileSystemManager.setCurrentPath(autoState.currentPath || '/'); if (!isDiag && autoState.hasOwnProperty('outputHTML')) DOM.outputDiv.innerHTML = autoState.outputHTML || ''; else if (!isDiag && !autoState.hasOwnProperty('outputHTML')) if(!isDiag) DOM.outputDiv.innerHTML = ''; TerminalUI.setHiddenInputValue(autoState.currentInput || ''); HistoryManager.setHistory(autoState.commandHistory || []); } else { if (!isDiag) DOM.outputDiv.innerHTML = ''; TerminalUI.setHiddenInputValue(''); FileSystemManager.setCurrentPath('/'); HistoryManager.clearHistory(); if (!isDiag) OutputManager.appendToOutput(`Welcome, ${username}! Type 'help' for commands.`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); } TerminalUI.updateVisualInput(); TerminalUI.updatePrompt(); if (!isDiag) DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; return !!autoState; }
            async function saveManualState() { const currentUser = UserManager.getCurrentUser(); const pendingData = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: DOM.hiddenInput.value, fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()), commandHistory: HistoryManager.getFullHistory() }; if (StorageManager.saveJSON(getManualUserTerminalStateKey(currentUser), pendingData, `Manual save for ${currentUser.name}`)) return { success: true, message: `Session manually saved for ${currentUser.name}.` }; return { success: false, error: "Failed to save session." }; }
            async function loadManualState() { const currentUser = UserManager.getCurrentUser(); const pendingData = StorageManager.loadJSON(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`); if (pendingData) { ConfirmationManager.request( ["Load manually saved state? This overwrites current session & filesystem."], { pendingData: pendingData, userName: currentUser.name }, async (data) => { FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { '/': { type: 'directory', children: {} } }); FileSystemManager.setCurrentPath(data.pendingData.currentPath || '/'); DOM.outputDiv.innerHTML = data.pendingData.outputHTML || ''; TerminalUI.setHiddenInputValue(data.pendingData.currentInput || ''); HistoryManager.setHistory(data.pendingData.commandHistory || []); await FileSystemManager.save(data.userName); OutputManager.appendToOutput("Session loaded from manual save.", false, Config.CSS_CLASSES.SUCCESS_MSG); TerminalUI.updateVisualInput(); TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }, () => { OutputManager.appendToOutput("Load state cancelled.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); } ); return { success: true, message: "Confirmation requested for loading state." }; } else return { success: false, message: `No manually saved state found for ${currentUser.name}.` }; }
            async function performFullReset() { OutputManager.clearOutput(); TerminalUI.clearHiddenInput(); const keysToRemove = []; const allKeys = StorageManager.getAllLocalStorageKeys(); allKeys.forEach(key => { if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) || key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) || key === Config.STORAGE_KEYS.USER_CREDENTIALS) keysToRemove.push(key); }); keysToRemove.forEach(key => StorageManager.removeItem(key)); OutputManager.appendToOutput("All session states and credentials cleared from local storage.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); try { await FileSystemManager.clearAllFS(); OutputManager.appendToOutput("All user filesystems cleared from DB.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); } catch (error) { /* Handled by FSManager */ } HistoryManager.clearHistory(); const guestUser = { name: Config.USER.DEFAULT_NAME, credentials: {} }; UserManager.setCurrentUserObject(guestUser); await FileSystemManager.initialize(Config.USER.DEFAULT_NAME); await AliasManager.load(Config.USER.DEFAULT_NAME); loadAutomaticState(Config.USER.DEFAULT_NAME); OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", false, Config.CSS_CLASSES.SUCCESS_MSG); TerminalUI.updatePrompt(); }
            return { saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset };
        })();

        // --- COMMAND EXECUTOR MODULE ---
        const CommandExecutor = (() => {
            let lastCommandFailed = false; 
            let isDiagActive = false; 
            const commandHelpData = { /* ... All help data remains here ... */ 
                'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms unless forced).', syntax: 'rm [-f] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation. The -f or --force option bypasses confirmation (used internally by scripts). The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
                'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
                'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
                'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
                'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { usage: 'register <username> <password>', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME PASSWORD', details: 'Registers a new user with the given USERNAME and PASSWORD. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage and input is masked.', examples: ['register myuser mysecretpass']},
                'login': { usage: 'login <username> <password>', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME PASSWORD', details: 'Logs in as the specified USERNAME using the provided PASSWORD. The entered password will be hashed, compared against the stored hash, and input is masked. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser mysecretpass']},
                'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
                'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
                'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
                'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
                'head': { usage: 'head [-n N] <filename>', summary: 'Displays the beginning of a file.', syntax: 'head [-n N] FILE', details: 'Prints the first N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt']},
                'tail': { usage: 'tail [-n N] <filename>', summary: 'Displays the end of a file.', syntax: 'tail [-n N] FILE', details: 'Prints the last N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt']},
                'export': { usage: 'export <path/to/filename>', summary: 'Exports a file to your local disk.', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log']},
                'backup': { usage: 'backup', summary: 'Backs up current user session to a local file.', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup']},
                'import': { usage: 'import', summary: 'Imports a user session from a local backup file.', syntax: 'import', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['import']},
                'wc': {  usage: 'wc [-l] [-w] [-c] <filename>', summary: 'Counts lines, words, and bytes in a file.', syntax: 'wc [OPTION]... [FILE]', details: 'Prints newline, word, and byte counts for the specified FILE. A word is a non-zero-length sequence of characters delimited by white space. With no OPTION, prints all three counts.\n  -c, --bytes         print the byte counts\n  -l, --lines         print the newline counts\n  -w, --words         print the word counts', examples: ['wc myfile.txt', 'wc -l story.txt', 'wc -w -c report.doc', 'wc -lwc data.csv']},
                'diff': { usage: 'diff <file1> <file2>', summary: 'Compares two files line by line.', syntax: 'diff FILE1 FILE2', details: 'Compares FILE1 and FILE2 line by line and outputs the differences. Common lines are prefixed with two spaces. Lines unique to FILE1 are prefixed with "< ". Lines unique to FILE2 are prefixed with "> ".', examples: ['diff old_version.txt new_version.txt', 'diff /config/main.conf /config/backup.conf']},
                'history': { usage: 'history', summary: 'Displays the command history.', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history']},
                'alias': { usage: 'alias [name[=value] ...]', summary: 'Define or display aliases.', syntax: 'alias [NAME[=VALUE]...]', details: '`alias` with no arguments prints the list of aliases in the form `name=\'value\'`.\n`alias name` prints the alias for `name`.\n`alias name=value` defines an alias. `value` can be a string containing commands. If `value` contains spaces, it should be quoted.\n`alias name=` unsets the alias `name`.', examples: ['alias', 'alias ll', "alias ll='ls -alF'", "alias mydocs='cd /home/user/documents'", "alias lsl="]},
                'unalias': { usage: 'unalias <name>', summary: 'Remove an alias.', syntax: 'unalias NAME', details: 'Removes the alias specified by NAME from the current user\'s alias list.', examples: ['unalias ll']}
            };
            
            async function handleLs(args) { /* ... same ... */ 
                const targetPathArg = args[0]; const validation = FileSystemManager.validatePath("ls", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true }); if (validation.error) return { success: false, error: validation.error }; const childrenNames = Object.keys(validation.node.children).sort(); if (childrenNames.length === 0) return { success: true, output: "Directory is empty." }; let outputLines = []; childrenNames.forEach(name => { const childNode = validation.node.children[name]; let line = name; if (childNode.type === 'directory') line += '/'; outputLines.push(line); }); return { success: true, output: outputLines.join('\n') };
            }
            async function handleCd(args) { /* ... same ... */ 
                const targetPathArg = args[0]; if (targetPathArg === undefined) return { success: false, error: "cd: missing operand\nUsage: cd <directory>" }; const validation = FileSystemManager.validatePath("cd", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; if (validation.resolvedPath === FileSystemManager.getCurrentPath()) return { success: true, output: `Already in '${validation.resolvedPath}'.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; FileSystemManager.setCurrentPath(validation.resolvedPath); TerminalUI.updatePrompt(); return { success: true, output: null };
            }
            async function handleMkdir(args) { /* ... same ... */ 
                const fullPathArg = args[0]; if (!fullPathArg) return { success: false, error: "mkdir: missing operand\nUsage: mkdir <directory_name>" }; if (fullPathArg === '.' || fullPathArg === '..') return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` }; const validation = FileSystemManager.validatePath("mkdir", fullPathArg, { allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error && validation.node && validation.node.type === 'file') return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` }; if (validation.error && validation.resolvedPath === '/') return { success: false, error: validation.error }; if (validation.error && !validation.node && !validation.allowMissing) return { success: false, error: validation.error }; const targetAbsPath = validation.resolvedPath; if (validation.node && validation.node.type === 'directory') return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.` , messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG}; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}'` }; const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` }; parentNode.children[dirToCreateName] = { type: 'directory', children: {} }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` }; return { success: true, output: `Directory '${fullPathArg}' created.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleTouch(args) { /* ... same ... */
                const fullPathArg = args[0]; if (!fullPathArg) return { success: false, error: "touch: missing file operand\nUsage: touch <filename>" }; if (fullPathArg.endsWith('/')) return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` }; const validation = FileSystemManager.validatePath("touch", fullPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const targetAbsPath = validation.resolvedPath; if (validation.node) return { success: true, output: `Timestamp of '${fullPathArg}' updated.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}'`}; const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); parentNode.children[newFileName] = { type: 'file', content: "" }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` }; return { success: true, output: `File '${fullPathArg}' created.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCat(args) { /* ... same ... */
                const targetPathArg = args[0]; if (!targetPathArg) return { success: false, error: "cat: missing file operand\nUsage: cat <filename>" }; const validation = FileSystemManager.validatePath("cat", targetPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; return { success: true, output: validation.node.content };
            }
            async function handleEcho(args) { /* ... same ... */
                let outputString = args.join(' '); if (outputString.length >= 2) { const firstChar = outputString[0], lastChar = outputString[outputString.length - 1]; if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) outputString = outputString.substring(1, outputString.length - 1); } return { success: true, output: outputString };
            }
            async function handleMv(args) { /* ... same ... */ 
                if (args.length < 2) return { success: false, error: "mv: missing source and/or destination operands" }; const sourcePathArg = args[0], destPathArg = args[1]; const sourceValidation = FileSystemManager.validatePath("mv", sourcePathArg, {disallowRoot: true, defaultToCurrentIfEmpty: false}); if (sourceValidation.error) return { success: false, error: sourceValidation.error }; const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation; const destValidation = FileSystemManager.validatePath("mv", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false }); if (destValidation.node && destValidation.node.type === 'file') return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` }; if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) return { success: false, error: destValidation.error }; let absDestPath = destValidation.resolvedPath; const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/'; const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1); const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath); if (!sourceParentNode || !sourceParentNode.children || !sourceParentNode.children[sourceName]) return { success: false, error: `mv: internal error: source '${sourceName}' not found in parent '${sourceParentPath}'` }; let finalDestParentNode, finalDestName; if (destValidation.node && destValidation.node.type === 'directory') { finalDestParentNode = destValidation.node; finalDestName = sourceName; absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath); } else { const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath); if(parentDirResult.error) return { success: false, error: `mv: ${parentDirResult.error}` }; finalDestParentNode = parentDirResult.parentNode; if (!finalDestParentNode) return { success: false, error: `mv: could not obtain parent for '${absDestPath}'`}; finalDestName = absDestPath.substring(absDestPath.lastIndexOf('/') + 1); } if (!finalDestName || finalDestName === "." || finalDestName === "..") return { success: false, error: `mv: invalid destination name '${finalDestName}'` }; if (absSourcePath === absDestPath) return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; if (finalDestParentNode.children[finalDestName]) return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destValidation.node ? destPathArg : absDestPath.substring(0, absDestPath.lastIndexOf('/')) || '/' }'.` }; if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one ofits subdirectories ('${destPathArg}')` }; finalDestParentNode.children[finalDestName] = sourceNode; delete sourceParentNode.children[sourceName]; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: "mv: failed to save filesystem changes." }; return { success: true, output: `Moved '${sourcePathArg}' to '${destPathArg}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCp(args) { /* ... same ... */ 
                if (args.length < 2) return { success: false, error: "cp: missing source and/or destination operands" }; const sourcePathArg = args[0], destPathArg = args[1]; const sourceValidation = FileSystemManager.validatePath("cp", sourcePathArg, {disallowRoot: false, defaultToCurrentIfEmpty: false}); if (sourceValidation.error) return { success: false, error: sourceValidation.error }; const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation; const destValidation = FileSystemManager.validatePath("cp", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false }); if (destValidation.node && destValidation.node.type === 'file') return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` }; if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) return { success: false, error: destValidation.error }; let absDestPath = destValidation.resolvedPath; const sourceName = absSourcePath === '/' ? 'root_copy' : absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1); let finalDestParentNode, finalDestName; if (destValidation.node && destValidation.node.type === 'directory') { finalDestParentNode = destValidation.node; finalDestName = sourceName; absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath); } else { const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath); if(parentDirResult.error) return { success: false, error: `cp: ${parentDirResult.error}` }; finalDestParentNode = parentDirResult.parentNode; if (!finalDestParentNode) return { success: false, error: `cp: could not obtain parent for '${absDestPath}'`}; finalDestName = absDestPath.substring(absDestPath.lastIndexOf('/') + 1); } if (!finalDestName || finalDestName === "." || finalDestName === "..") return { success: false, error: `cp: invalid destination name '${finalDestName}'` }; if (finalDestParentNode.children[finalDestName]) return { success: false, error: `cp: destination '${finalDestName}' already exists.` }; if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) return { success: false, error: `cp: cannot copy a directory into itself or one of its subdirectories.` }; const copiedNode = Utils.deepCopyNode(sourceNode); if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` }; finalDestParentNode.children[finalDestName] = copiedNode; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: "cp: failed to save filesystem changes." }; return { success: true, output: `Copied '${sourcePathArg}' to '${destPathArg}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            
            async function handleRm(args, cmdOptions = {}) {
                const { force = false } = cmdOptions; 
                let targetPathArg = args[0]; 
                let effectiveForce = force;
                const remainingArgs = [...args];
                let pathArgForValidation = targetPathArg;

                const forceFlagIndex = remainingArgs.findIndex(arg => arg === '-f' || arg === '--force');
                if (forceFlagIndex !== -1) {
                    effectiveForce = true;
                    remainingArgs.splice(forceFlagIndex, 1); 
                    pathArgForValidation = remainingArgs[0]; 
                }
                
                if (!pathArgForValidation) { 
                    return { success: false, error: "rm: missing operand\nUsage: rm [-f] <file_or_directory>" };
                }

                const validation = FileSystemManager.validatePath("rm", pathArgForValidation, { disallowRoot: true, defaultToCurrentIfEmpty: false });

                if (validation.error) {
                    if (effectiveForce && validation.error.includes("No such file or directory")) {
                        return { success: true, output: null }; 
                    }
                    return { success: false, error: validation.error };
                }
                
                const itemType = validation.node.type === 'directory' ? 'directory' : 'file';
                const dataForConfirm = { path: validation.resolvedPath, arg: pathArgForValidation, userName: UserManager.getCurrentUser().name };

                if (effectiveForce) { 
                    const parentPath = dataForConfirm.path.substring(0, dataForConfirm.path.lastIndexOf('/')) || '/';
                    const itemName = dataForConfirm.path.substring(dataForConfirm.path.lastIndexOf('/') + 1);
                    const parentNode = FileSystemManager.getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await FileSystemManager.save(dataForConfirm.userName)) {
                            return { success: false, error: `Error saving filesystem after force removing '${dataForConfirm.path}'.` };
                        } else {
                             return { success: true, output: `Forcibly removed '${pathArgForValidation}'.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; 
                        }
                    } else { 
                        return { success: false, error: `Error force removing '${dataForConfirm.path}': Item not found or parent changed.` };
                    }
                } else { 
                    ConfirmationManager.request(
                        [`Are you sure you want to remove ${itemType} '${pathArgForValidation}'? This action cannot be undone.`],
                        dataForConfirm,
                        async (data) => { 
                            const parentPath = data.path.substring(0, data.path.lastIndexOf('/')) || '/';
                            const itemName = data.path.substring(data.path.lastIndexOf('/') + 1);
                            const parentNode = FileSystemManager.getNodeByPath(parentPath);
                            if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                delete parentNode.children[itemName];
                                if(!await FileSystemManager.save(data.userName)) {
                                    OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'.`, true, Config.CSS_CLASSES.ERROR_MSG);
                                } else {
                                    OutputManager.appendToOutput(`'${data.path}' removed.`, false, Config.CSS_CLASSES.SUCCESS_MSG);
                                }
                            } else { 
                                OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, true, Config.CSS_CLASSES.ERROR_MSG);
                            }
                        },
                        (data) => { 
                            OutputManager.appendToOutput(`Removal of '${data.arg || 'item'}' cancelled.`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG);
                        }
                    );
                    return { success: true, output: null }; 
                }
            }

            async function handlePwd(args) { return { success: true, output: FileSystemManager.getCurrentPath() };}
            async function handleDate(args) { return { success: true, output: new Date().toString() };}
            async function handleWhoami(args) { return { success: true, output: UserManager.getCurrentUser().name };}
            async function handleGrep(args) { /* ... same ... */ 
                if (args.length < 2) return { success: false, error: "grep: usage: grep PATTERN FILE" }; const filePathArg = args[args.length - 1]; let pattern = args.slice(0, args.length - 1).join(' '); if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) pattern = pattern.substring(1, pattern.length - 1); if (!pattern) return { success: false, error: "grep: pattern cannot be empty" }; const validation = FileSystemManager.validatePath("grep", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || ""; const lines = fileContent.split('\n'); const matchingLines = lines.filter(line => line.includes(pattern)); return { success: true, output: matchingLines.length > 0 ? matchingLines.join('\n') : "" };
            }
            async function handleRun(args) { /* ... same ... */ 
                const scriptPathArg = args[0]; if (!scriptPathArg) return { success: false, error: "run: missing script file operand" }; const validation = FileSystemManager.validatePath("run", scriptPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const scriptContent = validation.node.content || ""; const scriptLines = scriptContent.split('\n'); OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); (async () => { for (let i = 0; i < scriptLines.length; i++) { const line = scriptLines[i], trimmedLine = line.trim(); if (trimmedLine === '' || trimmedLine.startsWith('#')) continue; const cmdResult = await processSingleCommand(trimmedLine, false); if (!cmdResult.success) { OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, true, Config.CSS_CLASSES.ERROR_MSG); if (cmdResult.error) OutputManager.appendToOutput(cmdResult.error, true, Config.CSS_CLASSES.ERROR_MSG); return; } } OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); })(); return { success: true, output: null }; 
            }
            async function handleSysmon(args) { /* ... same ... */ 
                const currentUser = UserManager.getCurrentUser(); const output = [ "** OopisOs System Monitor v6.9 - Sub-Etha Edition **", "----------------------------------------------------", `Registered User:    ${currentUser.name} (Probably you, unless you stole this login!)`, `OopisOs Version:    ${Config.OS.VERSION} (Now with more modules!)`, "", "==[ MAIN PROCESSOR UNIT (MPU) ]==", `  Type:             QualmCore 9001 (Modular Edition)`, `  Architecture:     Mostly Wishful Thinking with a Dash of RISC-y Business`, `  Conceptual Cores: 1 (It's trying its best, okay?)`, `  Clock Speed:      ~1 OopoHertz (Can reach 5 on a good day, with a tailwind)`, "", "==[ RANDOM ACCESS MUD (RAM) ]==",  `  Type:             DJHAR (Don't Jiggle; Highly Agitated Ram)`, `  Capacity:         640 KiloSegs (Should be enough for anyone, right?)`,  `  Current Load:     Probably too high. Did you try turning it off and on again?`, "", "==[ STORAGE (Probably Borrowed) ]==", `  Primary Drive:    The ol' IndexedDB Drive (Capacity: Browser's Whim)`, `  Space Used:       Enough to make you question your life choices.`, `  Space Free:       Less than you'd hope. Consider deleting 'that' folder.`, "", "==[ VISUAL DISPLAY UNIT (VDU) ]==", `  Model:            GreenScreen Deluxe (Now with 50 shades of green!)`, `  Resolution:       Optimistically Text-Mode`, `  Burn-in Status:   Impressive. You've been at this a while, huh?`, "----------------------------------------------------", "System Status:      'Nominally Operational'. (Whatever that means.)" ]; let styledOutput = ""; output.forEach(line => { const parts = line.split(':'); if (parts.length > 1 && line.trim().startsWith(parts[0].trim()))  styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.SYSMON_LABEL}">${parts[0].padEnd(20, ' ')}:</span><span>${parts.slice(1).join(':').trim()}</span></div>`; else styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">${line}</div>`; }); OutputManager.appendHtmlToOutput(styledOutput); return { success: true, output: null, isHtmlOutput: true };
            }
            async function handleSort(args) { /* ... same ... */ 
                const filePathArg = args[0]; if (!filePathArg) return { success: false, error: "sort: missing file operand" }; const validation = FileSystemManager.validatePath("sort", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || ""; if (fileContent.trim() === "") return { success: true, output: "" }; const lines = fileContent.split('\n'); lines.sort(); return { success: true, output: lines.join('\n') };
            }
            async function handleClear() { OutputManager.clearOutput(); return { success: true, output: null }; }
            async function handleSavestate() { /* ... same ... */ 
                const result = await SessionManager.saveManualState(); if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error || "Failed to save state." };
            }
            async function handleLoadstate() { /* ... same ... */ 
                const result = await SessionManager.loadManualState(); return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG };
            }
            async function handleReset() { /* ... same ... */ 
                ConfirmationManager.request( ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."], null, async () => { await SessionManager.performFullReset(); }, () => { OutputManager.appendToOutput("Reset cancelled.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); } ); return { success: true, output: null }; 
            }
            async function handleRegisterCmd(args) { /* ... same ... */ 
                if (args.length < 2) return { success: false, error: "Usage: register <username> <password>" }; const [username, password] = args; const result = await UserManager.register(username, password); if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error };
            }
            async function handleLoginCmd(args) { /* ... same ... */ 
                if (args.length < 2) return { success: false, error: "Usage: login <username> <password>" }; const [username, password] = args; TerminalUI.setPasswordInputActive(true, args[0].length + 1); const result = await UserManager.login(username, password); TerminalUI.setPasswordInputActive(false); if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error };
            }
            async function handleLogoutCmd() { /* ... same ... */ 
                const result = await UserManager.logout(); if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG }; else return { success: false, error: result.error || "Logout failed." };
            }
            async function handleHelp(args) { /* ... same ... */ 
                let outputLines = []; if (!args.length) { outputLines.push("Available commands (type 'help <command>' or 'man <command>'):"); const commandNames = Object.keys(commandRegistry).sort(); commandNames.forEach(cmdName => { const summary = commandHelpData[cmdName]?.summary || 'No summary available.'; outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`); }); } else { const commandName = args[0].toLowerCase(); const helpInfo = commandHelpData[commandName]; if (helpInfo) { outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`); outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`); outputLines.push(`  For more details, type: man ${commandName}`); } else return { success: false, error: `No help available for '${commandName}'. Try 'man ${commandName}'.` }; } return { success: true, output: outputLines.join('\n') };
            }
            async function handleMan(args) { /* ... same ... */ 
                function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");} if (args.length === 0) return { success: true, output: "What manual page do you want? (e.g., man ls)", messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG }; const commandName = args[0].toLowerCase(); const manData = commandHelpData[commandName]; if (manData) { let manOutputHtmlLines = []; manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">NAME</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">SYNOPSIS</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">DESCRIPTION</span></div>`); const detailLines = (manData.details || 'No detailed description available.').split('\n'); detailLines.forEach(line => { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`); }); if (manData.examples && manData.examples.length > 0) { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">EXAMPLES</span></div>`); manData.examples.forEach(example => { manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">        <span class="${Config.CSS_CLASSES.MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`); }); } manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); OutputManager.appendHtmlToOutput(manOutputHtmlLines.join('')); return { success: true, output: null, isHtmlOutput: true }; } else return { success: false, error: `No manual entry for ${commandName}` };
            }
            async function handleEditCmd(args) { /* ... same ... */ 
                if (EditorManager.isActive()) return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MESSAGE }; const targetPathArg = args[0]; if (!targetPathArg) return { success: false, error: "edit: missing file operand" }; if (targetPathArg.endsWith('/')) return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` }; const validation = FileSystemManager.validatePath("edit", targetPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const content = validation.node ? validation.node.content : ""; EditorManager.enter(validation.resolvedPath, content); return { success: true, output: null }; 
            }
            
            async function handleDiag(args) {
                isDiagActive = true; OutputManager.setDiagRunning(true);
                let passCount = 0, failCount = 0; window.diagInitializedForOutput = false; 
                const originalCurrentUser = UserManager.getCurrentUser(), originalFsData = Utils.deepCopyNode(FileSystemManager.getFsData()), originalCurrentPath = FileSystemManager.getCurrentPath();
                const originalUserCredentials = Utils.deepCopyNode(StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {})), originalOutputHTML = DOM.outputDiv.innerHTML, originalCommandHistory = HistoryManager.getFullHistory();
                
                const diagPrint = (message, typeClass = Config.CSS_CLASSES.DIAG_OUTPUT) => OutputManager.appendToOutput(message, false, typeClass);
                const report = (testName, success, details = "", expected = null, actual = null) => {
                    let detailStr = details;
                    if (!success && expected !== null && actual !== null) detailStr += ` (Expected: <${expected}>, Got: <${actual}>)`;
                    if (success) passCount++; else failCount++; 
                    diagPrint(`  ${success ? 'PASS' : 'FAIL'}: ${testName}${detailStr ? ` - ${detailStr}` : ''}`); 
                    return success; 
                };
                const createTestFile = async (filePath, content) => { const escapedContent = content.replace(/"/g, '\\"'); const echoResult = await processSingleCommand(`echo "${escapedContent}" > ${filePath}`, false); if (!echoResult.success) diagPrint(`  WARN: Failed to create test file ${filePath} for diag. Error: ${echoResult.error || 'Unknown error'}`); };
                
                OutputManager.clearOutput(); diagPrint("Starting OopisOs Diagnostics...", Config.CSS_CLASSES.DIAG_SECTION); diagPrint("-------------------------------");
                try { await IndexedDBManager.init(); } catch (e) { diagPrint("  CRITICAL: Diag cannot proceed, IndexedDB init failed."); isDiagActive = false; OutputManager.setDiagRunning(false); return {success: false, error: "Diag DB init failed"}; }
                
                const fsTestUser = "__diag_cmd_user__", fsTestBaseDir = "/tmp/__diag_cmd_tests__", diagUserPass = "diagTestPass123";
                let loginResult = await UserManager.login(fsTestUser, diagUserPass);
                if (!loginResult.success || loginResult.error === "Invalid username or password.") { await UserManager.register(fsTestUser, diagUserPass); loginResult = await UserManager.login(fsTestUser, diagUserPass); }
                if (!loginResult.success) { /* ... error handling ... */ diagPrint("  CRITICAL: Diag user setup failed."); isDiagActive = false; OutputManager.setDiagRunning(false); return { success: false, error: "Diag user setup failed." }; }
                
                await processSingleCommand(`rm ${fsTestBaseDir}`, false); 
                // No need to reset lastCommandFailed here, as handleRm now handles the benign "No such file" error silently when forced.

                await processSingleCommand(`mkdir ${fsTestBaseDir}`, false); await processSingleCommand(`cd ${fsTestBaseDir}`, false); 
                
                diagPrint("\nSECTION: Filesystem Path & Node Tests", Config.CSS_CLASSES.DIAG_SECTION);
                const pathTests = [ { name: "Current dir at root", target: '.', base: '/', expected: '/' }, { name: "Parent dir at root", target: '..', base: '/', expected: '/' }, { name: "Simple relative from root", target: 'foo', base: '/', expected: '/foo' }, { name: "Absolute target, ignore base", target: '/foo/bar', base: '/baz', expected: '/foo/bar' }, { name: "Relative .. from /foo/baz", target: '../bar', base: '/foo/baz', expected: '/foo/bar' }, { name: "Relative ../../ to root", target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar' }, { name: "Empty target (current dir)", target: '', base: '/foo', expected: '/foo' }, { name: "Trailing slash", target: 'dir/', base: '/foo', expected: '/foo/dir' }, { name: "Multiple slashes", target: '//a//b/', base: '/', expected: '/a/b' } ];
                pathTests.forEach(tc => { const actual = FileSystemManager.getAbsolutePath(tc.target, tc.base); report(tc.name, actual === tc.expected, "", String(tc.expected), String(actual)); });
                await createTestFile("testfile.txt", "content");
                let node = FileSystemManager.getNodeByPath("testfile.txt"); report("getNodeByPath existing file", node && node.type === 'file' && node.content === "content");
                node = FileSystemManager.getNodeByPath("nonexistent.txt"); report("getNodeByPath non-existent", node === null);
                let validation = FileSystemManager.validatePath("testcmd", "testfile.txt", {expectedType: 'file'}); report("validatePath existing file", validation.error === null && validation.node !== null);
                validation = FileSystemManager.validatePath("testcmd", "testfile.txt", {expectedType: 'directory'}); report("validatePath existing file as dir", validation.error !== null);
                validation = FileSystemManager.validatePath("testcmd", "newdir", {allowMissing: true}); report("validatePath non-existent allowMissing", validation.error === null && validation.node === null);

                diagPrint("\nSECTION: Alias Tests", Config.CSS_CLASSES.DIAG_SECTION);
                await processSingleCommand("alias myls='ls -l'", false);
                report("Alias creation", AliasManager.hasAlias("myls") && AliasManager.getAliases()["myls"] === "ls -l", "", "ls -l", AliasManager.getAliases()["myls"]);
                let expanded = await AliasManager.expand("myls /some/path"); report("Alias expansion", expanded === "ls -l /some/path", "", "ls -l /some/path", expanded);
                await processSingleCommand("unalias myls", false); report("Alias deletion", !AliasManager.hasAlias("myls"));

                diagPrint("\nSECTION: Redirection Tests", Config.CSS_CLASSES.DIAG_SECTION);
                await processSingleCommand("echo 'redirect test' > redir.txt", false);
                node = FileSystemManager.getNodeByPath("redir.txt"); report("Redirection overwrite (>)", node && node.content === "redirect test", "", "redirect test", node ? node.content : "null");
                await processSingleCommand("echo 'append test' >> redir.txt", false);
                node = FileSystemManager.getNodeByPath("redir.txt"); report("Redirection append (>>)", node && node.content === "redirect test\nappend test", "", "redirect test\nappend test", node ? node.content : "null");

                diagPrint("\nSECTION: File Content Commands (wc, head, tail, diff)", Config.CSS_CLASSES.DIAG_SECTION);
                const wcFile = "wc_test.txt", wcContent = "one two three\nfour five\n\nsix seven eight nine ten"; await createTestFile(wcFile, wcContent);
                let elWcDef = 4, elWcL = 3, ew = 10, eb = wcContent.length;
                let wcRes = await processSingleCommand(`wc ${wcFile}`, false); report("wc default", wcRes.success && wcRes.output && wcRes.output.trim() === `${String(elWcDef).padStart(7)} ${String(ew).padStart(7)} ${String(eb).padStart(7)} ${wcFile}`.trim(), "", `${String(elWcDef).padStart(7)} ${String(ew).padStart(7)} ${String(eb).padStart(7)} ${wcFile}`.trim(), wcRes.output ? wcRes.output.trim() : 'null');
                wcRes = await processSingleCommand(`wc -l ${wcFile}`, false); report("wc -l", wcRes.success && wcRes.output && wcRes.output.trim() === `${String(elWcL).padStart(7)} ${wcFile}`.trim(), "", `${String(elWcL).padStart(7)} ${wcFile}`.trim(), wcRes.output ? wcRes.output.trim() : 'null');

                const headTailContent = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\nLine 11\nLine 12";
                await createTestFile("ht_file.txt", headTailContent);
                await createTestFile("empty_file.txt", "");

                let htRes = await processSingleCommand("head ht_file.txt", false); report("head default (10 lines)", htRes.success && htRes.output === headTailContent.split('\n').slice(0,10).join('\n'));
                htRes = await processSingleCommand("head -n 3 ht_file.txt", false); report("head -n 3", htRes.success && htRes.output === "Line 1\nLine 2\nLine 3");
                htRes = await processSingleCommand("head -n 15 ht_file.txt", false); report("head -n 15 (more than lines)", htRes.success && htRes.output === headTailContent);
                htRes = await processSingleCommand("head empty_file.txt", false); report("head empty file", htRes.success && htRes.output === "");

                htRes = await processSingleCommand("tail ht_file.txt", false); report("tail default (10 lines)", htRes.success && htRes.output === headTailContent.split('\n').slice(2).join('\n')); 
                htRes = await processSingleCommand("tail -n 3 ht_file.txt", false); report("tail -n 3", htRes.success && htRes.output === "Line 10\nLine 11\nLine 12");
                htRes = await processSingleCommand("tail -n 15 ht_file.txt", false); report("tail -n 15 (more than lines)", htRes.success && htRes.output === headTailContent);
                htRes = await processSingleCommand("tail empty_file.txt", false); report("tail empty file", htRes.success && htRes.output === "");

                await createTestFile("diff1.txt", "apple\nbanana\ncherry");
                await createTestFile("diff2.txt", "apple\nbanana\ncherry");
                await createTestFile("diff3.txt", "apple\ndate\nbanana\ncherry");
                await createTestFile("diff4.txt", "apple\ncherry");
                await createTestFile("diff5.txt", "apple\nblueberry\ncherry");

                let diffRes = await processSingleCommand("diff diff1.txt diff2.txt", false); report("diff identical", diffRes.success && diffRes.output === "");
                diffRes = await processSingleCommand("diff diff1.txt diff3.txt", false); report("diff addition in file2", diffRes.success && diffRes.output === "> date", "", "> date", diffRes.output);
                diffRes = await processSingleCommand("diff diff1.txt diff4.txt", false); report("diff deletion in file2 (seen as removed from file1)", diffRes.success && diffRes.output === "< banana", "", "< banana", diffRes.output);
                diffRes = await processSingleCommand("diff diff1.txt diff5.txt", false); report("diff changed line", diffRes.success && diffRes.output === "< banana\n> blueberry", "", "< banana\n> blueberry", diffRes.output);
                
                await processSingleCommand(`cd /tmp`, false); 
                await processSingleCommand(`rm ${fsTestBaseDir.substring(fsTestBaseDir.lastIndexOf('/') + 1)}`, false); 
                
                UserManager.setCurrentUserObject(originalCurrentUser); StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, originalUserCredentials, "User creds"); 
                FileSystemManager.setFsData(originalFsData); await FileSystemManager.save(originalCurrentUser.name); FileSystemManager.setCurrentPath(originalCurrentPath);
                await AliasManager.load(originalCurrentUser.name); 
                diagPrint("\n-------------------------------"); diagPrint(`Diagnostics Complete: ${passCount} PASSED, ${failCount} FAILED.`); diagPrint("-------------------------------");
                const finalDiagReportHTML = DOM.outputDiv.innerHTML; DOM.outputDiv.innerHTML = originalOutputHTML; 
                const diagReportContainer = document.createElement('div'); diagReportContainer.innerHTML = finalDiagReportHTML; DOM.outputDiv.appendChild(diagReportContainer);
                HistoryManager.setHistory(originalCommandHistory); TerminalUI.updatePrompt(); TerminalUI.updateVisualInput(); TerminalUI.clearHiddenInput();
                setTimeout(() => { DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; }, 50);
                isDiagActive = false; OutputManager.setDiagRunning(false); window.diagInitializedForOutput = false; 
                return { success: true, output: null }; 
            }

            async function handleTree(args) { /* ... same ... */ 
                const targetPathArg = args[0]; const validation = FileSystemManager.validatePath("tree", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true }); if (validation.error) return { success: false, error: validation.error }; const outputLines = []; const startingDirName = validation.resolvedPath === '/' ? '/' : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || validation.resolvedPath; outputLines.push(startingDirName); function generateTreeLinesRecursive(directoryNode, prefix) { const childrenNames = Object.keys(directoryNode.children).sort(); childrenNames.forEach((name, index) => { const childNode = directoryNode.children[name]; const isLast = index === childrenNames.length - 1; const connector = isLast ? "└── " : "├── "; let line = prefix + connector + name; if (childNode.type === 'directory') line += "/"; outputLines.push(line); if (childNode.type === 'directory') { const newPrefix = prefix + (isLast ? "    " : "│   "); generateTreeLinesRecursive(childNode, newPrefix); } }); } generateTreeLinesRecursive(validation.node, ""); return { success: true, output: outputLines.join('\n') };
            }
            function matchPattern(name, pattern) { /* ... same ... */ 
                let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&'); regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.'); try { const regex = new RegExp(`^${regexPattern}$`); return regex.test(name); } catch (e) { throw new Error(`Invalid pattern regex: ${pattern}`); }
            }
            function findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) { /* ... same ... */ 
                if (!currentSearchNode || currentSearchNode.type !== 'directory') return; const childrenNames = Object.keys(currentSearchNode.children).sort(); for (const name of childrenNames) { const childNode = currentSearchNode.children[name]; const childFullPath = FileSystemManager.getAbsolutePath(name, currentSearchPath); if (matchPattern(name, pattern)) foundItems.push(childFullPath + (childNode.type === 'directory' ? '/' : '')); if (childNode.type === 'directory') findRecursive(childNode, childFullPath, pattern, foundItems); }
            }
            async function handleFind(args) { /* ... same ... */ 
                let searchPathArg = '.', pattern = null; const nameOptionIndex = args.indexOf('-name'); if (nameOptionIndex === -1) return { success: false, error: "find: usage: find [path] -name \"<pattern>\"" }; if (nameOptionIndex === 0) { searchPathArg = '.'; if (args.length < 2) return { success: false, error: "find: missing pattern after -name" }; pattern = args[1]; } else if (nameOptionIndex > 0) { searchPathArg = args.slice(0, nameOptionIndex).join(' '); if (nameOptionIndex + 1 >= args.length) return { success: false, error: "find: missing pattern after -name"}; pattern = args[nameOptionIndex + 1]; } else return { success: false, error: "find: invalid arguments for -name" }; if (pattern && pattern.length >= 2) { const firstChar = pattern[0], lastChar = pattern[pattern.length - 1]; if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) pattern = pattern.substring(1, pattern.length - 1); } if (!pattern) return { success: false, error: "find: pattern cannot be empty" }; const validation = FileSystemManager.validatePath("find", searchPathArg, {defaultToCurrentIfEmpty: true}); if(validation.error) return { success: false, error: validation.error }; const foundItems = []; try { if (validation.node.type === 'directory') findRecursive(validation.node, validation.resolvedPath, pattern, foundItems); else if (validation.node.type === 'file') { const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1); if (matchPattern(fileName, pattern)) foundItems.push(validation.resolvedPath); } } catch (e) { return { success: false, error: `find: ${e.message}` }; } return { success: true, output: foundItems.length > 0 ? foundItems.join('\n') : "" };
            }
            async function handleDu(args) { /* ... same ... */ 
                const outputLines = []; let pathsToProcess = args.length > 0 ? args : ['.']; for (const pathArg of pathsToProcess) { const validation = FileSystemManager.validatePath("du", pathArg, {defaultToCurrentIfEmpty: (args.length === 0)}); if (validation.error) { OutputManager.appendToOutput(validation.error, true, Config.CSS_CLASSES.ERROR_MSG); lastCommandFailed = true; continue; } const rawSize = FileSystemManager.calculateNodeSize(validation.node); const formattedSize = Utils.formatBytes(rawSize); let displayPath = pathArg; if (validation.node.type === 'directory' && pathArg === '.') displayPath = './'; else if (validation.node.type === 'directory' && !pathArg.endsWith('/') && pathArg !== '/') displayPath += '/'; outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`); } return { success: !lastCommandFailed, output: outputLines.join('\n') };
            }
            async function handleHead(args) { /* ... same ... */ 
                const defaultNumLines = 10, commandName = "head"; const options = Utils.parseNumericOption(args, "-n", defaultNumLines); let numLines = options.value, errorMessages = []; if (options.error) errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`); const filePathArg = options.remainingArgs[0]; if (!filePathArg && options.remainingArgs.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-n N] <filename>` }; if (options.remainingArgs.length > 1) return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` }; const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || "", lines = fileContent.split('\n'), outputLines = lines.slice(0, numLines); const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n'); const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null; return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleTail(args) { /* ... same ... */ 
                const defaultNumLines = 10, commandName = "tail"; const options = Utils.parseNumericOption(args, "-n", defaultNumLines); let numLines = options.value, errorMessages = []; if (options.error) errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`); const filePathArg = options.remainingArgs[0]; if (!filePathArg && options.remainingArgs.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-n N] <filename>` }; if (options.remainingArgs.length > 1) return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` }; const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileContent = validation.node.content || "", lines = fileContent.split('\n'), outputLines = lines.slice(Math.max(0, lines.length - numLines)); const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n'); const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null; return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleExport(args) { /* ... same ... */ 
                const filePathArg = args[0]; if (!filePathArg) return { success: false, error: "export: missing file operand" }; const validation = FileSystemManager.validatePath("export", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) return { success: false, error: validation.error }; const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || 'downloaded_file.txt', fileContent = validation.node.content || "", mimeType = "text/plain"; try { const blob = new Blob([fileContent], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); return { success: true, output: `Exporting '${fileName}'... Check your browser downloads.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } catch (error) { console.error("Export failed:", error); return { success: false, error: `Error exporting file '${fileName}': ${error.message}` }; }
            }
            async function handleBackup(args) { /* ... same ... */ 
                const currentUser = UserManager.getCurrentUser(); const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14); const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`; const backupData = { backupVersion: "1.0", osVersion: Config.OS.VERSION, user: currentUser.name, timestamp: new Date().toISOString(), filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()), currentPath: FileSystemManager.getCurrentPath(), commandHistory: HistoryManager.getFullHistory() }; try { const jsonString = JSON.stringify(backupData, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = backupFileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); return { success: true, output: `Creating backup '${backupFileName}'... Check your browser downloads.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } catch (error) { console.error("Backup failed:", error); return { success: false, error: `Error creating backup: ${error.message}` }; }
            }
            async function handleImport(args) { /* ... same ... */ 
                const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.json'; return new Promise((resolveCommand) => { fileInput.onchange = async (event) => { const file = event.target.files[0]; if (!file) { OutputManager.appendToOutput("Import cancelled: No file selected.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); resolveCommand({ success: true, output: null }); return; } const reader = new FileReader(); reader.onload = async (e) => { try { const fileContent = e.target.result; const parsedData = JSON.parse(fileContent); if (typeof parsedData !== 'object' || parsedData === null || !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') || !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') || !parsedData.hasOwnProperty('backupVersion')) { OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", true, Config.CSS_CLASSES.ERROR_MSG); resolveCommand({ success: false, error: "Invalid backup file." }); return; } if (parsedData.backupVersion !== "1.0") OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, false, Config.CSS_CLASSES.WARNING_MSG); const dataForConfirm = { parsedData: parsedData, fileName: file.name }; ConfirmationManager.request( [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`], dataForConfirm, async (data) => { const importedUser = data.parsedData.user; const currentActiveUser = UserManager.getCurrentUser(); if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser && !isDiagActive) SessionManager.saveAutomaticState(currentActiveUser.name); UserManager.setCurrentUserObject({ name: importedUser, credentials: StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}) }); FileSystemManager.setFsData(Utils.deepCopyNode(data.parsedData.filesystem) || { '/': { type: 'directory', children: {} } }); FileSystemManager.setCurrentPath(data.parsedData.currentPath || '/'); HistoryManager.setHistory(data.parsedData.commandHistory || []); OutputManager.clearOutput(); TerminalUI.clearHiddenInput(); await FileSystemManager.save(importedUser); await AliasManager.load(importedUser); const userCredentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}); if (!userCredentials[importedUser] && importedUser !== Config.USER.DEFAULT_NAME) OutputManager.appendToOutput(`Warning: User '${importedUser}' from backup does not have credentials. Session restored, but login for this user is not possible without registering.`, false, Config.CSS_CLASSES.WARNING_MSG); OutputManager.appendToOutput(`Session for user '${importedUser}' successfully imported and restored from '${data.fileName}'.`, false, Config.CSS_CLASSES.SUCCESS_MSG); TerminalUI.updateVisualInput(); TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; resolveCommand({ success: true, output: null}); }, () => { OutputManager.appendToOutput("Import cancelled.", false, Config.CSS_CLASSES.CONSOLE_LOG_MSG); resolveCommand({ success: true, output: null}); } ); } catch (parseError) { console.error("Import error - parsing JSON:", parseError); OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", true, Config.CSS_CLASSES.ERROR_MSG); resolveCommand({ success: false, error: "Could not parse backup file."}); } }; reader.onerror = (e) => { console.error("Import error - reading file:", e); OutputManager.appendToOutput("Error: Could not read the selected file.", true, Config.CSS_CLASSES.ERROR_MSG); resolveCommand({ success: false, error: "Could not read file."}); }; reader.readAsText(file); }; fileInput.click(); }); 
            }
            async function handleWc(args) { /* ... same ... */ 
                const commandName = "wc"; let showLines = false, showWords = false, showBytes = false, optionsSpecified = false; const tempArgs = [...args], filesToProcess = []; while (tempArgs.length > 0 && tempArgs[0].startsWith('-')) { const option = tempArgs.shift(); optionsSpecified = true; for (const char of option.substring(1)) { switch (char) { case 'l': showLines = true; break; case 'w': showWords = true; break; case 'c': showBytes = true; break; default: return { success: false, error: `${commandName}: invalid option -- '${char}'\nUsage: ${commandName} [-lwc] [file...]` }; } } } filesToProcess.push(...tempArgs); if (filesToProcess.length === 0) return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandName} [-lwc] [file...]` }; const defaultAll = !optionsSpecified; let totalLines = 0, totalWords = 0, totalBytes = 0; const outputResults = []; let anyFileFailed = false; for (const filePathArg of filesToProcess) { const validation = FileSystemManager.validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation.error) { OutputManager.appendToOutput(validation.error, true, Config.CSS_CLASSES.ERROR_MSG); anyFileFailed = true; continue; } const fileContent = validation.node.content || ""; let lineCountForDisplay; const newlineOnlyCount = (fileContent.match(/\n/g) || []).length; if (fileContent === "") lineCountForDisplay = 0; else if (showLines && optionsSpecified) lineCountForDisplay = newlineOnlyCount; else { lineCountForDisplay = newlineOnlyCount; if (fileContent.length > 0 && !fileContent.endsWith('\n')) lineCountForDisplay++; } const words = fileContent.trim() === "" ? 0 : fileContent.trim().split(/\s+/).filter(Boolean).length; const bytes = fileContent.length; totalLines += lineCountForDisplay; totalWords += words; totalBytes += bytes; let resultLine = ""; if (showLines || defaultAll) resultLine += `${String(lineCountForDisplay).padStart(7)} `; if (showWords || defaultAll) resultLine += `${String(words).padStart(7)} `; if (showBytes || defaultAll) resultLine += `${String(bytes).padStart(7)} `; resultLine += filePathArg; outputResults.push(resultLine); } if (filesToProcess.length > 1 && !anyFileFailed) { let totalLineStr = ""; if (showLines || defaultAll) totalLineStr += `${String(totalLines).padStart(7)} `; if (showWords || defaultAll) totalLineStr += `${String(totalWords).padStart(7)} `; if (showBytes || defaultAll) totalLineStr += `${String(totalBytes).padStart(7)} `; totalLineStr += "total"; outputResults.push(totalLineStr); } return { success: !anyFileFailed, output: outputResults.join('\n') };
            }
            async function handleDiff(args) { /* ... same ... */ 
                const commandName = "diff"; if (args.length !== 2) return { success: false, error: `${commandName}: missing operand. Requires two file arguments.\nUsage: ${commandName} <file1> <file2>` }; const file1PathArg = args[0], file2PathArg = args[1]; const validation1 = FileSystemManager.validatePath(commandName, file1PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation1.error) return { success: false, error: validation1.error }; const validation2 = FileSystemManager.validatePath(commandName, file2PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false }); if (validation2.error) return { success: false, error: validation2.error }; const lines1 = (validation1.node.content || "").split('\n'), lines2 = (validation2.node.content || "").split('\n'); const lcsArray = Utils.findLCS(lines1, lines2); let ptr1 = 0, ptr2 = 0, ptrLcs = 0; const diffOutput = []; let differencesFound = false; while (ptr1 < lines1.length || ptr2 < lines2.length) { const line1Exists = ptr1 < lines1.length, line2Exists = ptr2 < lines2.length, lcsExists = ptrLcs < lcsArray.length; if (lcsExists && line1Exists && lines1[ptr1] === lcsArray[ptrLcs] && line2Exists && lines2[ptr2] === lcsArray[ptrLcs]) { ptr1++; ptr2++; ptrLcs++; } else { differencesFound = true; if (line1Exists && (!lcsExists || lines1[ptr1] !== lcsArray[ptrLcs])) { if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) { diffOutput.push(`< ${lines1[ptr1]}`); diffOutput.push(`> ${lines2[ptr2]}`); ptr1++; ptr2++; } else { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; } } else if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; } else { if (ptr1 < lines1.length) { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; } else if (ptr2 < lines2.length) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; } else break; } } } return { success: true, output: differencesFound ? diffOutput.join('\n') : "" };
            }
            async function handleHistoryCmd(args) { /* ... same ... */ 
                const history = HistoryManager.getFullHistory(); if (history.length === 0) return { success: true, output: "No commands in history." }; return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') };
            }
            async function handleAliasCmd(args) { /* ... same ... */ 
                const commandName = "alias", currentUser = UserManager.getCurrentUser().name; if (args.length === 0) { const aliases = AliasManager.getAliases(); if (Object.keys(aliases).length === 0) return { success: true, output: "No aliases defined." }; const output = []; for (const name in aliases) { let value = aliases[name]; if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) value = `'${value.replace(/'/g, "'\\''")}'`; output.push(`${name}=${value}`); } return { success: true, output: output.join('\n') }; } const firstArg = args.join(" "), assignmentIndex = firstArg.indexOf('='); if (assignmentIndex === -1) { const aliasName = args[0]; if (AliasManager.hasAlias(aliasName)) { let value = AliasManager.getAliases()[aliasName]; if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) value = `'${value.replace(/'/g, "'\\''")}'`; return { success: true, output: `alias ${aliasName}=${value}` }; } else return { success: false, error: `${commandName}: ${aliasName}: not found` }; } else { const aliasName = firstArg.substring(0, assignmentIndex).trim(); let commandString = firstArg.substring(assignmentIndex + 1).trim(); if (!aliasName) return { success: false, error: `${commandName}: invalid alias name.` }; if (aliasName.includes(" ")) return { success: false, error: `${commandName}: alias name cannot contain spaces.` }; if (commandRegistry.hasOwnProperty(aliasName) && aliasName !== "alias" && aliasName !== "unalias") return { success: false, error: `${commandName}: '${aliasName}' is a built-in command. Cannot create alias.` }; if (commandString === "") { if (AliasManager.hasAlias(aliasName)) { AliasManager.removeAlias(aliasName); await AliasManager.save(currentUser); return { success: true, output: `${aliasName} alias unset.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } return { success: true, output: null }; } if ((commandString.startsWith("'") && commandString.endsWith("'")) || (commandString.startsWith('"') && commandString.endsWith('"'))) commandString = commandString.substring(1, commandString.length - 1); if (aliasName === commandString.split(' ')[0]) return { success: false, error: `${commandName}: cannot alias '${aliasName}' to itself directly.` }; AliasManager.setAlias(aliasName, commandString); await AliasManager.save(currentUser); return { success: true, output: `Alias '${aliasName}' set.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; }
            }
            async function handleUnaliasCmd(args) { /* ... same ... */ 
                const commandName = "unalias", currentUser = UserManager.getCurrentUser().name; if (args.length !== 1) return { success: false, error: `${commandName}: usage: unalias <name>` }; const aliasName = args[0]; if (AliasManager.hasAlias(aliasName)) { AliasManager.removeAlias(aliasName); await AliasManager.save(currentUser); return { success: true, output: `Alias '${aliasName}' removed.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG }; } else return { success: false, error: `${commandName}: ${aliasName}: not found` };
            }

            const commandRegistry = {
                'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch, 'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd, 'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep, 'sort': handleSort, 'sysmon': handleSysmon, 'mv': handleMv, 'cp': handleCp, 'clear': handleClear, 'register': handleRegisterCmd, 'login': handleLoginCmd, 'logout': handleLogoutCmd, 'savestate': handleSavestate, 'loadstate': handleLoadstate, 'reset': handleReset, 'help': handleHelp, 'man': handleMan, 'edit': handleEditCmd, 'diag': handleDiag, 'tree': handleTree, 'find': handleFind, 'du': handleDu, 'head': handleHead, 'tail': handleTail, 'export': handleExport, 'backup': handleBackup, 'import': handleImport, 'wc': handleWc, 'diff': handleDiff, 'history': handleHistoryCmd, 'alias': handleAliasCmd, 'unalias': handleUnaliasCmd
            };
            
            function parseInput(commandInputText) { /* ... same ... */ 
                let commandToExecute = commandInputText, redirectionType = null, redirectionFile = null; const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/); if (appendMatch) { redirectionType = 'append'; redirectionFile = appendMatch[1]; commandToExecute = commandToExecute.substring(0, appendMatch.index).trim(); } else { const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/); if (overwriteMatch) { redirectionType = 'overwrite'; redirectionFile = overwriteMatch[1]; commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim(); } } const parts = commandToExecute.split(' ').filter(p => p); const baseCommand = parts[0] ? parts[0].toLowerCase() : ''; let args; if (baseCommand === 'alias' && commandToExecute.includes('=')) args = [commandToExecute.substring(baseCommand.length).trimStart()]; else args = parts.slice(1); return { baseCommand, args, redirection: redirectionType ? { type: redirectionType, file: redirectionFile } : null, originalFullCommand: commandInputText };
            }
            async function handleRedirection(commandName, commandOutputContent, redirection) { /* ... same ... */ 
                if (!redirection || !redirection.file) return { success: false, error: `${commandName}: internal error: redirection file not specified.` }; const validation = FileSystemManager.validatePath(commandName, redirection.file, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false }); if (validation.error) { if (validation.node && validation.node.type === 'directory') return { success: false, error: `${commandName}: cannot redirect to '${redirection.file}': It is a directory.` }; else return { success: false, error: validation.error }; } const targetAbsPath = validation.resolvedPath; const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath); if (parentDirResult.error) return { success: false, error: `${commandName}: ${parentDirResult.error}` }; const parentNode = parentDirResult.parentNode; if (!parentNode) return { success: false, error: `${commandName}: error obtaining parent directory for redirection target '${redirection.file}'.` }; const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1); const targetNode = parentNode.children[newFileName]; let contentToWrite = (commandOutputContent !== null && commandOutputContent !== undefined) ? String(commandOutputContent) : ""; if (redirection.type === 'overwrite' || !targetNode) parentNode.children[newFileName] = { type: 'file', content: contentToWrite }; else if (redirection.type === 'append' && targetNode.type === 'file') { const existingContent = targetNode.content || ""; const separator = (existingContent && contentToWrite) ? "\n" : ""; parentNode.children[newFileName].content = existingContent + separator + contentToWrite; } else return { success: false, error: `${commandName}: cannot write to '${redirection.file}': Unexpected target type or situation.` }; if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) return { success: false, error: `${commandName}: failed to save redirected output to '${redirection.file}'.` }; return { success: true }; 
            }

            async function processSingleCommand(commandInputText, isInteractive = true) {
                lastCommandFailed = false; 
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false };
                if (EditorManager.isActive() && !isDiagActive) return finalResult; 
                if (ConfirmationManager.isAwaiting()) { await ConfirmationManager.handleConfirmation(commandInputText); return finalResult; }
                const expandedCommandText = await AliasManager.expand(commandInputText.trim());
                const parsedInput = parseInput(expandedCommandText); 
                if (isInteractive && !isDiagActive) {
                    let displayCommand = commandInputText.trim(); 
                    const passInfo = TerminalUI.getPasswordInputActive();
                    if (passInfo.isActive && passInfo.startIndex !== -1 && displayCommand.length > passInfo.startIndex) { const prefix = displayCommand.substring(0, passInfo.startIndex), suffixToMask = displayCommand.substring(passInfo.startIndex); displayCommand = prefix + '*'.repeat(suffixToMask.length); }
                    const promptText = `${DOM.promptUserSpan.textContent}@${DOM.promptHostSpan.textContent}:${DOM.promptPathSpan.textContent}> `;
                    OutputManager.appendToOutput(`${promptText}${displayCommand}`);
                    if (commandInputText.trim() !== expandedCommandText) OutputManager.appendToOutput(`> ${expandedCommandText}`, false, Config.CSS_CLASSES.CONSOLE_LOG_MSG);
                } else if (!isInteractive && !isDiagActive && expandedCommandText) OutputManager.appendToOutput(`> ${expandedCommandText}`);
                if (isInteractive && commandInputText.trim()) HistoryManager.add(commandInputText.trim()); 
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) HistoryManager.resetIndex();
                if (parsedInput.baseCommand === '') { if (isInteractive && !isDiagActive) TerminalUI.clearHiddenInput(); return finalResult; }

                const handler = commandRegistry[parsedInput.baseCommand];
                if (handler) {
                    try {
                        let cmdResult;
                        const cmdOptions = {
                            force: (parsedInput.baseCommand === 'rm' && !isInteractive) || 
                                   (parsedInput.args.includes('-f') || parsedInput.args.includes('--force'))
                        };
                        cmdResult = await handler(parsedInput.args, cmdOptions);
                        
                        finalResult = { ...finalResult, ...cmdResult }; 

                        if (!finalResult.success && finalResult.error) { 
                            if (!isDiagActive) OutputManager.appendToOutput(finalResult.error, true, Config.CSS_CLASSES.ERROR_MSG);
                            else OutputManager.appendToOutput(`  ERROR in '${parsedInput.baseCommand}': ${finalResult.error}`, true, Config.CSS_CLASSES.DIAG_OUTPUT);
                            lastCommandFailed = true; 
                        }
                        
                        if (finalResult.output !== null && finalResult.output !== undefined) {
                            if (parsedInput.redirection) {
                                const redirResult = await handleRedirection(parsedInput.baseCommand, finalResult.output, parsedInput.redirection);
                                if (!redirResult.success) { OutputManager.appendToOutput(redirResult.error, true, Config.CSS_CLASSES.ERROR_MSG); lastCommandFailed = true; finalResult.success = false; }
                            } else if (!finalResult.isHtmlOutput && (!isDiagActive || (isDiagActive && finalResult.messageType === Config.CSS_CLASSES.DIAG_OUTPUT))) { 
                                if (isInteractive || finalResult.messageType) { 
                                    const lines = String(finalResult.output).split('\n');
                                    lines.forEach(line => { 
                                        let typeClass = finalResult.messageType || null;
                                        if (parsedInput.baseCommand === 'ls' && line.endsWith('/')) typeClass = Config.CSS_CLASSES.DIR_ITEM;
                                        if (isDiagActive && !typeClass) typeClass = Config.CSS_CLASSES.DIAG_OUTPUT; 
                                        OutputManager.appendToOutput(line, !finalResult.success && !typeClass && !finalResult.messageType, typeClass); 
                                    });
                                }
                            } 
                        }
                        if (lastCommandFailed) finalResult.success = false;
                    } catch (e) {
                        console.error(`Critical error in '${parsedInput.baseCommand}':`, e);
                        const errorMsg = `Unexpected critical error executing '${parsedInput.baseCommand}'. Check console.`;
                        if (!isDiagActive) OutputManager.appendToOutput(errorMsg, true, Config.CSS_CLASSES.ERROR_MSG);
                        else OutputManager.appendToOutput(`  CRITICAL ERROR in '${parsedInput.baseCommand}': ${e.message}`, true, Config.CSS_CLASSES.DIAG_OUTPUT);
                        finalResult.success = false; lastCommandFailed = true;
                    }
                } else { 
                    const errorMsg = `Error: Command not found: "${parsedInput.baseCommand}"`;
                    if (!isDiagActive) OutputManager.appendToOutput(errorMsg, true, Config.CSS_CLASSES.ERROR_MSG);
                    else OutputManager.appendToOutput(`  ERROR: Command not found: "${parsedInput.baseCommand}"`, true, Config.CSS_CLASSES.DIAG_OUTPUT);
                    finalResult.success = false; lastCommandFailed = true;
                }
                if (isInteractive && !isDiagActive) { TerminalUI.clearHiddenInput(); TerminalUI.setPasswordInputActive(false); TerminalUI.updatePrompt(); }
                return finalResult;
            }
            function getIsDiagActive() { return isDiagActive; }
            function getLastCommandFailed() { return lastCommandFailed; } 
            return { processSingleCommand, isDiagActive: getIsDiagActive, getLastCommandFailed };
        })();

        // --- GLOBAL EVENT LISTENERS & INITIALIZATION ---
        DOM.terminalDiv.addEventListener('click', e => { /* ... same as before ... */ 
            if (EditorManager.isActive()) { const editorWrapper = EditorManager.getEditorWrapperDiv(); if (editorWrapper && editorWrapper.contains(e.target) && e.target !== EditorManager.getEditorTextarea()) EditorManager.focusEditor(); return; }
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A' && !e.target.closest('#visual-input-container')) DOM.hiddenInput.focus();
            if (e.target.closest('.input-line') || e.target.id === 'terminal') DOM.hiddenInput.focus();
        });
        DOM.hiddenInput.addEventListener('keydown', async e => { /* ... same as before ... */ 
            if (EditorManager.isActive()) { e.preventDefault(); return; } 
            TerminalUI.setIsNavigatingHistory(false); 
            if (e.key === 'Enter') { e.preventDefault(); await CommandExecutor.processSingleCommand(DOM.hiddenInput.value, true); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); const prevCommand = HistoryManager.getPrevious(); if (prevCommand !== null) { TerminalUI.setIsNavigatingHistory(true); TerminalUI.setHiddenInputValue(prevCommand, true); } }
            else if (e.key === 'ArrowDown') { e.preventDefault(); const nextCommand = HistoryManager.getNext(); if (nextCommand !== null) { TerminalUI.setIsNavigatingHistory(true); TerminalUI.setHiddenInputValue(nextCommand, true); } }
            else if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'Backspace', 'Delete'].includes(e.key)) setTimeout(() => DOM.hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })), 0);
        });
        DOM.hiddenInput.addEventListener('input', (event) => { /* ... same as before ... */ 
            if (EditorManager.isActive()) return;
            const rawInput = DOM.hiddenInput.value; TerminalUI.setPasswordInputActive(false); 
            const passwordCommandRegex = /^(login|register)(\s+)(\S+)(\s+)(.*)$/i; const match = rawInput.match(passwordCommandRegex);
            if (match) { const commandPart = match[1], spaceAfterCommand = match[2], usernamePart = match[3], spaceAfterUsername = match[4]; TerminalUI.setPasswordInputActive(true, commandPart.length + spaceAfterCommand.length + usernamePart.length + spaceAfterUsername.length); }
            else { const prefixRegex = /^(login|register)(\s+)(\S+)$/i; const prefixMatch = rawInput.match(prefixRegex); if (prefixMatch && rawInput.endsWith(' ')) TerminalUI.setPasswordInputActive(true, rawInput.length); }
            TerminalUI.updateVisualInput();
            if (!TerminalUI.getIsNavigatingHistory()) HistoryManager.resetIndex();
        });
        
        window.diagInitializedForOutput = false; 
        window.onload = async () => { /* ... same as before ... */ 
            OutputManager.appendToOutput("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.", false, Config.CSS_CLASSES.WARNING_MSG);
            try {
                await IndexedDBManager.init();
                const guestUser = { name: UserManager.getDefaultUser(), credentials: {} }; UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.load(UserManager.getDefaultUser()); await AliasManager.load(UserManager.getDefaultUser());
                SessionManager.loadAutomaticState(UserManager.getDefaultUser()); 
                setTimeout(() => { if (!EditorManager.isActive()) DOM.hiddenInput.focus(); }, 100);
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                OutputManager.appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details.", true, Config.CSS_CLASSES.ERROR_MSG);
                DOM.hiddenInput.disabled = true;
            }
        };
    </script>
</body>
</html>
