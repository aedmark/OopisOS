<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 0.7.0 - Lexer/Parser Implementation</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
            line-height: 1.2em;
        }

        .input-line-container {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }
        .prompt-container {
            display: flex;
            align-items: center;
            line-height: 1.2em;
            flex-shrink: 0;
            white-space: nowrap;
            padding-top: 0.1em;
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container {
            flex-grow: 1;
            min-width: 0;
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            outline: none;
            caret-color: #00ff00;
            color: #00ff00;
            width: 100%;
        }
        
        #hidden-legacy-input {
             position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;
        }

        .error-message { color: #ff4136; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .console-log-message { color: #aaaaaa; }
        .editor-message { color: #7fdbff; }
        
        .directory-item { color: #7fdbff; }
        .file-item { color: #00ff00; }

        .help-command-name { color: #7fdbff; font-weight: bold; }
        .help-description { margin-left: 10px; }
        .man-section-title { color: #7fdbff; font-weight: bold; }
        .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }

        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; }
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        #editor-textarea-wrapper { border-right: 1px solid #333; }
        #editor-textarea { width: 100%; height: 100%; background-color: #0c0c0c; color: #00dd00; border: none; font-family: 'VT323', monospace; font-size: 1em; line-height: 1.2em; resize: none; outline: none; padding: 0; }
        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre > code { display: block; padding: 10px; overflow-x: auto; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }
        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            <input type="text" id="hidden-legacy-input" style="position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;">
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const Config = (() => {
            'use strict';
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore"
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "0.7.0", // Updated version for Lexer/Parser
                    DEFAULT_HOST_NAME: "OopisOs"
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                    RESERVED_USERNAMES: ["guest"]
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    PROMPT_CHAR: ">",
                    PROMPT_SEPARATOR: ":",
                    PROMPT_AT: "@"
                },
                STORAGE_KEYS: {
                    USER_CREDENTIALS: 'oopisOsUserCredentials',
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                },
                CSS_CLASSES: {
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    EDITOR_MSG: 'editor-message',
                    DIR_ITEM: 'directory-item',
                    FILE_ITEM: 'file-item',
                    HELP_CMD_NAME: 'help-command-name',
                    HELP_DESC: 'help-description',
                    OUTPUT_LINE: 'output-line',
                    MAN_SECTION_TITLE: 'man-section-title',
                    MAN_SECTION_CONTENT: 'man-section-content',
                    MAN_EXAMPLE: 'man-example'
                },
                EDITOR: {
                    DEBOUNCE_DELAY_MS: 250,
                    TAB_REPLACEMENT: "\t", 
                    CTRL_S_ACTION: 'save_exit',
                    CTRL_O_ACTION: 'exit_no_save',
                    CTRL_P_ACTION: 'toggle_preview',
                    DEFAULT_MODE: 'text',
                    MODES: {
                        TEXT: 'text',
                        MARKDOWN: 'markdown',
                        HTML: 'html'
                    },
                    EXTENSIONS_MAP: {
                        'md': 'markdown',
                        'html': 'html',
                        'htm': 'html',
                        'sh': 'text' 
                    },
                    VIEW_MODES: {
                        SPLIT: 'split',
                        EDIT_ONLY: 'edit',
                        PREVIEW_ONLY: 'preview'
                    }
                },
                FILESYSTEM: {
                    ROOT_PATH: '/',
                    CURRENT_DIR_SYMBOL: '.',
                    PARENT_DIR_SYMBOL: '..',
                    DEFAULT_DIRECTORY_TYPE: 'directory',
                    DEFAULT_FILE_TYPE: 'file',
                    PATH_SEPARATOR: '/'
                },
                MESSAGES: {
                    CONFIRMATION_PROMPT: "Type 'YES' (all caps) to confirm, or any other input to cancel.",
                    OPERATION_CANCELLED: "Operation cancelled.",
                    ALREADY_LOGGED_IN_AS_PREFIX: "Already logged in as '",
                    ALREADY_LOGGED_IN_AS_SUFFIX: "'.",
                    NO_ACTION_TAKEN: "No action taken.",
                    ALREADY_IN_DIRECTORY_PREFIX: "Already in '",
                    ALREADY_IN_DIRECTORY_SUFFIX: "'.",
                    DIRECTORY_EMPTY: "Directory is empty.",
                    TIMESTAMP_UPDATED_PREFIX: "Timestamp of '",
                    TIMESTAMP_UPDATED_SUFFIX: "' updated.",
                    FILE_CREATED_SUFFIX: "' created.",
                    DIRECTORY_CREATED_SUFFIX: "' created.",
                    ITEM_REMOVED_SUFFIX: "' removed.",
                    FORCIBLY_REMOVED_PREFIX: "Forcibly removed '",
                    FORCIBLY_REMOVED_SUFFIX: "'.",
                    REMOVAL_CANCELLED_PREFIX: "Removal of '",
                    REMOVAL_CANCELLED_SUFFIX: "' cancelled.",
                    MOVED_PREFIX: "Moved '",
                    MOVED_TO: "' to '",
                    MOVED_SUFFIX: "'.",
                    COPIED_PREFIX: "Copied '",
                    COPIED_TO: "' to '",
                    COPIED_SUFFIX: "'.",
                    SESSION_SAVED_FOR_PREFIX: "Session manually saved for ",
                    SESSION_LOADED_MSG: "Session loaded from manual save.",
                    LOAD_STATE_CANCELLED: "Load state cancelled.",
                    NO_MANUAL_SAVE_FOUND_PREFIX: "No manually saved state found for ",
                    WELCOME_PREFIX: "Welcome, ",
                    WELCOME_SUFFIX: "! Type 'help' for commands.",
                    EXPORTING_PREFIX: "Exporting '",
                    EXPORTING_SUFFIX: "'... Check your browser downloads.",
                    BACKUP_CREATING_PREFIX: "Creating backup '",
                    BACKUP_CREATING_SUFFIX: "'... Check your browser downloads.",
                    RESTORE_CANCELLED_NO_FILE: "Restore cancelled: No file selected.",
                    RESTORE_SUCCESS_PREFIX: "Session for user '",
                    RESTORE_SUCCESS_MIDDLE: "' successfully restored from '",
                    RESTORE_SUCCESS_SUFFIX: "'.",
                    UPLOAD_NO_FILE: "Upload cancelled: No file selected.",
                    UPLOAD_INVALID_TYPE_PREFIX: "Error: Invalid file type '",
                    UPLOAD_INVALID_TYPE_SUFFIX: "'. Only .txt, .md, .html, .sh files are allowed.", 
                    UPLOAD_SUCCESS_PREFIX: "File '",
                    UPLOAD_SUCCESS_MIDDLE: "' uploaded successfully to '",
                    UPLOAD_SUCCESS_SUFFIX: "'.",
                    UPLOAD_READ_ERROR_PREFIX: "Error reading file '",
                    UPLOAD_READ_ERROR_SUFFIX: "'.",
                    NO_COMMANDS_IN_HISTORY: "No commands in history."
                },
                INTERNAL_ERRORS: {
                    DB_NOT_INITIALIZED_FS_SAVE: "DB not initialized for FS save",
                    DB_NOT_INITIALIZED_FS_LOAD: "DB not initialized for FS load",
                    DB_NOT_INITIALIZED_FS_DELETE: "DB not initialized for FS delete",
                    DB_NOT_INITIALIZED_FS_CLEAR: "DB not initialized for clearing all FS",
                    CORRUPTED_FS_DATA_PRE_SAVE: "Corrupted FS data before saving.",
                    REDIRECTION_FILE_NOT_SPECIFIED: "internal error: redirection file not specified.",
                    SOURCE_NOT_FOUND_IN_PARENT_PREFIX: "internal error: source '",
                    SOURCE_NOT_FOUND_IN_PARENT_MIDDLE: "' not found in parent '",
                    SOURCE_NOT_FOUND_IN_PARENT_SUFFIX: "'"
                }
            };
        })();

        // --- DOM ELEMENTS CACHE ---
        const DOM = (() => {
            'use strict';
            return {
                terminalDiv: document.getElementById('terminal'),
                outputDiv: document.getElementById('output'),
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'),
                promptHostSpan: document.getElementById('prompt-host')
            };
        })();

        // --- UTILITY FUNCTIONS ---
        const Utils = (() => {
            'use strict';
            function formatConsoleArgs(args) {
                return Array.from(args)
                    .map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg))
                    .join(' ');
            }
            function deepCopyNode(node) {
                return node ? JSON.parse(JSON.stringify(node)) : null;
            }
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            function getFileExtension(filePath) {
                if (!filePath || typeof filePath !== 'string') return '';
                const name = filePath.substring(filePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const lastDot = name.lastIndexOf('.');
                if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) { 
                    return '';
                }
                return name.substring(lastDot + 1).toLowerCase();
            }
            return {
                formatConsoleArgs,
                deepCopyNode,
                formatBytes,
                getFileExtension
            };
        })();

        // --- OUTPUT MANAGER ---
        const OutputManager = (() => {
            'use strict';
            let isEditorActive = false;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;

            function setEditorActive(status) {
                isEditorActive = status;
            }

            async function appendToOutput(text, options = {}) {
                if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MSG) {
                    return; 
                }
                const { typeClass = null } = options;
                const lines = String(text).split('\n');

                for (const line of lines) {
                    const newLine = document.createElement('div');
                    newLine.classList.add(Config.CSS_CLASSES.OUTPUT_LINE);
                    if (typeClass) {
                        newLine.classList.add(typeClass);
                    } else if (options.isError) { 
                        newLine.classList.add(Config.CSS_CLASSES.ERROR_MSG);
                    }
                    DOM.outputDiv.appendChild(newLine);
                    newLine.textContent = line; 
                }
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }

            function appendHtmlToOutput(htmlContent) {
                if (isEditorActive) return;
                const blockDiv = document.createElement('div');
                blockDiv.innerHTML = htmlContent; 
                DOM.outputDiv.appendChild(blockDiv);
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }

            function clearOutput() {
                if (!isEditorActive) {
                    DOM.outputDiv.innerHTML = '';
                }
            }

            console.log = (...args) => {
                appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                originalConsoleLog.apply(console, args);
            };
            console.warn = (...args) => {
                appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                originalConsoleWarn.apply(console, args);
            };
            console.error = (...args) => {
                appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                originalConsoleError.apply(console, args);
            };

            return {
                setEditorActive,
                appendToOutput,
                appendHtmlToOutput,
                clearOutput
            };
        })();

        // --- LOCAL STORAGE MANAGER ---
        const StorageManager = (() => {
            'use strict';
            function loadJSON(key, itemName, defaultValue = null) {
                try {
                    const storedValue = localStorage.getItem(key);
                    if (storedValue) {
                        return JSON.parse(storedValue);
                    }
                } catch (e) {
                     OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                }
                return defaultValue;
            }
            function saveJSON(key, data, itemName) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                }
                return false;
            }
            function removeItem(key) {
                localStorage.removeItem(key);
            }
            function getAllLocalStorageKeys() {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    keys.push(localStorage.key(i));
                }
                return keys;
            }
            return {
                loadJSON,
                saveJSON,
                removeItem,
                getAllLocalStorageKeys
            };
        })();

        // --- INDEXEDDB MANAGER ---
        const IndexedDBManager = (() => {
            'use strict';
            let dbInstance = null;
            let hasLoggedNormalInitialization = false;

            function init() {
                return new Promise((resolve, reject) => {
                    if (dbInstance) {
                        resolve(dbInstance);
                        return;
                    }
                    const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION);
                    request.onupgradeneeded = (event) => {
                        const tempDb = event.target.result;
                        if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) {
                            tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        if (!hasLoggedNormalInitialization) { 
                             OutputManager.appendToOutput("FileSystem DB initialized.", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                             hasLoggedNormalInitialization = true;
                        }
                        resolve(dbInstance);
                    };
                    request.onerror = (event) => {
                        console.error("Database error: ", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private Browse mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(event.target.error);
                    };
                });
            }
            function getDbInstance() {
                if (!dbInstance) {
                    OutputManager.appendToOutput("Error: OopisOs file system storage is not available. Please ensure browser storage is enabled and the page is reloaded.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    throw new Error("IndexedDB not initialized.");
                }
                return dbInstance;
            }
            return {
                init,
                getDbInstance
            };
        })();

        // --- FILE SYSTEM MANAGER ---
        const FileSystemManager = (() => {
            'use strict';
            let fsData = {}; 
            let currentPath = Config.FILESYSTEM.ROOT_PATH;

            function _getFileSystemKey(user) {
                return `fs_${user}`;
            }

            async function initialize(user) {
                fsData = {
                    [Config.FILESYSTEM.ROOT_PATH]: {
                        type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                        children: {}
                    }
                };
            }

            async function save(user) {
                const db = IndexedDBManager.getDbInstance(); 
                if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_SAVE);
                }

                return new Promise((resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const dataToSave = Utils.deepCopyNode(fsData); 

                        if (!dataToSave || typeof dataToSave !== 'object' ||
                            !dataToSave[Config.FILESYSTEM.ROOT_PATH] ||
                            dataToSave[Config.FILESYSTEM.ROOT_PATH].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            console.error("Attempted to save invalid fsData structure for user:", user, dataToSave);
                            OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            return reject(new Error(Config.INTERNAL_ERRORS.CORRUPTED_FS_DATA_PRE_SAVE));
                        }

                        const request = store.put({ id: _getFileSystemKey(user), data: dataToSave });
                        request.onsuccess = () => resolve(true);
                        request.onerror = (event) => {
                            console.error(`Error saving FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            reject(event.target.error);
                        };
                    } catch (e) { 
                        console.error(`Error initiating save transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(e);
                    }
                });
            }

            async function load(user) {
                const db = IndexedDBManager.getDbInstance(); 
                 if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    await initialize(user); 
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_LOAD);
                }

                return new Promise(async (resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const request = store.get(_getFileSystemKey(user));

                        request.onsuccess = async (event) => {
                            const result = event.target.result;
                            if (result && result.data && result.data[Config.FILESYSTEM.ROOT_PATH]?.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                fsData = result.data;
                            } else {
                                const message = result ? `Warning: File system for '${user}' appears invalid or corrupted. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`;
                                const messageType = result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG;
                                
                                OutputManager.appendToOutput(message, { typeClass: messageType });
                                await initialize(user);
                                await save(user); 
                            }
                            resolve();
                        };
                        request.onerror = async (event) => {
                            console.error(`Error loading FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            await initialize(user);
                            await save(user); 
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating load transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        await initialize(user);
                        await save(user);
                        reject(e);
                    }
                });
            }

            async function deleteUserFS(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_DELETE);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.delete(_getFileSystemKey(user));
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error deleting FS for ${user}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            }

            async function clearAllFS() {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                     OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_CLEAR);
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.clear(); 
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error("Error clearing FileSystemsStore:", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(event.target.error);
                    };
                });
            }

            function getCurrentPath() {
                return currentPath;
            }
            function setCurrentPath(path) {
                currentPath = path;
            }
            function getFsData() {
                return fsData;
            }
            function setFsData(newData) {
                fsData = newData;
            }

            function getAbsolutePath(targetPath, basePath) {
                if (!targetPath) targetPath = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;

                let effectiveBasePath = basePath; 

                if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    effectiveBasePath = Config.FILESYSTEM.ROOT_PATH;
                }

                const baseSegments = effectiveBasePath === Config.FILESYSTEM.ROOT_PATH ? [] : effectiveBasePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s && s !== Config.FILESYSTEM.CURRENT_DIR_SYMBOL);
                
                let resolvedSegments = [...baseSegments];
                const targetSegments = targetPath.split(Config.FILESYSTEM.PATH_SEPARATOR);

                for (const segment of targetSegments) {
                    if (segment === '' || segment === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR) && resolvedSegments.length === 0 && segment === '') {
                        }
                        continue;
                    }
                    if (segment === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                        if (resolvedSegments.length > 0) {
                            resolvedSegments.pop(); 
                        }
                    } else {
                        resolvedSegments.push(segment); 
                    }
                }

                if (resolvedSegments.length === 0) {
                    return Config.FILESYSTEM.ROOT_PATH;
                }
                return Config.FILESYSTEM.PATH_SEPARATOR + resolvedSegments.join(Config.FILESYSTEM.PATH_SEPARATOR);
            }

            function getNodeByPath(path) {
                const absolutePath = getAbsolutePath(path, currentPath);

                if (absolutePath === Config.FILESYSTEM.ROOT_PATH) {
                    return fsData[Config.FILESYSTEM.ROOT_PATH];
                }

                const segments = absolutePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                
                let currentNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                for (const segment of segments) {
                    if (currentNode && currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && currentNode.children && currentNode.children[segment]) {
                        currentNode = currentNode.children[segment];
                    } else {
                        return null; 
                    }
                }
                return currentNode;
            }

            function createParentDirectoriesIfNeeded(fullPath) {
                if (fullPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: null, error: "Cannot create parent for root." };
                }

                const lastSlashIndex = fullPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                const parentPath = (lastSlashIndex === 0) ? Config.FILESYSTEM.ROOT_PATH : fullPath.substring(0, lastSlashIndex);
                const newFileName = fullPath.substring(lastSlashIndex + 1); 

                if (!newFileName || newFileName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || newFileName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` };
                }
                if (parentPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: fsData[Config.FILESYSTEM.ROOT_PATH], error: null };
                }

                const parentPathSegments = parentPath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentDirNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                let currentBuiltParentPath = ""; 

                for (const segment of parentPathSegments) {
                    currentBuiltParentPath += Config.FILESYSTEM.PATH_SEPARATOR + segment;
                    if (!currentDirNode.children[segment]) {
                        currentDirNode.children[segment] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                    } else if (currentDirNode.children[segment].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                    }
                    currentDirNode = currentDirNode.children[segment]; 
                }
                return { parentNode: currentDirNode, error: null }; 
            }
            
            function calculateNodeSize(node) {
                if (!node) return 0;
                if (node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return (node.content || "").length; 
                }
                if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    let totalSize = 0;
                    for (const childName in node.children) {
                        totalSize += calculateNodeSize(node.children[childName]); 
                    }
                    return totalSize;
                }
                return 0; 
            }

            function validatePath(commandName, pathArg, options = {}) {
                const {
                    expectedType = 'any',          
                    allowMissing = false,        
                    disallowRoot = false,        
                    defaultToCurrentIfEmpty = true 
                } = options;

                let effectivePathArg = pathArg;
                if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) {
                    effectivePathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                }

                if (effectivePathArg === undefined || effectivePathArg === null) {
                    return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
                }

                const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath());
                const node = getNodeByPath(resolvedPath);

                if (disallowRoot && resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '${Config.FILESYSTEM.ROOT_PATH}'` };
                }

                if (node) { 
                    if (expectedType === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                    }
                    if (expectedType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                    }
                    return { node: node, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                } else { 
                    if (allowMissing) {
                        return { node: null, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                    } else {
                        return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory`, optionsUsed: options };
                    }
                }
            }

            return {
                initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath,
                getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded,
                calculateNodeSize, validatePath
            };
        })();

        // --- COMMAND HISTORY MANAGER ---
        const HistoryManager = (() => {
            'use strict';
            let commandHistory = [];
            let historyIndex = 0; 

            function add(command) {
                const trimmedCommand = command.trim();
                if (trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                    commandHistory.push(trimmedCommand);
                    if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) {
                        commandHistory.shift(); 
                    }
                }
                historyIndex = commandHistory.length; 
            }

            function getPrevious() {
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    return commandHistory[historyIndex];
                }
                return null; 
            }

            function getNext() {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    return commandHistory[historyIndex];
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    return ""; 
                }
                return null; 
            }
            
            function resetIndex() {
                historyIndex = commandHistory.length;
            }

            function getFullHistory() {
                return [...commandHistory]; 
            }
            function clearHistory() {
                commandHistory = [];
                historyIndex = 0;
            }
            function setHistory(newHistory) {
                commandHistory = Array.isArray(newHistory) ? [...newHistory] : [];
                historyIndex = commandHistory.length;
            }

            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();

        // --- CONFIRMATION MANAGER ---
        const ConfirmationManager = (() => {
            'use strict';
            let awaitingConfirmation = false;
            let confirmationContext = null; 

            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
                awaitingConfirmation = true;
                confirmationContext = {
                    promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                    data: dataForAction,
                    onConfirm: onConfirmCallback,
                    onCancel: onCancelCallback
                };
                confirmationContext.promptMessageLines.forEach(line =>
                    OutputManager.appendToOutput(line, { typeClass: Config.CSS_CLASSES.WARNING_MSG })
                );
                OutputManager.appendToOutput(Config.MESSAGES.CONFIRMATION_PROMPT, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                
                TerminalUI.clearInput(); 
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput();
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }

            async function handleConfirmation(input) {
                if (!awaitingConfirmation || !confirmationContext) return false; 

                let processed = false;
                if (input.trim() === 'YES' && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                    processed = true;
                } else {
                    if (typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    }
                    processed = true;
                }
                
                awaitingConfirmation = false;
                confirmationContext = null;
                return processed; 
            }

            function isAwaiting() {
                return awaitingConfirmation;
            }

            return { request, handleConfirmation, isAwaiting };
        })();

        // --- EDITOR MANAGER ---
        const EditorManager = (() => {
            'use strict';
            let isActiveState = false;
            let currentFilePath = null;
            let currentFileMode = Config.EDITOR.DEFAULT_MODE; 
            let currentViewMode = Config.EDITOR.VIEW_MODES.SPLIT; 
            let debounceTimer = null; 

            let editorContainerDiv = null;
            let editorControlsDiv = null;
            let editorFilenameDisplay = null;
            let viewToggleButton = null;
            let editorMainAreaDiv = null;
            let editorTextareaWrapper = null;
            let editorTextareaElement = null;
            let editorPreviewWrapper = null;
            let editorPreviewPaneDiv = null; 
            let editorInstructionsFooter = null;

            function _determineMode(filePath) {
                const extension = Utils.getFileExtension(filePath);
                return Config.EDITOR.EXTENSIONS_MAP[extension] || Config.EDITOR.DEFAULT_MODE;
            }

            function _updatePreview() {
                if (!editorTextareaElement || !editorPreviewPaneDiv) return;
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;

                const content = editorTextareaElement.value;
                if (debounceTimer) clearTimeout(debounceTimer);

                debounceTimer = setTimeout(() => {
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        if (typeof marked !== 'undefined') { 
                            editorPreviewPaneDiv.innerHTML = marked.parse(content);
                        } else {
                            editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded.";
                        }
                    } else if (currentFileMode === Config.EDITOR.MODES.HTML) {
                        let iframe = editorPreviewPaneDiv.querySelector('iframe');
                        if (!iframe) {
                            iframe = document.createElement('iframe');
                            editorPreviewPaneDiv.innerHTML = ''; 
                            editorPreviewPaneDiv.appendChild(iframe);
                        }
                        iframe.srcdoc = content; 
                    }
                }, Config.EDITOR.DEBOUNCE_DELAY_MS);
            }

            function _setupEditorLayout() {
                editorContainerDiv = document.createElement('div');
                editorContainerDiv.id = 'editor-container';

                editorControlsDiv = document.createElement('div');
                editorControlsDiv.id = 'editor-controls';
                editorFilenameDisplay = document.createElement('span');
                editorFilenameDisplay.id = 'editor-filename-display';
                editorFilenameDisplay.textContent = `File: ${currentFilePath || "Untitled"}`;
                
                viewToggleButton = document.createElement('button');
                viewToggleButton.id = 'editor-view-toggle';
                viewToggleButton.addEventListener('click', _toggleViewMode);

                editorControlsDiv.appendChild(editorFilenameDisplay);
                editorControlsDiv.appendChild(viewToggleButton);
                editorContainerDiv.appendChild(editorControlsDiv);

                editorMainAreaDiv = document.createElement('div');
                editorMainAreaDiv.id = 'editor-main-area';

                editorTextareaWrapper = document.createElement('div');
                editorTextareaWrapper.id = 'editor-textarea-wrapper';
                editorTextareaWrapper.classList.add('editor-pane');
                editorTextareaElement = document.createElement('textarea');
                editorTextareaElement.id = 'editor-textarea';
                editorTextareaWrapper.appendChild(editorTextareaElement);
                editorMainAreaDiv.appendChild(editorTextareaWrapper);

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    editorPreviewWrapper = document.createElement('div');
                    editorPreviewWrapper.id = 'editor-preview-wrapper';
                    editorPreviewWrapper.classList.add('editor-pane');
                    editorPreviewPaneDiv = document.createElement('div');
                    editorPreviewPaneDiv.id = 'editor-preview-content'; 
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        editorPreviewPaneDiv.classList.add('markdown-preview'); 
                    }
                    editorPreviewWrapper.appendChild(editorPreviewPaneDiv);
                    editorMainAreaDiv.appendChild(editorPreviewWrapper);
                    _setViewModeUI(currentViewMode); 
                } else {
                    viewToggleButton.style.display = 'none';
                    editorTextareaWrapper.style.borderRight = 'none';
                }
                
                editorContainerDiv.appendChild(editorMainAreaDiv);

                editorInstructionsFooter = document.createElement('div');
                editorInstructionsFooter.id = 'editor-instructions-footer';
                editorInstructionsFooter.textContent = `Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving` +
                    ((currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) ? ` | Ctrl+P: Toggle Preview` : '');
                editorContainerDiv.appendChild(editorInstructionsFooter);

                DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv);
            }
            
            function _setViewModeUI(mode) {
                 if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                 if (!editorTextareaWrapper || !editorPreviewWrapper) return; 

                currentViewMode = mode;
                const showTextarea = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                const showPreview = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY;

                editorTextareaWrapper.style.display = showTextarea ? "flex" : "none";
                editorPreviewWrapper.style.display = showPreview ? "flex" : "none";

                if (mode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    viewToggleButton.textContent = "Edit Only";
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.flex = "1";
                    editorTextareaWrapper.style.borderRight = '1px solid #333'; 
                } else if (mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                    viewToggleButton.textContent = "Preview Only";
                    editorTextareaWrapper.style.flex = "2"; 
                    editorTextareaWrapper.style.borderRight = 'none';
                } else if (mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY) {
                    viewToggleButton.textContent = "Split View";
                    editorPreviewWrapper.style.flex = "2"; 
                }
            }

            function _toggleViewMode() {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                
                if (currentViewMode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.EDIT_ONLY);
                } else if (currentViewMode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                     _setViewModeUI(Config.EDITOR.VIEW_MODES.PREVIEW_ONLY);
                } else { 
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.SPLIT);
                }
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") {
                    editorTextareaElement.focus();
                }
            }

            function enter(filePath, content) {
                if (isActiveState) {
                    OutputManager.appendToOutput("Editor already active.", { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                    return;
                }
                isActiveState = true;
                OutputManager.setEditorActive(true); 
                currentFilePath = filePath;
                currentFileMode = _determineMode(filePath);
                currentViewMode = (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML)
                                  ? Config.EDITOR.VIEW_MODES.SPLIT
                                  : Config.EDITOR.VIEW_MODES.EDIT_ONLY;

                DOM.outputDiv.style.display = 'none'; 
                DOM.inputLineContainerDiv.style.display = 'none'; 

                _setupEditorLayout(); 

                editorTextareaElement.value = content;
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview(); 
                    editorTextareaElement.addEventListener('input', _updatePreview); 
                }
                
                editorTextareaElement.focus();
                editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
                editorTextareaElement.addEventListener('keydown', handleKeyDown); 
            }

            async function exit(saveChanges = false) {
                let success = true; 
                if (saveChanges && editorTextareaElement && currentFilePath) {
                    const newContent = editorTextareaElement.value;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath);
                    if (parentDirResult.error) {
                        OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                        success = false;
                    } else {
                        const parentNode = parentDirResult.parentNode;
                        if (parentNode) {
                            const fileName = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: newContent };
                            
                            const currentUser = UserManager.getCurrentUser();
                            if (currentUser) {
                                if (await FileSystemManager.save(currentUser.name)) {
                                    OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                } else {
                                    OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                    success = false;
                                }
                            } else {
                                OutputManager.appendToOutput(`Error saving file: No current user context.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                success = false;
                            }
                        } else { 
                             OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                             success = false;
                        }
                    }
                } else if (currentFilePath) { 
                    OutputManager.appendToOutput(`Exited editor for '${currentFilePath}' without saving.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }

                if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) {
                    DOM.terminalDiv.removeChild(editorContainerDiv);
                }
                if (editorTextareaElement) {
                    editorTextareaElement.removeEventListener('keydown', handleKeyDown);
                    editorTextareaElement.removeEventListener('input', _updatePreview);
                }
                editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = null;
                editorMainAreaDiv = editorTextareaWrapper = editorTextareaElement = null;
                editorPreviewWrapper = editorPreviewPaneDiv = editorInstructionsFooter = null;

                if (debounceTimer) clearTimeout(debounceTimer); 
                debounceTimer = null;

                isActiveState = false;
                OutputManager.setEditorActive(false); 
                currentFilePath = null;
                currentFileMode = Config.EDITOR.DEFAULT_MODE;

                DOM.outputDiv.style.display = '';
                DOM.inputLineContainerDiv.style.display = '';
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                TerminalUI.focusInput();
                TerminalUI.updatePrompt(); 
                return success; 
            }

            async function handleKeyDown(event) {
                if (event.key === 'Tab') {
                    event.preventDefault(); 
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + Config.EDITOR.TAB_REPLACEMENT + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + Config.EDITOR.TAB_REPLACEMENT.length;
                    _updatePreview(); 
                    return;
                }

                if (event.ctrlKey) {
                    switch (event.key.toLowerCase()) {
                        case 's':
                            event.preventDefault();
                            await exit(true); 
                            break;
                        case 'o':
                            event.preventDefault();
                            await exit(false); 
                            break;
                        case 'p':
                            event.preventDefault();
                            if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                                _toggleViewMode();
                            }
                            break;
                    }
                }
            }
            return { isActive: () => isActiveState, enter, exit };
        })();

        // --- USER MANAGER ---
        const UserManager = (() => {
            'use strict';
            let currentUser = { name: Config.USER.DEFAULT_NAME }; 

            function getCurrentUser() {
                return currentUser;
            }

            async function register(username) {
                const users = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (users[username]) {
                    return { success: false, error: `User '${username}' already exists.` };
                }
                if (Config.USER.RESERVED_USERNAMES.includes(username.toLowerCase())) {
                     return { success: false, error: `Cannot register '${username}'. This username is reserved.` };
                }
                if (username.includes(" ")) { 
                    return { success: false, error: "Username cannot contain spaces." };
                }

                users[username] = {}; 
                if (StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, users, "User list")) {
                    await FileSystemManager.initialize(username);
                    await FileSystemManager.save(username);
                    return { success: true, message: `User '${username}' registered. You can now login.` };
                } else {
                    return { success: false, error: "Failed to save new user credentials." };
                }
            }

            async function login(username) {
                if (currentUser.name === username) {
                    return { success: true, message: `${Config.MESSAGES.ALREADY_LOGGED_IN_AS_PREFIX}${username}${Config.MESSAGES.ALREADY_LOGGED_IN_AS_SUFFIX}`, noAction: true };
                }

                const users = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (!users.hasOwnProperty(username)) { 
                     return { success: false, error: "Invalid username." };
                }
                
                if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username) {
                    SessionManager.saveAutomaticState(currentUser.name);
                }

                currentUser = { name: username }; 
                HistoryManager.clearHistory(); 
                await FileSystemManager.load(username); 
                SessionManager.loadAutomaticState(username); 
                TerminalUI.updatePrompt(); 
                return { success: true, message: `Logged in as ${username}.` };
            }

            async function logout() {
                if (currentUser.name === Config.USER.DEFAULT_NAME) {
                    return { success: true, message: `Already logged in as Guest. ${Config.MESSAGES.NO_ACTION_TAKEN}`, noAction: true };
                }
                SessionManager.saveAutomaticState(currentUser.name); 
                
                const prevUserName = currentUser.name;
                currentUser = { name: Config.USER.DEFAULT_NAME }; 

                HistoryManager.clearHistory();
                await FileSystemManager.load(Config.USER.DEFAULT_NAME); 
                SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME); 
                TerminalUI.updatePrompt();
                return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` };
            }
            
            function setCurrentUserObject(userObject) {
                currentUser = userObject;
            }
            function getDefaultUser() {
                return Config.USER.DEFAULT_NAME;
            }

            return {
                getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser
            };
        })();

        // --- SESSION MANAGER ---
        const SessionManager = (() => {
            'use strict';
            function _getAutomaticSessionStateKey(user) {
                return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`;
            }
            function _getManualUserTerminalStateKey(user) {
                const userName = typeof user === 'object' && user !== null && user.name ? user.name : String(user);
                return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${userName}`;
            }

            function saveAutomaticState(username) {
                const currentInput = TerminalUI.getCurrentInputValue();
                const autoState = {
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML, 
                    currentInput: currentInput,
                    commandHistory: HistoryManager.getFullHistory()
                };
                StorageManager.saveJSON(_getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`);
            }

            function loadAutomaticState(username) {
                const autoState = StorageManager.loadJSON(_getAutomaticSessionStateKey(username), `Auto session for ${username}`);

                if (autoState) {
                    FileSystemManager.setCurrentPath(autoState.currentPath || Config.FILESYSTEM.ROOT_PATH);
                    if (autoState.hasOwnProperty('outputHTML')) {
                        DOM.outputDiv.innerHTML = autoState.outputHTML || '';
                    } else { 
                        DOM.outputDiv.innerHTML = ''; 
                    }
                    TerminalUI.setCurrentInputValue(autoState.currentInput || '');
                    HistoryManager.setHistory(autoState.commandHistory || []);
                } else { 
                    DOM.outputDiv.innerHTML = '';
                    TerminalUI.setCurrentInputValue('');
                    FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH); 
                    HistoryManager.clearHistory();
                    OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`);
                }
                TerminalUI.updatePrompt();
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                return !!autoState; 
            }

            async function saveManualState() {
                const currentUser = UserManager.getCurrentUser();
                const currentInput = TerminalUI.getCurrentInputValue();
                const manualStateData = {
                    user: currentUser.name, 
                    osVersion: Config.OS.VERSION,
                    timestamp: new Date().toISOString(),
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML,
                    currentInput: currentInput,
                    fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()), 
                    commandHistory: HistoryManager.getFullHistory()
                };
                if (StorageManager.saveJSON(_getManualUserTerminalStateKey(currentUser), manualStateData, `Manual save for ${currentUser.name}`)) {
                    return { success: true, message: `${Config.MESSAGES.SESSION_SAVED_FOR_PREFIX}${currentUser.name}.` };
                } else {
                    return { success: false, error: "Failed to save session manually." };
                }
            }

            async function loadManualState() {
                const currentUser = UserManager.getCurrentUser();
                const manualStateData = StorageManager.loadJSON(_getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`);

                if (manualStateData) {
                    if (manualStateData.user && manualStateData.user !== currentUser.name) {
                         OutputManager.appendToOutput(`Warning: Saved state is for user '${manualStateData.user}', but current user is '${currentUser.name}'. Loading anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                    }

                    ConfirmationManager.request(
                        [`Load manually saved state for '${currentUser.name}'? This overwrites current session & filesystem.`],
                        { pendingData: manualStateData, userNameToRestoreTo: currentUser.name }, 
                        async (data) => {
                            FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                            FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                            DOM.outputDiv.innerHTML = data.pendingData.outputHTML || '';
                            TerminalUI.setCurrentInputValue(data.pendingData.currentInput || '');
                            HistoryManager.setHistory(data.pendingData.commandHistory || []);
                            
                            await FileSystemManager.save(data.userNameToRestoreTo); 
                            OutputManager.appendToOutput(Config.MESSAGES.SESSION_LOADED_MSG, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                            TerminalUI.updatePrompt();
                            DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        },
                        () => { 
                            OutputManager.appendToOutput(Config.MESSAGES.LOAD_STATE_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, message: "Confirmation requested for loading state." };
                } else {
                    return { success: false, message: `${Config.MESSAGES.NO_MANUAL_SAVE_FOUND_PREFIX}${currentUser.name}.` };
                }
            }

            async function performFullReset() {
                OutputManager.clearOutput();
                TerminalUI.clearInput();

                const keysToRemove = [];
                const allKeys = StorageManager.getAllLocalStorageKeys();
                allKeys.forEach(key => {
                    if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) ||
                        key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) ||
                        key === Config.STORAGE_KEYS.USER_CREDENTIALS) {
                        keysToRemove.push(key);
                    }
                });
                keysToRemove.forEach(key => StorageManager.removeItem(key));
                await OutputManager.appendToOutput("All session states and credentials cleared from local storage.");

                try {
                    await FileSystemManager.clearAllFS();
                    await OutputManager.appendToOutput("All user filesystems cleared from DB.");
                } catch (error) {
                }

                HistoryManager.clearHistory();
                
                const guestUser = { name: Config.USER.DEFAULT_NAME };
                UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.initialize(Config.USER.DEFAULT_NAME); 
                await FileSystemManager.save(Config.USER.DEFAULT_NAME);       
                
                loadAutomaticState(Config.USER.DEFAULT_NAME); 
                
                await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                TerminalUI.updatePrompt();
            }

            return {
                saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset
            };
        })();

        // --- TERMINAL UI MANAGER ---
        const TerminalUI = (() => {
            'use strict';
            let isNavigatingHistory = false; 

            function updatePrompt() {
                const user = UserManager.getCurrentUser();
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.DEFAULT_HOST_NAME;
                const currentPathDisplay = FileSystemManager.getCurrentPath();
                DOM.promptPathSpan.textContent = (currentPathDisplay === Config.FILESYSTEM.ROOT_PATH && currentPathDisplay.length > 1)
                                                 ? Config.FILESYSTEM.ROOT_PATH 
                                                 : currentPathDisplay;
            }

            function focusInput() {
                 if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.focus();
                    if (DOM.editableInputDiv.textContent.length === 0) {
                        setCaretToEnd(DOM.editableInputDiv); 
                    }
                }
            }

            function clearInput() {
                if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = '';
            }

            function getCurrentInputValue() {
                return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : '';
            }

            function setCurrentInputValue(value, setAtEnd = true) {
                if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.textContent = value;
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv);
                }
            }

            function setCaretToEnd(element) {
                if (!element) return;
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(element); 
                range.collapse(false); 
                sel.removeAllRanges(); 
                sel.addRange(range); 
            }
            
            function isPasswordInputActiveState() { return false; }
            function getPasswordContext() { return null; }
            function switchToPasswordInput(promptContext) { /* TODO */ }
            function switchToEditableInput() { /* TODO */ }


            function setIsNavigatingHistory(status) {
                isNavigatingHistory = status;
            }
            function getIsNavigatingHistory() {
                return isNavigatingHistory;
            }

            return {
                updatePrompt, focusInput, clearInput, setCurrentInputValue, getCurrentInputValue,
                isPasswordInputActiveState, getPasswordContext, switchToPasswordInput,
                switchToEditableInput, setCaretToEnd, setIsNavigatingHistory, getIsNavigatingHistory
            };
        })();

        // --- COMMAND EXECUTOR ---
        const CommandExecutor = (() => {
            'use strict';
            let lastCommandFailed = false; 
            
            // --- NEW LEXER AND PARSER START ---
            const TokenType = {
                WORD: 'WORD',                 // For command names, unquoted arguments, filenames
                STRING_DQ: 'STRING_DQ',       // Double-quoted string literal
                STRING_SQ: 'STRING_SQ',       // Single-quoted string literal
                OPERATOR_GT: 'OPERATOR_GT',   // >
                OPERATOR_GTGT: 'OPERATOR_GTGT', // >>
                // Future: OPERATOR_LT: '<', OPERATOR_PIPE: '|', etc.
                WHITESPACE: 'WHITESPACE',     // Whitespace characters (optional to tokenize)
                EOF: 'EOF'                    // End of input
            };

            class Token {
                constructor(type, value, position) {
                    this.type = type;
                    this.value = value;
                    this.position = position; // For error reporting
                }
            }

            class Lexer {
                constructor(input) {
                    this.input = input;
                    this.position = 0;
                    this.tokens = [];
                }

                tokenize() {
                    while (this.position < this.input.length) {
                        const char = this.input[this.position];

                        if (/\s/.test(char)) {
                            // Optional: Create WHITESPACE tokens or just skip
                            // For simplicity now, let's skip whitespace between tokens
                            this.position++;
                            continue;
                        }

                        if (char === '"') {
                            this.tokens.push(this._tokenizeString('"'));
                            continue;
                        }
                        if (char === "'") {
                            this.tokens.push(this._tokenizeString("'"));
                            continue;
                        }

                        if (char === '>') {
                            if (this.input[this.position + 1] === '>') {
                                this.tokens.push(new Token(TokenType.OPERATOR_GTGT, '>>', this.position));
                                this.position += 2;
                            } else {
                                this.tokens.push(new Token(TokenType.OPERATOR_GT, '>', this.position));
                                this.position++;
                            }
                            continue;
                        }
                        
                        // For now, anything else that's not a special char or whitespace is a WORD
                        // This is a simplification; a real shell lexer has more complex rules for WORDs
                        // (e.g., not starting with a number if it's not a number, handling special chars in unquoted words)
                        let value = '';
                        const startPos = this.position;
                        while (this.position < this.input.length && 
                               !/\s/.test(this.input[this.position]) && 
                               this.input[this.position] !== '"' && 
                               this.input[this.position] !== "'" &&
                               this.input[this.position] !== '>') {
                            value += this.input[this.position];
                            this.position++;
                        }
                        if (value) {
                            this.tokens.push(new Token(TokenType.WORD, value, startPos));
                        }
                    }
                    this.tokens.push(new Token(TokenType.EOF, null, this.position));
                    return this.tokens;
                }

                _tokenizeString(quoteChar) {
                    const startPos = this.position;
                    let value = '';
                    this.position++; // Skip opening quote

                    while (this.position < this.input.length && this.input[this.position] !== quoteChar) {
                        // Basic string, no escape sequences handled for now
                        value += this.input[this.position];
                        this.position++;
                    }

                    if (this.position >= this.input.length || this.input[this.position] !== quoteChar) {
                        // This is a lexer error: unclosed string
                        // For now, we'll return it as a partial word or handle error in parser
                        // A more robust lexer would throw an error here.
                        // Let's treat it as a WORD for now if unclosed, or parser can error.
                        console.warn(`Lexer: Unclosed string starting at position ${startPos}. Treating as WORD.`);
                        return new Token(TokenType.WORD, quoteChar + value, startPos); // Return as is, parser might reject
                    }
                    this.position++; // Skip closing quote
                    return new Token(quoteChar === '"' ? TokenType.STRING_DQ : TokenType.STRING_SQ, value, startPos);
                }
            }

            class Parser {
                constructor(tokens) {
                    this.tokens = tokens;
                    this.position = 0;
                }

                _currentToken() {
                    return this.tokens[this.position];
                }

                _nextToken() {
                    if (this.position < this.tokens.length -1) { // Don't go past EOF
                        this.position++;
                    }
                    return this._currentToken();
                }
                
                _expect(tokenType) {
                    if (this._currentToken().type === tokenType) {
                        const token = this._currentToken();
                        this._nextToken();
                        return token;
                    }
                    throw new Error(`Parser Error: Expected token ${tokenType} but got ${this._currentToken().type} ('${this._currentToken().value}') at position ${this._currentToken().position}`);
                }

                parse() {
                    // This initial parser aims to replicate the output of the old _parseInputAndRedirection
                    // { baseCommand: string, args: string[], redirection: { type: 'overwrite'|'append', file: string } | null }
                    
                    let baseCommand = null;
                    const args = [];
                    let redirection = null;

                    if (this._currentToken().type === TokenType.EOF) {
                        return { baseCommand: '', args: [], redirection: null }; // Empty input
                    }

                    // First token should be the command name (WORD)
                    const cmdToken = this._expect(TokenType.WORD);
                    baseCommand = cmdToken.value;

                    // Collect arguments
                    while (this._currentToken().type === TokenType.WORD || 
                           this._currentToken().type === TokenType.STRING_DQ ||
                           this._currentToken().type === TokenType.STRING_SQ) {
                        args.push(this._currentToken().value);
                        this._nextToken();
                    }

                    // Check for redirection at the end (simplified to match old behavior first)
                    // A more robust parser would allow redirection anywhere.
                    // This part needs to look ahead or parse redirection specifically.
                    // For now, let's try to find redirection tokens *among the remaining tokens*.
                    
                    let redirTokenIndex = -1;
                    for (let i = this.position; i < this.tokens.length -1; i++) { // -1 to exclude EOF
                        if (this.tokens[i].type === TokenType.OPERATOR_GT || this.tokens[i].type === TokenType.OPERATOR_GTGT) {
                            redirTokenIndex = i;
                            break;
                        }
                    }

                    if (redirTokenIndex !== -1) {
                        // Potential redirection found.
                        // Let's assume anything before it that wasn't part of the initial args scan 
                        // might be an error or unhandled. For now, we'll just take what we have.
                        
                        // Re-scan arguments up to the redirection operator
                        args.length = 0; // Clear previously scanned args
                        let currentPosBeforeRedirScan = cmdToken === this.tokens[0] ? 1 : 0; // Start after command if it was first
                        
                        // If the first token after command is already a redir op, no args.
                        if (this.tokens[currentPosBeforeRedirScan] && 
                            (this.tokens[currentPosBeforeRedirScan].type === TokenType.OPERATOR_GT ||
                             this.tokens[currentPosBeforeRedirScan].type === TokenType.OPERATOR_GTGT)) {
                            // No args before redirection
                        } else {
                             while(this.tokens[currentPosBeforeRedirScan] && 
                                   currentPosBeforeRedirScan < redirTokenIndex &&
                                   (this.tokens[currentPosBeforeRedirScan].type === TokenType.WORD ||
                                    this.tokens[currentPosBeforeRedirScan].type === TokenType.STRING_DQ ||
                                    this.tokens[currentPosBeforeRedirScan].type === TokenType.STRING_SQ)) {
                                args.push(this.tokens[currentPosBeforeRedirScan].value);
                                currentPosBeforeRedirScan++;
                            }
                        }


                        const redirOpToken = this.tokens[redirTokenIndex];
                        const redirFileToken = this.tokens[redirTokenIndex + 1];

                        if (redirFileToken && (redirFileToken.type === TokenType.WORD || redirFileToken.type === TokenType.STRING_DQ || redirFileToken.type === TokenType.STRING_SQ)) {
                            redirection = {
                                type: redirOpToken.type === TokenType.OPERATOR_GTGT ? 'append' : 'overwrite',
                                file: redirFileToken.value
                            };
                            // Check if there's anything after the redirection file token (excluding EOF)
                            if (this.tokens[redirTokenIndex + 2] && this.tokens[redirTokenIndex + 2].type !== TokenType.EOF) {
                                // This indicates extra tokens after redirection, which the old parser implicitly ignored or treated as part of filename.
                                // A stricter parser would error here. For now, to match old behavior, we might just use the first file token.
                                OutputManager.appendToOutput(`Warning: Extra tokens found after redirection target '${redirFileToken.value}'. Ignoring.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            }
                        } else {
                            // Invalid redirection (e.g., `echo >` or `echo > >>`)
                            // The old parser might have treated the operator as an argument.
                            // This new parser will be stricter.
                            throw new Error(`Parser Error: Expected filename after redirection operator '${redirOpToken.value}' at position ${redirOpToken.position}`);
                        }
                    }
                    // If no redirection was found by the loop, args remain as initially collected.

                    return { baseCommand, args, redirection };
                }
            }

            // --- NEW LEXER AND PARSER END ---


            function _createUsageError(commandName, message) {
                const usage = commands[commandName]?.usage || `No usage information available for '${commandName}'.`;
                const finalMessage = message || 'missing operand'; 
                return { success: false, error: `${commandName}: ${finalMessage}\nUsage: ${usage}` };
            }

            async function processSingleCommand(rawCommandText, isInteractive = true) {
                lastCommandFailed = false; 
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false };

                if (EditorManager.isActive()) return finalResult; 

                if (ConfirmationManager.isAwaiting()) {
                    await ConfirmationManager.handleConfirmation(rawCommandText);
                     if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                    return finalResult; 
                }

                const commandToEcho = rawCommandText.trim(); 
                let commandToExecute = rawCommandText.trim(); 
                
                if (isInteractive) {
                    DOM.inputLineContainerDiv.style.visibility = 'hidden'; 
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                    await OutputManager.appendToOutput(`${promptText}${commandToEcho}`);
                }

                if (commandToExecute === '') { 
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText);
                    return finalResult;
                }

                if (isInteractive) { 
                    HistoryManager.add(rawCommandText.trim());
                }
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) {
                     HistoryManager.resetIndex();
                }
                
                // --- USE NEW LEXER/PARSER ---
                let parsedCommand;
                try {
                    const lexer = new Lexer(commandToExecute);
                    const tokens = lexer.tokenize();
                    // For debugging: console.log("Tokens:", JSON.stringify(tokens, null, 2));
                    const parser = new Parser(tokens);
                    parsedCommand = parser.parse();
                    // For debugging: console.log("Parsed Command:", JSON.stringify(parsedCommand, null, 2));
                } catch (e) {
                    await OutputManager.appendToOutput(e.message, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText);
                    return { success: false, error: e.message };
                }
                // --- END LEXER/PARSER USAGE ---
                
                const cmdOptions = {
                    force: (parsedCommand.baseCommand === 'rm' && !isInteractive) || 
                           (parsedCommand.args.includes('-f') || parsedCommand.args.includes('--force'))
                };

                const cmdResult = await _executeCommandHandler(parsedCommand, cmdOptions);
                
                finalResult = await _processCommandOutput(parsedCommand, cmdResult, isInteractive);
                lastCommandFailed = !finalResult.success; 

                if (isInteractive) {
                    await _finalizeInteractiveModeUI(rawCommandText); 
                }
                return finalResult;
            }
            
            // _parseInputAndRedirection is now REMOVED.

            async function handleLs(args, cmdOptions) {
                const targetPathArg = args[0]; 
                const validation = FileSystemManager.validatePath('ls', targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, 
                    defaultToCurrentIfEmpty: true 
                });

                if (validation.error) return { success: false, error: validation.error };
                
                const childrenNames = Object.keys(validation.node.children).sort(); 
                if (childrenNames.length === 0) return { success: true, output: Config.MESSAGES.DIRECTORY_EMPTY };

                let outputLines = [];
                childrenNames.forEach(name => {
                    const childNode = validation.node.children[name];
                    let line = name;
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        line += Config.FILESYSTEM.PATH_SEPARATOR; 
                    }
                    outputLines.push(line);
                });
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleCd(args, cmdOptions) {
                const targetPathArg = args[0];
                if (targetPathArg === undefined) return _createUsageError('cd');

                const validation = FileSystemManager.validatePath('cd', targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: false 
                });

                if (validation.error) return { success: false, error: validation.error };

                if (validation.resolvedPath === FileSystemManager.getCurrentPath()) {
                    return { success: true, output: `${Config.MESSAGES.ALREADY_IN_DIRECTORY_PREFIX}${validation.resolvedPath}${Config.MESSAGES.ALREADY_IN_DIRECTORY_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }

                FileSystemManager.setCurrentPath(validation.resolvedPath);
                TerminalUI.updatePrompt(); 
                return { success: true, output: null }; 
            }
            async function handleMkdir(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return _createUsageError('mkdir');
                if (fullPathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || fullPathArg === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` };
                }

                const validation = FileSystemManager.validatePath('mkdir', fullPathArg, {
                    allowMissing: true,    
                    disallowRoot: true,    
                    defaultToCurrentIfEmpty: false
                });

                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                     return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` };
                }
                if (validation.error && !validation.optionsUsed?.allowMissing) { 
                     return { success: false, error: validation.error };
                }
                
                const targetAbsPath = validation.resolvedPath;
                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }

                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` };
                
                const parentNode = parentDirResult.parentNode;
                if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}' (internal error)` };

                const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` };

                parentNode.children[dirToCreateName] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    delete parentNode.children[dirToCreateName];
                    return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `Directory '${fullPathArg}${Config.MESSAGES.DIRECTORY_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleTouch(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return _createUsageError('touch');
                if (fullPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                     return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` };
                }

                const validation = FileSystemManager.validatePath('touch', fullPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, 
                    allowMissing: true,
                    disallowRoot: true, 
                    defaultToCurrentIfEmpty: false
                });

                if (validation.error) return { success: false, error: validation.error };

                const targetAbsPath = validation.resolvedPath;
                if (validation.node) { 
                    return { success: true, output: `${Config.MESSAGES.TIMESTAMP_UPDATED_PREFIX}${fullPathArg}${Config.MESSAGES.TIMESTAMP_UPDATED_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }

                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` };
                
                const parentNode = parentDirResult.parentNode;
                 if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}' (internal error)`};

                const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: "" }; 
                
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                     delete parentNode.children[newFileName]; 
                     return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `File '${fullPathArg}${Config.MESSAGES.FILE_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCat(args, cmdOptions) {
                const targetPathArg = args[0];
                if (!targetPathArg) return _createUsageError('cat');

                const validation = FileSystemManager.validatePath('cat', targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, 
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                return { success: true, output: validation.node.content };
            }
            async function handleEcho(args, cmdOptions) {
                let outputString = args.join(' ');
                // The new parser already handles stripping quotes from arguments if they were quoted.
                // So, this specific logic might become redundant or behave slightly differently
                // if an argument like `"hello"world"` is passed.
                // For now, let's keep it, as the parser provides individual args.
                // If args = ["hello world"], this won't strip anything.
                // If args = ["\"hello world\""], then this will strip.
                // The new parser should give args = ["hello world"] if input was `echo "hello world"`.
                // This `echo` implementation might simplify.
                // For now, let's assume `args` are already processed values.
                return { success: true, output: outputString };
            }
            async function handleMv(args, cmdOptions) {
                if (args.length < 2) return _createUsageError('mv', "missing source and/or destination operands");
                const sourcePathArg = args[0], destPathArg = args[1];

                const sourceValidation = FileSystemManager.validatePath('mv', sourcePathArg, {
                    disallowRoot: true, 
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;

                const destValidation = FileSystemManager.validatePath('mv', destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (destValidation.error && !(destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE)) {
                     if (!destValidation.error.includes("Is a directory") && !destValidation.error.includes("Not a directory")) {
                     }
                }

                let absDestPath = destValidation.resolvedPath; 

                const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath);

                if (!sourceParentNode || !sourceParentNode.children || !sourceParentNode.children[sourceName]) {
                    return { success: false, error: `${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX}${sourceName}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE}${sourceParentPath}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX}` };
                }

                let finalDestParentNode, finalDestName;

                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName; 
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath); 
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                    if(parentDirResult.error) return { success: false, error: `mv: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `mv: could not obtain parent directory for '${absDestPath}' (internal error)`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }

                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mv: invalid destination name '${finalDestName}'` };
                }
                if (absSourcePath === absDestPath) {
                    return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                if (finalDestParentNode.children[finalDestName]) {
                     const destDisplayPath = (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE)
                                            ? destPathArg 
                                            : (absDestPath.substring(0, absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH); 
                    return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destDisplayPath}'.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one of its subdirectories ('${destPathArg}')` };
                }

                finalDestParentNode.children[finalDestName] = sourceNode;
                delete sourceParentNode.children[sourceName];
                
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    sourceParentNode.children[sourceName] = sourceNode; 
                    delete finalDestParentNode.children[finalDestName]; 
                    return { success: false, error: "mv: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.MOVED_PREFIX}${sourcePathArg}${Config.MESSAGES.MOVED_TO}${destPathArg}${Config.MESSAGES.MOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCp(args, cmdOptions) {
                if (args.length < 2) return _createUsageError('cp', "missing source and/or destination operands");
                const sourcePathArg = args[0], destPathArg = args[1];

                const sourceValidation = FileSystemManager.validatePath('cp', sourcePathArg, {
                    disallowRoot: false, 
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;

                const destValidation = FileSystemManager.validatePath('cp', destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }

                let absDestPath = destValidation.resolvedPath;
                const sourceName = absSourcePath === Config.FILESYSTEM.ROOT_PATH
                                   ? 'root_copy' 
                                   : absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);

                let finalDestParentNode, finalDestName;
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName; 
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath);
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                     if(parentDirResult.error) return { success: false, error: `cp: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `cp: could not obtain parent for '${absDestPath}'`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }

                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `cp: invalid destination name '${finalDestName}'` };
                }
                if (finalDestParentNode.children[finalDestName]) { 
                    return { success: false, error: `cp: destination '${finalDestName}' already exists.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `cp: cannot copy a directory into itself or one of its subdirectories.` };
                }

                const copiedNode = Utils.deepCopyNode(sourceNode); 
                if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` };
                
                finalDestParentNode.children[finalDestName] = copiedNode;
                
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    delete finalDestParentNode.children[finalDestName]; 
                    return { success: false, error: "cp: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.COPIED_PREFIX}${sourcePathArg}${Config.MESSAGES.COPIED_TO}${destPathArg}${Config.MESSAGES.COPIED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleRm(args, cmdOptions = {}) {
                const CWDbeforeDeletion = FileSystemManager.getCurrentPath(); 
                const { force: initialForce } = cmdOptions; 
                let effectiveForce = initialForce;
                
                const remainingArgs = [...args]; 
                let pathArgForValidation;

                const forceFlagIndex = remainingArgs.findIndex(arg => arg === '-f' || arg === '--force');
                if (forceFlagIndex !== -1) {
                    effectiveForce = true;
                    remainingArgs.splice(forceFlagIndex, 1); 
                }
                pathArgForValidation = remainingArgs[0]; 

                if (!pathArgForValidation) return _createUsageError('rm');

                const validation = FileSystemManager.validatePath('rm', pathArgForValidation, {
                    disallowRoot: true, 
                    defaultToCurrentIfEmpty: false
                });

                if (validation.error) {
                    if (effectiveForce && validation.error.includes("No such file or directory")) {
                        return { success: true, output: null }; 
                    }
                    return { success: false, error: validation.error }; 
                }

                const pathBeingDeleted = validation.resolvedPath; 
                const originalNodeType = validation.node.type; 

                const itemTypeDisplay = originalNodeType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? 'directory' : 'file';
                
                const dataForConfirm = { 
                    path: pathBeingDeleted,
                    arg: pathArgForValidation, 
                    userName: UserManager.getCurrentUser().name,
                    cwdBeforeDelete: CWDbeforeDeletion, 
                    nodeType: originalNodeType 
                };

                if (effectiveForce) { 
                    const parentPath = pathBeingDeleted.substring(0, pathBeingDeleted.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                    const itemName = pathBeingDeleted.substring(pathBeingDeleted.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const parentNode = FileSystemManager.getNodeByPath(parentPath);

                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        const removedNodeForRevert = parentNode.children[itemName]; 
                        delete parentNode.children[itemName];
                        if(!await FileSystemManager.save(dataForConfirm.userName)) {
                             parentNode.children[itemName] = removedNodeForRevert; 
                            return { success: false, error: `Error saving filesystem after force removing '${pathBeingDeleted}'.` };
                        } else {
                            let outputMessage = `${Config.MESSAGES.FORCIBLY_REMOVED_PREFIX}${pathArgForValidation}${Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX}`;
                            if (pathBeingDeleted === CWDbeforeDeletion && originalNodeType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                const parentOfDeleted = pathBeingDeleted.substring(0, pathBeingDeleted.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                                FileSystemManager.setCurrentPath(parentOfDeleted);
                                outputMessage += `\nCurrent directory was '${pathBeingDeleted}'. Moved to '${parentOfDeleted}'.`;
                                TerminalUI.updatePrompt(); 
                            }
                            return { success: true, output: outputMessage, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                    } else { 
                        return { success: false, error: `Error force removing '${pathBeingDeleted}': Item not found or parent changed.` };
                    }
                } else { 
                    ConfirmationManager.request(
                        [`Are you sure you want to remove ${itemTypeDisplay} '${pathArgForValidation}'? This action cannot be undone.`],
                        dataForConfirm,
                        async (data) => { 
                            const parentPath = data.path.substring(0, data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                            const itemName = data.path.substring(data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            const parentNode = FileSystemManager.getNodeByPath(parentPath);

                            if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                const removedNodeForRevert = parentNode.children[itemName]; 
                                delete parentNode.children[itemName];
                                if(!await FileSystemManager.save(data.userName)) {
                                    parentNode.children[itemName] = removedNodeForRevert; 
                                    await OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'. Removal not persisted.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                } else {
                                    let removalMessage = `'${data.arg}${Config.MESSAGES.ITEM_REMOVED_SUFFIX}`;
                                    if (data.path === data.cwdBeforeDelete && data.nodeType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                        const parentOfDeleted = data.path.substring(0, data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                                        FileSystemManager.setCurrentPath(parentOfDeleted);
                                        removalMessage += `\nCurrent directory was '${data.path}'. Moved to '${parentOfDeleted}'.`;
                                        TerminalUI.updatePrompt(); 
                                    }
                                    await OutputManager.appendToOutput(removalMessage, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                }
                            } else {
                                await OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            }
                        },
                        (data) => { 
                            OutputManager.appendToOutput(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${data.arg || 'item'}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, output: null }; 
                }
            }
            async function handlePwd(args, cmdOptions) {
                return { success: true, output: FileSystemManager.getCurrentPath() };
            }
            async function handleDate(args, cmdOptions) {
                return { success: true, output: new Date().toString() };
            }
            async function handleRun(args, cmdOptions) {
                const scriptPathArg = args[0];
                if (!scriptPathArg) return _createUsageError('run');

                const validation = FileSystemManager.validatePath('run', scriptPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };

                const scriptContent = validation.node.content || "";
                const scriptLines = scriptContent.split('\n');
                await OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                
                (async () => {
                    for (let i = 0; i < scriptLines.length; i++) {
                        const line = scriptLines[i];
                        const trimmedLine = line.trim();
                        if (trimmedLine === '' || trimmedLine.startsWith('#')) continue; 

                        const cmdResult = await processSingleCommand(trimmedLine, false); 
                        if (!cmdResult.success) { 
                            await OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            if (cmdResult.error) await OutputManager.appendToOutput(cmdResult.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            return; 
                        }
                    }
                    await OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                })();
                
                return { success: true, output: null }; 
            }
            async function handleClear(args, cmdOptions) {
                OutputManager.clearOutput();
                return { success: true, output: null };
            }
            async function handleRegisterCmd(args, cmdOptions) {
                const username = args[0];
                if (!username) return _createUsageError('register');
                const result = await UserManager.register(username);
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error };
            }
            async function handleLoginCmd(args, cmdOptions) {
                const username = args[0];
                if (!username) return _createUsageError('login');
                const result = await UserManager.login(username);
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error };
            }
            async function handleLogoutCmd(args, cmdOptions) {
                const result = await UserManager.logout();
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Logout failed." };
            }
            async function handleSavestate(args, cmdOptions) {
                const result = await SessionManager.saveManualState();
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Failed to save state." };
            }
            async function handleLoadstate(args, cmdOptions) {
                const result = await SessionManager.loadManualState();
                return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG };
            }
            async function handleReset(args, cmdOptions) {
                ConfirmationManager.request(
                    ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."],
                    null, 
                    async () => { await SessionManager.performFullReset(); }, 
                    () => { OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); } 
                );
                return { success: true, output: null }; 
            }
            async function handleHelp(args, cmdOptions) {
                let outputLines = [];
                if (!args.length) { 
                    outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                    const commandNames = Object.keys(commands).sort(); 
                    commandNames.forEach(cmdName => {
                        const summary = commands[cmdName]?.summary || 'No summary available.';
                        outputLines.push(`- ${cmdName.padEnd(14, ' ')} ${summary}`); 
                    });
                } else { 
                    const commandName = args[0].toLowerCase();
                    const cmdInfo = commands[commandName];
                    if (cmdInfo) {
                        outputLines.push(`${commandName}: ${cmdInfo.summary || 'No summary available.'}`);
                        outputLines.push(`  Usage: ${cmdInfo.usage || 'N/A'}`);
                        outputLines.push(`  For more details, type: man ${commandName}`);
                    } else return { success: false, error: `No help available for '${commandName}'. Try 'man ${commandName}'.` };
                }
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleMan(args, cmdOptions) {
                function escapeHtml(unsafe) { 
                    if (typeof unsafe !== 'string') return '';
                    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                }

                if (args.length === 0) return _createUsageError('man', "What manual page do you want?");
                const commandName = args[0].toLowerCase();
                const manData = commands[commandName];

                if (manData) {
                    let manOutputHtmlLines = [];
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">NAME</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`); 

                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">SYNOPSIS</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);

                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">DESCRIPTION</span></div>`);
                    const detailLines = (manData.details || 'No detailed description available.').split('\n');
                    detailLines.forEach(line => {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`);
                    });

                    if (manData.examples && manData.examples.length > 0) {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">EXAMPLES</span></div>`);
                        manData.examples.forEach(example => {
                            manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">        <span class="${Config.CSS_CLASSES.MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`);
                        });
                    }
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    
                    OutputManager.appendHtmlToOutput(manOutputHtmlLines.join(''));
                    return { success: true, output: null, isHtmlOutput: true }; 
                } else return { success: false, error: `No manual entry for ${commandName}` };
            }
            async function handleEditCmd(args, cmdOptions) {
                if (EditorManager.isActive()) {
                    return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MSG };
                }
                const targetPathArg = args[0];
                if (!targetPathArg) return _createUsageError('edit');
                if (targetPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) { 
                    return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` };
                }

                const validation = FileSystemManager.validatePath('edit', targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, 
                    allowMissing: true,
                    disallowRoot: true, 
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };

                const content = validation.node ? validation.node.content : ""; 
                EditorManager.enter(validation.resolvedPath, content);
                return { success: true, output: null }; 
            }
            async function handleTree(args, cmdOptions) {
                const targetPathArg = args[0];
                const validation = FileSystemManager.validatePath('tree', targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                if (validation.error) return { success: false, error: validation.error };

                const outputLines = [];
                const startingDirName = validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH
                                      ? Config.FILESYSTEM.ROOT_PATH
                                      : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || validation.resolvedPath;
                outputLines.push(startingDirName);

                function generateTreeLinesRecursive(directoryNode, prefix) {
                    const childrenNames = Object.keys(directoryNode.children).sort();
                    childrenNames.forEach((name, index) => {
                        const childNode = directoryNode.children[name];
                        const isLast = index === childrenNames.length - 1; 
                        const connector = isLast ? " " : " "; 
                        let line = prefix + connector + name;
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) line += Config.FILESYSTEM.PATH_SEPARATOR;
                        outputLines.push(line);

                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            const newPrefix = prefix + (isLast ? "    " : "   ");
                            generateTreeLinesRecursive(childNode, newPrefix);
                        }
                    });
                }
                generateTreeLinesRecursive(validation.node, ""); 
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleExport(args, cmdOptions) {
                const filePathArg = args[0];
                if (!filePathArg) return _createUsageError('export');

                const validation = FileSystemManager.validatePath('export', filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };

                const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || 'downloaded_file.txt';
                const fileContent = validation.node.content || "";
                const mimeType = "text/plain"; 

                try {
                    const blob = new Blob([fileContent], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a); 
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url); 
                    return { success: true, output: `${Config.MESSAGES.EXPORTING_PREFIX}${fileName}${Config.MESSAGES.EXPORTING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Export failed:", error);
                    return { success: false, error: `Error exporting file '${fileName}': ${error.message}` };
                }
            }
            async function handleBackup(args, cmdOptions) {
                const currentUser = UserManager.getCurrentUser();
                const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14); 
                const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`;

                const backupData = {
                    backupVersion: "1.0", 
                    osVersion: Config.OS.VERSION,
                    user: currentUser.name,
                    timestamp: new Date().toISOString(),
                    filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    currentPath: FileSystemManager.getCurrentPath(),
                    commandHistory: HistoryManager.getFullHistory()
                };

                try {
                    const jsonString = JSON.stringify(backupData, null, 2); 
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = backupFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return { success: true, output: `${Config.MESSAGES.BACKUP_CREATING_PREFIX}${backupFileName}${Config.MESSAGES.BACKUP_CREATING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Backup failed:", error);
                    return { success: false, error: `Error creating backup: ${error.message}` };
                }
            }
            async function handleRestore(args, cmdOptions) { 
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json'; 

                return new Promise((resolveCommand) => {
                    fileInput.onchange = async (event) => {
                        const file = event.target.files[0];
                        if (!file) {
                            await OutputManager.appendToOutput(Config.MESSAGES.RESTORE_CANCELLED_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            resolveCommand({ success: true, output: null }); 
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const fileContent = e.target.result;
                                const parsedData = JSON.parse(fileContent);

                                if (typeof parsedData !== 'object' || parsedData === null ||
                                    !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') ||
                                    !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') ||
                                    !parsedData.hasOwnProperty('backupVersion')) {
                                    await OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                    resolveCommand({ success: false, error: "Invalid backup file." });
                                    return;
                                }
                                if (parsedData.backupVersion !== "1.0") { 
                                    await OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting restore anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                                }

                                const dataForConfirm = { parsedData: parsedData, fileName: file.name };
                                ConfirmationManager.request(
                                    [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`],
                                    dataForConfirm,
                                    async (data) => { 
                                        const importedUser = data.parsedData.user;
                                        const currentActiveUser = UserManager.getCurrentUser();
                                        
                                        if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser) {
                                            SessionManager.saveAutomaticState(currentActiveUser.name);
                                        }
                                        
                                        const users = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                                        if (!users[importedUser]) {
                                            OutputManager.appendToOutput(`User '${importedUser}' from backup does not exist locally. Their session will be loaded. Consider registering them if login is desired later.`, {typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG});
                                        }
                                        
                                        UserManager.setCurrentUserObject({ name: importedUser });

                                        FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.filesystem) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                                        FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                                        HistoryManager.setHistory(data.pendingData.commandHistory || []);
                                        
                                        OutputManager.clearOutput(); 
                                        TerminalUI.clearInput();

                                        await FileSystemManager.save(importedUser); 
                                        
                                        await OutputManager.appendToOutput(`${Config.MESSAGES.RESTORE_SUCCESS_PREFIX}${importedUser}${Config.MESSAGES.RESTORE_SUCCESS_MIDDLE}${data.fileName}${Config.MESSAGES.RESTORE_SUCCESS_SUFFIX}`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                        TerminalUI.updatePrompt(); 
                                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                                        resolveCommand({ success: true, output: null});
                                    },
                                    () => { 
                                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                                        resolveCommand({ success: true, output: null});
                                    }
                                );
                            } catch (parseError) {
                                console.error("Restore error - parsing JSON:", parseError);
                                await OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                resolveCommand({ success: false, error: "Could not parse backup file."});
                            }
                        };
                        reader.onerror = async (e) => {
                            console.error("Restore error - reading file:", e);
                            await OutputManager.appendToOutput("Error: Could not read the selected file.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            resolveCommand({ success: false, error: "Could not read file."});
                        };
                        reader.readAsText(file); 
                    };
                    fileInput.click(); 
                });
            }
            async function handleUpload(args, cmdOptions) {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt,.md,.html,.sh'; // Added .sh

                return new Promise((resolveCommand) => {
                    fileInput.onchange = async (event) => {
                        const file = event.target.files[0];
                        if (!file) {
                            await OutputManager.appendToOutput(Config.MESSAGES.UPLOAD_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            resolveCommand({ success: true, output: null });
                            return;
                        }

                        const fileName = file.name;
                        const fileExtension = Utils.getFileExtension(fileName);
                        const allowedExtensions = ['txt', 'md', 'html', 'sh']; // Added 'sh'

                        if (!allowedExtensions.includes(fileExtension)) {
                            const errorMsg = `${Config.MESSAGES.UPLOAD_INVALID_TYPE_PREFIX}${fileExtension}${Config.MESSAGES.UPLOAD_INVALID_TYPE_SUFFIX}`;
                            await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            resolveCommand({ success: false, error: errorMsg });
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const fileContent = e.target.result;
                                const currentDirNode = FileSystemManager.getNodeByPath(FileSystemManager.getCurrentPath());

                                if (currentDirNode && currentDirNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    currentDirNode.children[fileName] = {
                                        type: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                                        content: fileContent
                                    };
                                    if (await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                        const successMsg = `${Config.MESSAGES.UPLOAD_SUCCESS_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_SUCCESS_MIDDLE}${FileSystemManager.getCurrentPath()}${Config.MESSAGES.UPLOAD_SUCCESS_SUFFIX}`;
                                        await OutputManager.appendToOutput(successMsg, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                        resolveCommand({ success: true, output: null });
                                    } else {
                                        const saveErrorMsg = `Error saving uploaded file '${fileName}' to filesystem.`;
                                        await OutputManager.appendToOutput(saveErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                        resolveCommand({ success: false, error: saveErrorMsg });
                                    }
                                } else {
                                    const dirErrorMsg = `Error: Cannot upload file. Current path '${FileSystemManager.getCurrentPath()}' is not a valid directory.`;
                                    await OutputManager.appendToOutput(dirErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                    resolveCommand({ success: false, error: dirErrorMsg });
                                }
                            } catch (readError) {
                                console.error("Upload error - processing file content:", readError);
                                const errorMsg = `${Config.MESSAGES.UPLOAD_READ_ERROR_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_READ_ERROR_SUFFIX}`;
                                await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                resolveCommand({ success: false, error: errorMsg });
                            }
                        };
                        reader.onerror = async (e) => {
                            console.error("Upload error - reading file:", e);
                            const errorMsg = `${Config.MESSAGES.UPLOAD_READ_ERROR_PREFIX}${fileName}${Config.MESSAGES.UPLOAD_READ_ERROR_SUFFIX}`;
                            await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            resolveCommand({ success: false, error: errorMsg });
                        };
                        reader.readAsText(file);
                    };
                    fileInput.click(); 
                });
            }
            async function handleHistoryCmd(args, cmdOptions) {
                const history = HistoryManager.getFullHistory();
                if (history.length === 0) return { success: true, output: Config.MESSAGES.NO_COMMANDS_IN_HISTORY };
                return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') };
            }
            function _parseFindArgs(args) {
                let searchPathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL; 
                let pattern = null;

                const nameOptionIndex = args.indexOf('-name');
                if (nameOptionIndex === -1) { 
                    return { error: `usage: find [path] -name "<pattern>"` };
                }

                if (nameOptionIndex === 0) { 
                    if (args.length < 2) return { error: "missing pattern after -name" };
                    pattern = args[1];
                    if (args.length > 2) searchPathArg = args[2]; 
                } else { 
                    searchPathArg = args.slice(0, nameOptionIndex).join(' '); 
                    if (nameOptionIndex + 1 >= args.length) return { error: "missing pattern after -name" };
                    pattern = args[nameOptionIndex + 1];
                }
                
                if (pattern && pattern.length >= 2) {
                    const firstChar = pattern[0];
                    const lastChar = pattern[pattern.length - 1];
                    if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                        pattern = pattern.substring(1, pattern.length - 1);
                    }
                }
                if (!pattern) return { error: "pattern cannot be empty" };
                if (searchPathArg.trim() === "") searchPathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL; 

                return { searchPathArg, pattern, error: null };
            }
            function _findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) {
                if (!currentSearchNode || currentSearchNode.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return; 
                }
                const childrenNames = Object.keys(currentSearchNode.children).sort(); 
                for (const name of childrenNames) {
                    const childNode = currentSearchNode.children[name];
                    const childFullPath = FileSystemManager.getAbsolutePath(name, currentSearchPath);
                    
                    if (_matchFindPattern(name, pattern)) {
                        foundItems.push(childFullPath + (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? Config.FILESYSTEM.PATH_SEPARATOR : ''));
                    }
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        _findRecursive(childNode, childFullPath, pattern, foundItems);
                    }
                }
            }
            function _matchFindPattern(name, pattern) {
                let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&'); 
                regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.'); 
                const regex = new RegExp(`^${regexPattern}$`); 
                return regex.test(name);
            }
            async function handleFind(args, cmdOptions) {
                const commandName = 'find';
                const parsedArgs = _parseFindArgs(args);
                if (parsedArgs.error) return _createUsageError(commandName, parsedArgs.error); 
                
                const { searchPathArg, pattern } = parsedArgs;

                const validation = FileSystemManager.validatePath(commandName, searchPathArg, {
                    expectedType: 'any', 
                    defaultToCurrentIfEmpty: true
                });
                
                let startingNode = validation.node;
                let startingPath = validation.resolvedPath;

                if (validation.error) {
                    return { success: false, error: validation.error };
                }

                const foundItems = [];
                try {
                    if (startingNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        const fileName = startingPath.substring(startingPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        if (_matchFindPattern(fileName, pattern)) {
                            foundItems.push(startingPath);
                        }
                    } else if (startingNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        const dirName = startingPath === Config.FILESYSTEM.ROOT_PATH ? Config.FILESYSTEM.ROOT_PATH : startingPath.substring(startingPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        if (dirName && _matchFindPattern(dirName, pattern) && startingPath !== Config.FILESYSTEM.ROOT_PATH) {
                        }
                        _findRecursive(startingNode, startingPath, pattern, foundItems);
                    }
                } catch (e) { 
                     return { success: false, error: `${commandName}: ${e.message}` };
                }
                return { success: true, output: foundItems.length > 0 ? foundItems.join('\n') : "" }; 
            }
            async function handleCheckFailCmd(args, cmdOptions) {
                if (args.length === 0) {
                    return _createUsageError('check_fail', 'missing command to execute');
                }
                const subCommandStr = args[0]; 
                
                await OutputManager.appendToOutput(`check_fail: Executing '${subCommandStr}' (expected to fail)...`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                
                const subCmdResult = await processSingleCommand(subCommandStr, false); 

                if (!subCmdResult.success) { 
                    const successMsg = `check_fail: OK - Command '${subCommandStr}' correctly failed.`;
                    await OutputManager.appendToOutput(successMsg, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                    return { success: true, output: null }; 
                } else { 
                    const errorMsg = `check_fail: TEST FAILURE - Command '${subCommandStr}' succeeded but was expected to fail.`;
                    await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return { success: false, error: `TEST FAILURE: '${subCommandStr}' succeeded unexpectedly.` };
                }
            }
            
            // --- COMMANDS DICTIONARY ---
            const commands = {
                'ls': { handler: handleLs, summary: 'Lists directory contents.', usage: 'ls [path/to/directory]', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { handler: handleCd, summary: 'Changes current directory.', usage: 'cd <path/to/directory>', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { handler: handleMkdir, summary: 'Creates a new directory, including parents.', usage: 'mkdir <path/to/new_directory_name>', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { handler: handleTouch, summary: 'Creates an empty file or updates timestamp.', usage: 'touch <path/to/filename>', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { handler: handleCat, summary: 'Displays file contents.', usage: 'cat <path/to/filename>', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { handler: handleEcho, summary: 'Displays text, stripping outer quotes.', usage: 'echo [text]', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { handler: handleMv, summary: 'Moves or renames a file or directory.', usage: 'mv <source_path> <destination_path>', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { handler: handleCp, summary: 'Copies a file or directory.', usage: 'cp <source_path> <destination_path>', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { handler: handleRm, summary: 'Removes a file or directory (confirms unless forced).', usage: 'rm [-f|--force] <path/to/item>', syntax: 'rm [-f|--force] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation. The -f or --force option bypasses confirmation. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { handler: handlePwd, summary: 'Prints the current working directory path.', usage: 'pwd', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { handler: handleDate, summary: 'Displays the current date and time.', usage: 'date', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'run': { handler: handleRun, summary: 'Executes commands from a script file.', usage: 'run <path/to/scriptfile>', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'clear': { handler: handleClear, summary: 'Clears the terminal screen.', usage: 'clear', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { handler: handleRegisterCmd, summary: 'Creates a new user profile.', usage: 'register <username>', syntax: 'register USERNAME', details: 'Registers a new user. Usernames are unique. The username "Guest" is reserved.', examples: ['register myuser']},
                'login': { handler: handleLoginCmd, summary: 'Logs in as a specified user.', usage: 'login <username>', syntax: 'login USERNAME', details: 'Logs in as the specified USERNAME. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser']},
                'logout': { handler: handleLogoutCmd, summary: 'Logs out the current user.', usage: 'logout', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { handler: handleSavestate, summary: 'Manually saves the current session.', usage: 'savestate', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { handler: handleLoadstate, summary: 'Loads the last manually saved session (confirms).', usage: 'loadstate', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { handler: handleReset, summary: 'Performs a full factory reset (confirms).', usage: 'reset', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states. This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { handler: handleHelp, summary: 'Displays command list or brief help.', usage: 'help [command_name]', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
                'man': { handler: handleMan, summary: 'Displays detailed manual pages for commands.', usage: 'man <command_name>', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
                'edit': { handler: handleEditCmd, summary: 'Edits a text file or creates a new one.', usage: 'edit <path/to/filename>', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving, Ctrl+P to toggle preview for MD/HTML.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'tree': { handler: handleTree, summary: 'Displays directory structure as a tree.', usage: 'tree [path]', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { handler: handleFind, summary: 'Searches for files and directories.', usage: 'find [path] -name "<pattern>"', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'export': { handler: handleExport, summary: 'Exports a file to your local disk.', usage: 'export <path/to/filename>', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log'] },
                'backup': { handler: handleBackup, summary: 'Backs up current user session to a local file.', usage: 'backup', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup'] },
                'restore': { handler: handleRestore, summary: 'Restores a user session from a local backup file.', usage: 'restore', syntax: 'restore', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['restore'] },
                'upload': { handler: handleUpload, summary: 'Uploads a local file (.txt, .md, .html, .sh) to the current directory.', usage: 'upload', syntax: 'upload', details: 'Prompts you to select a local file (.txt, .md, .html, or .sh). The selected file\'s content will be saved into a new file with the same name in the current OopisOs directory. If a file with the same name already exists, it will be overwritten.', examples: ['upload'] },
                'history': { handler: handleHistoryCmd, summary: 'Displays the command history.', usage: 'history', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history'] },
                'check_fail': { 
                    handler: handleCheckFailCmd, 
                    summary: 'Runs a command and succeeds if the command fails.', 
                    usage: 'check_fail "<command_string>"', 
                    syntax: 'check_fail "COMMAND [ARGS...]"', 
                    details: 'Executes the specified COMMAND with its ARGS, all provided as a single quoted string. If the COMMAND fails, check_fail reports success and allows script execution to continue. If the COMMAND succeeds (unexpectedly for a failure test), check_fail reports an error and will cause the calling script (via `run`) to halt. Ensure the entire command to be checked, including any of its own arguments or redirection symbols (>, >>), is enclosed in one set of quotes.', 
                    examples: ['check_fail "ls /non_existent_directory"', 'check_fail "echo text > /a/file/that/should/fail_creation"'] 
                }
            };

            // Executes the appropriate command handler based on parsed command
            async function _executeCommandHandler(parsedCommand, cmdOptions) {
                const commandData = commands[parsedCommand.baseCommand.toLowerCase()];
                if (commandData && typeof commandData.handler === 'function') {
                    try {
                        return await commandData.handler(parsedCommand.args, cmdOptions);
                    } catch (e) { // Catch unexpected errors within a command handler
                        console.error(`Error in command handler for '${parsedCommand.baseCommand}':`, e);
                        return { success: false, error: `Command failed: ${e.message}` };
                    }
                } else if (parsedCommand.baseCommand) { // Command exists but no handler or not found
                    return { success: false, error: `${parsedCommand.baseCommand}: command not found` };
                } else { // Empty command string (should be caught earlier, but as a fallback)
                    return { success: true, output: "" };
                }
            }

            // Processes the output of a command, handling redirection and display
            async function _processCommandOutput(parsedCommand, cmdResult, isInteractive) {
                let finalResult = { ...cmdResult }; // Copy result to modify if needed

                if (parsedCommand.redirection && parsedCommand.redirection.file) {
                    const { type: redirType, file: redirFile } = parsedCommand.redirection;
                    const outputToRedirect = cmdResult.success ? (cmdResult.output || "") : (cmdResult.error || "");
                    
                    const redirValidation = FileSystemManager.validatePath('redirection', redirFile, {
                        expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, 
                        allowMissing: true,    
                        disallowRoot: true,    
                        defaultToCurrentIfEmpty: false
                    });

                    if (redirValidation.error) { 
                        await OutputManager.appendToOutput(redirValidation.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        finalResult = { success: false, error: redirValidation.error }; 
                    } else {
                        const absRedirectPath = redirValidation.resolvedPath;
                        const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absRedirectPath);

                        if (parentDirResult.error) { 
                            await OutputManager.appendToOutput(`Redirection error: ${parentDirResult.error}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            finalResult = { success: false, error: parentDirResult.error };
                        } else {
                            const parentNode = parentDirResult.parentNode;
                            const redirectFileName = absRedirectPath.substring(absRedirectPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            let existingContent = "";
                            if (redirType === 'append' && parentNode.children[redirectFileName]) {
                                existingContent = parentNode.children[redirectFileName].content || "";
                                if (existingContent && !existingContent.endsWith('\n') && outputToRedirect.length > 0) {
                                     existingContent += '\n';
                                }
                            }
                            parentNode.children[redirectFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: existingContent + outputToRedirect };
                            
                            if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                const saveErrorMsg = `Failed to save redirected output to '${redirFile}'.`;
                                await OutputManager.appendToOutput(saveErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                if (finalResult.success) {
                                    finalResult.error = (finalResult.error ? finalResult.error + "\n" : "") + saveErrorMsg;
                                }
                                finalResult.success = false; 
                            }
                        }
                    }
                    if(finalResult.success && !cmdResult.isHtmlOutput) finalResult.output = null;

                } else if (!cmdResult.isHtmlOutput) { 
                    if (cmdResult.error) {
                        await OutputManager.appendToOutput(cmdResult.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else if (cmdResult.output !== null && cmdResult.output !== undefined) {
                        await OutputManager.appendToOutput(cmdResult.output, { typeClass: cmdResult.messageType || null });
                    }
                }
                return finalResult;
            }

            // Finalizes UI after an interactive command is processed
            async function _finalizeInteractiveModeUI(originalCommandText) {
                TerminalUI.clearInput();
                TerminalUI.updatePrompt();
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput();
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                
                if (!TerminalUI.getIsNavigatingHistory() && originalCommandText.trim() !== "") {
                    HistoryManager.resetIndex();
                }
                TerminalUI.setIsNavigatingHistory(false); 
            }

            return {
                processSingleCommand,
                getLastCommandFailed: () => lastCommandFailed
            };
        })();

        // --- TERMINAL EVENT LISTENERS INITIALIZATION ---
        function initializeTerminalEventListeners() {
            DOM.terminalDiv.addEventListener('click', e => {
                if (EditorManager.isActive()) { return; }
                if (!DOM.editableInputDiv.contains(e.target) && !e.target.closest('button, a')) {
                     TerminalUI.focusInput();
                }
            });
            
            const getCurrentInputTarget = () => {
                 return DOM.editableInputDiv;
            };

            document.addEventListener('keydown', async e => {
                if (EditorManager.isActive()) return; 

                const activeInputTarget = getCurrentInputTarget();
                if (document.activeElement !== activeInputTarget && !activeInputTarget.contains(document.activeElement)) return;

                TerminalUI.setIsNavigatingHistory(false); 

                if (e.key === 'Enter') {
                    e.preventDefault(); 
                    const commandText = TerminalUI.getCurrentInputValue();
                    await CommandExecutor.processSingleCommand(commandText, true);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prevCommand = HistoryManager.getPrevious();
                    if (prevCommand !== null) {
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(prevCommand, true); 
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const nextCommand = HistoryManager.getNext();
                    if (nextCommand !== null) {
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(nextCommand, true); 
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault(); 
                    if (DOM.editableInputDiv && (document.activeElement === DOM.editableInputDiv || DOM.editableInputDiv.contains(document.activeElement))) {
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        
                        const range = selection.getRangeAt(0);
                        range.deleteContents(); 
                        
                        const tabNode = document.createTextNode(Config.EDITOR.TAB_REPLACEMENT); 
                        range.insertNode(tabNode);
                        
                        range.setStartAfter(tabNode);
                        range.setEndAfter(tabNode);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            });

            if (DOM.editableInputDiv) {
                DOM.editableInputDiv.addEventListener('paste', e => {
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' '));
                });
            }
        }

        // --- INITIALIZATION ON WINDOW LOAD ---
        window.onload = async () => {
            await OutputManager.appendToOutput("User accounts are now passwordless.");
            
            try {
                await IndexedDBManager.init(); 
                
                const guestUser = { name: UserManager.getDefaultUser() };
                UserManager.setCurrentUserObject(guestUser);
                
                await FileSystemManager.load(UserManager.getDefaultUser()); 
                SessionManager.loadAutomaticState(UserManager.getDefaultUser()); 
                
                initializeTerminalEventListeners(); 
                TerminalUI.focusInput(); 
                
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                await OutputManager.appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details and browser storage settings.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
            }
        };
    </script>
</body>
</html>
