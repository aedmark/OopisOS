<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 0.5.1, 'Simplified Playground'</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
            line-height: 1.2em;
        }

        .input-line-container {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }
        .prompt-container {
            display: flex;
            align-items: center;
            line-height: 1.2em;
            flex-shrink: 0;
            white-space: nowrap;
            padding-top: 0.1em;
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container {
            flex-grow: 1;
            min-width: 0;
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            outline: none;
            caret-color: #00ff00;
            color: #00ff00;
            width: 100%;
        }
        
        #hidden-legacy-input {
             position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;
        }

        .error-message { color: #ff4136; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .console-log-message { color: #aaaaaa; }
        .editor-message { color: #7fdbff; }
        
        .diag-output { color: #dddddd; }
        .diag-pass { color: #2ecc40 !important; font-weight: bold; }
        .diag-fail { color: #ff4136 !important; font-weight: bold; }
        .diag-detail { color: #bbbbbb; margin-left:15px;}
        .diag-section-title { color: #00ffff; font-weight: bold; margin-top: 8px; margin-bottom: 3px; }


        .directory-item { color: #7fdbff; }
        .file-item { color: #00ff00; }

        .help-command-name { color: #7fdbff; font-weight: bold; }
        .help-description { margin-left: 10px; }
        .man-section-title { color: #7fdbff; font-weight: bold; }
        .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }

        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; }
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        #editor-textarea-wrapper { border-right: 1px solid #333; }
        #editor-textarea { width: 100%; height: 100%; background-color: #0c0c0c; color: #00dd00; border: none; font-family: 'VT323', monospace; font-size: 1em; line-height: 1.2em; resize: none; outline: none; padding: 0; }
        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre > code { display: block; padding: 10px; overflow-x: auto; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }
        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            <input type="text" id="hidden-legacy-input" style="position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;">
        </div>
    </div>

    <script>
        const Config = (() => {
            'use strict';
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore"
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "0.5.1", 
                    DEFAULT_HOST_NAME: "OopisOs"
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                    RESERVED_USERNAMES: ["guest"]
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    MAX_ALIAS_EXPANSION_DEPTH: 10,
                    DEFAULT_TYPING_SPEED: 35,
                    PROMPT_CHAR: ">",
                    PROMPT_SEPARATOR: ":",
                    PROMPT_AT: "@"
                },
                STORAGE_KEYS: {
                    USER_CREDENTIALS: 'oopisOsUserCredentials', 
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                    ALIAS_FILE_PATH: "/.aliases"
                },
                CSS_CLASSES: {
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    EDITOR_MSG: 'editor-message',
                    DIAG_OUTPUT: 'diag-output',
                    DIAG_PASS: 'diag-pass',
                    DIAG_FAIL: 'diag-fail',
                    DIAG_DETAIL: 'diag-detail',
                    DIAG_SECTION_TITLE: 'diag-section-title',
                    DIR_ITEM: 'directory-item',
                    FILE_ITEM: 'file-item',
                    HELP_CMD_NAME: 'help-command-name',
                    HELP_DESC: 'help-description',
                    OUTPUT_LINE: 'output-line',
                    MAN_SECTION_TITLE: 'man-section-title',
                    MAN_SECTION_CONTENT: 'man-section-content',
                    MAN_EXAMPLE: 'man-example'
                },
                EDITOR: {
                    DEBOUNCE_DELAY_MS: 250,
                    TAB_REPLACEMENT: "\t",
                    CTRL_S_ACTION: 'save_exit',
                    CTRL_O_ACTION: 'exit_no_save',
                    CTRL_P_ACTION: 'toggle_preview',
                    DEFAULT_MODE: 'text',
                    MODES: {
                        TEXT: 'text',
                        MARKDOWN: 'markdown',
                        HTML: 'html'
                    },
                    EXTENSIONS_MAP: {
                        'md': 'markdown',
                        'html': 'html',
                        'htm': 'html'
                    },
                    VIEW_MODES: {
                        SPLIT: 'split',
                        EDIT_ONLY: 'edit',
                        PREVIEW_ONLY: 'preview'
                    }
                },
                FILESYSTEM: {
                    ROOT_PATH: '/',
                    CURRENT_DIR_SYMBOL: '.',
                    PARENT_DIR_SYMBOL: '..',
                    DEFAULT_DIRECTORY_TYPE: 'directory',
                    DEFAULT_FILE_TYPE: 'file',
                    PATH_SEPARATOR: '/'
                },
                MESSAGES: {
                    CONFIRMATION_PROMPT: "Type 'YES' (all caps) to confirm, or any other input to cancel.",
                    OPERATION_CANCELLED: "Operation cancelled.",
                    ALREADY_LOGGED_IN_AS_PREFIX: "Already logged in as '",
                    ALREADY_LOGGED_IN_AS_SUFFIX: "'.",
                    NO_ACTION_TAKEN: "No action taken.",
                    ALREADY_IN_DIRECTORY_PREFIX: "Already in '",
                    ALREADY_IN_DIRECTORY_SUFFIX: "'.",
                    DIRECTORY_EMPTY: "Directory is empty.",
                    TIMESTAMP_UPDATED_PREFIX: "Timestamp of '",
                    TIMESTAMP_UPDATED_SUFFIX: "' updated.",
                    FILE_CREATED_SUFFIX: "' created.",
                    DIRECTORY_CREATED_SUFFIX: "' created.",
                    ITEM_REMOVED_SUFFIX: "' removed.",
                    FORCIBLY_REMOVED_PREFIX: "Forcibly removed '",
                    FORCIBLY_REMOVED_SUFFIX: "'.",
                    REMOVAL_CANCELLED_PREFIX: "Removal of '",
                    REMOVAL_CANCELLED_SUFFIX: "' cancelled.",
                    MOVED_PREFIX: "Moved '",
                    MOVED_TO: "' to '",
                    MOVED_SUFFIX: "'.",
                    COPIED_PREFIX: "Copied '",
                    COPIED_TO: "' to '",
                    COPIED_SUFFIX: "'.",
                    SESSION_SAVED_FOR_PREFIX: "Session manually saved for ",
                    SESSION_LOADED_MSG: "Session loaded from manual save.",
                    LOAD_STATE_CANCELLED: "Load state cancelled.",
                    NO_MANUAL_SAVE_FOUND_PREFIX: "No manually saved state found for ",
                    WELCOME_PREFIX: "Welcome, ",
                    WELCOME_SUFFIX: "! Type 'help' for commands.",
                    EXPORTING_PREFIX: "Exporting '",
                    EXPORTING_SUFFIX: "'... Check your browser downloads.",
                    BACKUP_CREATING_PREFIX: "Creating backup '",
                    BACKUP_CREATING_SUFFIX: "'... Check your browser downloads.",
                    IMPORT_CANCELLED_NO_FILE: "Import cancelled: No file selected.",
                    IMPORT_SUCCESS_PREFIX: "Session for user '",
                    IMPORT_SUCCESS_MIDDLE: "' successfully imported and restored from '",
                    IMPORT_SUCCESS_SUFFIX: "'.",
                    ALIAS_UNSET_SUFFIX: " alias unset.",
                    ALIAS_SET_SUFFIX: " set.",
                    NO_ALIASES_DEFINED: "No aliases defined.",
                    NO_COMMANDS_IN_HISTORY: "No commands in history."
                },
                INTERNAL_ERRORS: {
                    DB_NOT_INITIALIZED_FS_SAVE: "DB not initialized for FS save",
                    DB_NOT_INITIALIZED_FS_LOAD: "DB not initialized for FS load",
                    DB_NOT_INITIALIZED_FS_DELETE: "DB not initialized for FS delete",
                    DB_NOT_INITIALIZED_FS_CLEAR: "DB not initialized for clearing all FS",
                    CORRUPTED_FS_DATA_PRE_SAVE: "Corrupted FS data before saving.",
                    REDIRECTION_FILE_NOT_SPECIFIED: "internal error: redirection file not specified.",
                    SOURCE_NOT_FOUND_IN_PARENT_PREFIX: "internal error: source '",
                    SOURCE_NOT_FOUND_IN_PARENT_MIDDLE: "' not found in parent '",
                    SOURCE_NOT_FOUND_IN_PARENT_SUFFIX: "'"
                },
                COMMAND_NAMES: {
                    RM: 'rm', LS: 'ls', CD: 'cd', MKDIR: 'mkdir', TOUCH: 'touch',
                    CAT: 'cat', ECHO: 'echo', MV: 'mv', CP: 'cp', PWD: 'pwd',
                    DATE: 'date', WHOAMI: 'whoami', RUN: 'run', GREP: 'grep',
                    SORT: 'sort', CLEAR: 'clear', REGISTER: 'register',
                    LOGIN: 'login', LOGOUT: 'logout', SAVESTATE: 'savestate',
                    LOADSTATE: 'loadstate', RESET: 'reset', HELP: 'help', MAN: 'man',
                    EDIT: 'edit', DIAG: 'diag', TREE: 'tree', FIND: 'find', DU: 'du',
                    HEAD: 'head', TAIL: 'tail', EXPORT: 'export', BACKUP: 'backup',
                    IMPORT: 'import', WC: 'wc', DIFF: 'diff', HISTORY: 'history',
                    ALIAS: 'alias', UNALIAS: 'unalias'
                },
                DIAGNOSTICS: {
                    TEST_USER_NAME: "__diag_test_user__", 
                    TEST_USER_PASS: "diagSecurePass123!", 
                    TEST_BASE_DIR_NAME: "__diag_tests__",
                    TEST_BASE_DIR_PATH_PREFIX: "/tmp/", 
                    DEFAULT_TEST_FILENAME: "testfile.txt",
                    DEFAULT_TEST_FILE_CONTENT: "content for diagnostics",
                    REDIRECT_TEST_FILENAME: "redir_diag.txt",
                    REDIRECT_TEST_CONTENT_OVERWRITE: "redirect overwrite test content",
                    REDIRECT_TEST_CONTENT_APPEND: "append test content",
                    WC_TEST_FILENAME: "wc_diag.txt",
                    WC_TEST_CONTENT: "one two three\nfour five six\n\nseven eight nine ten eleven",
                    HT_TEST_FILENAME: "ht_diag.txt",
                    HT_TEST_CONTENT: "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\nLine 11\nLine 12\nLine 13\nLine 14\nLine 15",
                    EMPTY_TEST_FILENAME: "empty_diag.txt",
                    DIFF_FILE1_NAME: "diff1_diag.txt",
                    DIFF_FILE1_CONTENT: "alpha\nbravo\ncharlie",
                    DIFF_FILE2_NAME: "diff2_diag.txt", 
                    DIFF_FILE2_CONTENT: "alpha\nbravo\ncharlie",
                    DIFF_FILE3_NAME: "diff3_diag.txt", 
                    DIFF_FILE3_CONTENT: "alpha\ndelta\nbravo\ncharlie",
                    DIFF_FILE4_NAME: "diff4_diag.txt", 
                    DIFF_FILE4_CONTENT: "alpha\ncharlie",
                    DIFF_FILE5_NAME: "diff5_diag.txt", 
                    DIFF_FILE5_CONTENT: "alpha\nbeta\ncharlie",
                }
            };
        })();

        const DOM = (() => {
            'use strict';
            return {
                terminalDiv: document.getElementById('terminal'),
                outputDiv: document.getElementById('output'),
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'),
                promptHostSpan: document.getElementById('prompt-host')
            };
        })();

        const Utils = (() => {
            'use strict';
            function formatConsoleArgs(args) {
                return Array.from(args)
                    .map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg))
                    .join(' ');
            }
            function deepCopyNode(node) {
                return node ? JSON.parse(JSON.stringify(node)) : null;
            }
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            function parseNumericOption(args, optionStr, defaultValue) {
                let numericValue = defaultValue;
                const remainingArgs = [...args];
                let error = null;
                const optionIndex = remainingArgs.indexOf(optionStr);
                if (optionIndex !== -1) {
                    if (optionIndex + 1 < remainingArgs.length) {
                        const potentialNumber = remainingArgs[optionIndex + 1];
                        const parsedNumber = parseInt(potentialNumber, 10);
                        if (!isNaN(parsedNumber) && parsedNumber >= 0) {
                            numericValue = parsedNumber;
                            remainingArgs.splice(optionIndex, 2);
                        } else {
                            error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`;
                            remainingArgs.splice(optionIndex, 2);
                        }
                    } else {
                        error = `option ${optionStr} requires an argument`;
                        remainingArgs.splice(optionIndex, 1);
                    }
                }
                return { value: numericValue, remainingArgs, error };
            }
            function findLCS(X, Y) {
                const m = X.length;
                const n = Y.length;
                const L = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
                for (let i = 0; i <= m; i++) {
                    for (let j = 0; j <= n; j++) {
                        if (i === 0 || j === 0) {
                            L[i][j] = 0;
                        } else if (X[i - 1] === Y[j - 1]) {
                            L[i][j] = L[i - 1][j - 1] + 1;
                        } else {
                            L[i][j] = Math.max(L[i - 1][j], L[i][j - 1]);
                        }
                    }
                }
                let index = L[m][n];
                const lcs = Array(index);
                let i = m, j = n;
                while (i > 0 && j > 0) {
                    if (X[i - 1] === Y[j - 1]) {
                        lcs[index - 1] = X[i - 1];
                        i--; j--; index--;
                    } else if (L[i - 1][j] > L[i][j - 1]) {
                        i--;
                    } else {
                        j--;
                    }
                }
                return lcs;
            }
            function getFileExtension(filePath) {
                if (!filePath || typeof filePath !== 'string') return '';
                const name = filePath.substring(filePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const lastDot = name.lastIndexOf('.');
                if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) {
                    return '';
                }
                return name.substring(lastDot + 1).toLowerCase();
            }
            return {
                formatConsoleArgs,
                deepCopyNode,
                formatBytes,
                parseNumericOption,
                findLCS,
                getFileExtension
            };
        })();

        const OutputManager = (() => {
            'use strict';
            let isEditorActive = false;
            let isDiagRunning = false;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;
            function setEditorActive(status) {
                isEditorActive = status;
            }
            function setDiagRunning(status) {
                isDiagRunning = status;
            }
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            async function _typeTextCinematically(element, text, speed) {
                for (const char of text) {
                    element.textContent += char;
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                    await sleep(speed);
                }
            }
            async function appendToOutput(text, options = {}) {
                if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MSG && !isDiagRunning) {
                    return;
                }
                const {
                    isInstant = false,
                    typingSpeed = Config.TERMINAL.DEFAULT_TYPING_SPEED,
                    isError = false,
                    typeClass = null
                } = options;
                const lines = String(text).split('\n');
                const forceInstant = isError ||
                                     typeClass === Config.CSS_CLASSES.WARNING_MSG ||
                                     typeClass === Config.CSS_CLASSES.CONSOLE_LOG_MSG ||
                                     typeClass === Config.CSS_CLASSES.DIAG_OUTPUT ||
                                     typeClass === Config.CSS_CLASSES.DIAG_PASS ||
                                     typeClass === Config.CSS_CLASSES.DIAG_FAIL ||
                                     typeClass === Config.CSS_CLASSES.DIAG_DETAIL ||
                                     typeClass === Config.CSS_CLASSES.DIAG_SECTION_TITLE ||
                                     (CommandExecutor && CommandExecutor.isDiagActive() && typeClass !== null);
                for (const line of lines) {
                    const newLine = document.createElement('div');
                    newLine.classList.add(Config.CSS_CLASSES.OUTPUT_LINE);
                    if (typeClass) {
                        newLine.classList.add(typeClass);
                    } else if (isError) {
                        newLine.classList.add(Config.CSS_CLASSES.ERROR_MSG);
                    }
                    DOM.outputDiv.appendChild(newLine);
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                    if (isInstant || forceInstant) {
                        newLine.textContent = line;
                    } else {
                        await _typeTextCinematically(newLine, line, typingSpeed);
                    }
                }
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }
            function appendHtmlToOutput(htmlContent) {
                if (isEditorActive && !isDiagRunning) return;
                const blockDiv = document.createElement('div');
                blockDiv.innerHTML = htmlContent;
                DOM.outputDiv.appendChild(blockDiv);
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }
            function clearOutput() {
                if (!isEditorActive) {
                    DOM.outputDiv.innerHTML = '';
                }
            }
            console.log = (...args) => {
                appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                originalConsoleLog.apply(console, args);
            };
            console.warn = (...args) => {
                appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                originalConsoleWarn.apply(console, args);
            };
            console.error = (...args) => {
                appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { isError: true });
                originalConsoleError.apply(console, args);
            };
            return {
                setEditorActive,
                setDiagRunning,
                appendToOutput,
                appendHtmlToOutput,
                clearOutput
            };
        })();

        const StorageManager = (() => {
            'use strict';
            function loadJSON(key, itemName, defaultValue = null) {
                try {
                    const storedValue = localStorage.getItem(key);
                    if (storedValue) {
                        return JSON.parse(storedValue);
                    }
                } catch (e) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                         OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                    }
                }
                return defaultValue;
            }
            function saveJSON(key, data, itemName) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { isInstant: true, isError: true });
                    }
                }
                return false;
            }
            function removeItem(key) {
                localStorage.removeItem(key);
            }
            function getAllLocalStorageKeys() {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    keys.push(localStorage.key(i));
                }
                return keys;
            }
            return {
                loadJSON,
                saveJSON,
                removeItem,
                getAllLocalStorageKeys
            };
        })();

        const IndexedDBManager = (() => {
            'use strict';
            let dbInstance = null;
            function init() {
                return new Promise((resolve, reject) => {
                    if (dbInstance) {
                        resolve(dbInstance);
                        return;
                    }
                    const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION);
                    request.onupgradeneeded = (event) => {
                        const tempDb = event.target.result;
                        if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) {
                            tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        if ((!CommandExecutor || !CommandExecutor.isDiagActive()) && !window.diagInitializedForOutput) {
                             OutputManager.appendToOutput("FileSystem DB initialized.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                             window.diagInitializedForOutput = true;
                        }
                        resolve(dbInstance);
                    };
                    request.onerror = (event) => {
                        console.error("Database error: ", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private browsing mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.", { isInstant: true, isError: true });
                        reject(event.target.error);
                    };
                });
            }
            function getDbInstance() {
                if (!dbInstance) {
                    OutputManager.appendToOutput("Error: OopisOs file system storage is not available. Please ensure browser storage is enabled.", { isInstant: true, isError: true });
                    throw new Error("IndexedDB not initialized.");
                }
                return dbInstance;
            }
            return {
                init,
                getDbInstance
            };
        })();

        const FileSystemManager = (() => {
            'use strict';
            let fsData = {};
            let currentPath = Config.FILESYSTEM.ROOT_PATH;
            function _getFileSystemKey(user) {
                return `fs_${user}`;
            }
            async function initialize(user) {
                fsData = {
                    [Config.FILESYSTEM.ROOT_PATH]: {
                        type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                        children: {}
                    }
                };
            }
            async function save(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { isInstant: true, isError: true });
                    }
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_SAVE);
                }
                return new Promise((resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const dataToSave = Utils.deepCopyNode(fsData);
                        if (!dataToSave || typeof dataToSave !== 'object' ||
                            !dataToSave[Config.FILESYSTEM.ROOT_PATH] ||
                            dataToSave[Config.FILESYSTEM.ROOT_PATH].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            console.error("Attempted to save invalid fsData structure for user:", user, dataToSave);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { isInstant: true, isError: true });
                            }
                            return reject(new Error(Config.INTERNAL_ERRORS.CORRUPTED_FS_DATA_PRE_SAVE));
                        }
                        const request = store.put({ id: _getFileSystemKey(user), data: dataToSave });
                        request.onsuccess = () => resolve(true);
                        request.onerror = (event) => {
                            console.error(`Error saving FS for ${user}:`, event.target.error);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { isInstant: true, isError: true });
                            }
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating save transaction for ${user}:`, e);
                         if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                            OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { isInstant: true, isError: true });
                         }
                        reject(e);
                    }
                });
            }
            async function load(user) {
                const db = IndexedDBManager.getDbInstance();
                 if (!db) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { isInstant: true, isError: true });
                    }
                    await initialize(user);
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_LOAD);
                }
                return new Promise(async (resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const request = store.get(_getFileSystemKey(user));
                        request.onsuccess = async (event) => {
                            const result = event.target.result;
                            if (result && result.data && result.data[Config.FILESYSTEM.ROOT_PATH]?.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                fsData = result.data;
                            } else {
                                const message = result ? `Warning: File system for '${user}' appears invalid. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`;
                                const messageType = result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG;
                                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                    OutputManager.appendToOutput(message, { isInstant: true, typeClass: messageType });
                                }
                                await initialize(user);
                                await save(user);
                            }
                            resolve();
                        };
                        request.onerror = async (event) => {
                            console.error(`Error loading FS for ${user}:`, event.target.error);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            }
                            await initialize(user);
                            await save(user);
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating load transaction for ${user}:`, e);
                        if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                             OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        }
                        await initialize(user);
                        await save(user);
                        reject(e);
                    }
                });
            }
            async function deleteUserFS(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_DELETE);
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.delete(_getFileSystemKey(user));
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error deleting FS for ${user}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            async function clearAllFS() {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                     OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { isInstant: true, isError: true });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_CLEAR);
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.clear();
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error("Error clearing FileSystemsStore:", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { isInstant: true, isError: true });
                        reject(event.target.error);
                    };
                });
            }
            function getCurrentPath() {
                return currentPath;
            }
            function setCurrentPath(path) {
                currentPath = path;
            }
            function getFsData() {
                return fsData;
            }
            function setFsData(newData) {
                fsData = newData;
            }
            function getAbsolutePath(targetPath, basePath) {
                if (!targetPath) targetPath = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                let effectiveBasePath = basePath;
                if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    effectiveBasePath = Config.FILESYSTEM.ROOT_PATH;
                }
                const baseSegments = effectiveBasePath === Config.FILESYSTEM.ROOT_PATH ? [] : effectiveBasePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s && s !== Config.FILESYSTEM.CURRENT_DIR_SYMBOL);
                let resolvedSegments = [...baseSegments];
                const targetSegments = targetPath.split(Config.FILESYSTEM.PATH_SEPARATOR);
                for (const segment of targetSegments) {
                    if (segment === '' || segment === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR) && resolvedSegments.length === 0 && segment === '') {
                        }
                        continue;
                    }
                    if (segment === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                        if (resolvedSegments.length > 0) {
                            resolvedSegments.pop();
                        }
                    } else {
                        resolvedSegments.push(segment);
                    }
                }
                if (resolvedSegments.length === 0) {
                    return Config.FILESYSTEM.ROOT_PATH;
                }
                return Config.FILESYSTEM.PATH_SEPARATOR + resolvedSegments.join(Config.FILESYSTEM.PATH_SEPARATOR);
            }
            function getNodeByPath(path) {
                const absolutePath = getAbsolutePath(path, currentPath);
                if (absolutePath === Config.FILESYSTEM.ROOT_PATH) {
                    return fsData[Config.FILESYSTEM.ROOT_PATH];
                }
                const segments = absolutePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                for (const segment of segments) {
                    if (currentNode && currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && currentNode.children && currentNode.children[segment]) {
                        currentNode = currentNode.children[segment];
                    } else {
                        return null;
                    }
                }
                return currentNode;
            }
            function createParentDirectoriesIfNeeded(fullPath) {
                if (fullPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: null, error: "Cannot create parent for root." };
                }
                const lastSlashIndex = fullPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                const parentPath = (lastSlashIndex === 0) ? Config.FILESYSTEM.ROOT_PATH : fullPath.substring(0, lastSlashIndex);
                const newFileName = fullPath.substring(lastSlashIndex + 1);
                if (!newFileName || newFileName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || newFileName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` };
                }
                if (parentPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: fsData[Config.FILESYSTEM.ROOT_PATH], error: null };
                }
                const parentPathSegments = parentPath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentDirNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                let currentBuiltParentPath = "";
                for (const segment of parentPathSegments) {
                    currentBuiltParentPath += Config.FILESYSTEM.PATH_SEPARATOR + segment;
                    if (!currentDirNode.children[segment]) {
                        currentDirNode.children[segment] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                    } else if (currentDirNode.children[segment].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                    }
                    currentDirNode = currentDirNode.children[segment];
                }
                return { parentNode: currentDirNode, error: null };
            }
            function calculateNodeSize(node) {
                if (!node) return 0;
                if (node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return (node.content || "").length;
                }
                if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    let totalSize = 0;
                    for (const childName in node.children) {
                        totalSize += calculateNodeSize(node.children[childName]);
                    }
                    return totalSize;
                }
                return 0;
            }
            function validatePath(commandName, pathArg, options = {}) {
                const {
                    expectedType = 'any',
                    allowMissing = false,
                    disallowRoot = false,
                    defaultToCurrentIfEmpty = true
                } = options;
                let effectivePathArg = pathArg;
                if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) {
                    effectivePathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                }
                if (effectivePathArg === undefined || effectivePathArg === null) {
                    return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
                }
                const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath());
                const node = getNodeByPath(resolvedPath);
                if (disallowRoot && resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '${Config.FILESYSTEM.ROOT_PATH}'` };
                }
                if (node) {
                    if (expectedType === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                    }
                    if (expectedType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                    }
                    return { node: node, resolvedPath: resolvedPath, error: null };
                } else {
                    if (allowMissing) {
                        return { node: null, resolvedPath: resolvedPath, error: null };
                    } else {
                        return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory` };
                    }
                }
            }
            return {
                initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath,
                getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded,
                calculateNodeSize, validatePath
            };
        })();

        const AliasManager = (() => {
            'use strict';
            let userAliases = {};
            async function load(currentUser) {
                userAliases = {};
                const aliasFileNode = FileSystemManager.getNodeByPath(Config.STORAGE_KEYS.ALIAS_FILE_PATH);
                if (aliasFileNode && aliasFileNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    try {
                        const parsed = JSON.parse(aliasFileNode.content);
                        if (typeof parsed === 'object' && parsed !== null) {
                            userAliases = parsed;
                        }
                    } catch (e) {
                        userAliases = {};
                    }
                }
            }
            async function save(currentUser) {
                const aliasJsonString = JSON.stringify(userAliases, null, 2);
                const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH;
                const rootNode = FileSystemManager.getFsData()[Config.FILESYSTEM.ROOT_PATH];
                if (rootNode && rootNode.children) {
                    const aliasFileName = aliasFilePath.substring(1);
                    rootNode.children[aliasFileName] = {
                        type: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                        content: aliasJsonString
                    };
                    await FileSystemManager.save(currentUser);
                } else {
                    OutputManager.appendToOutput("Error: Could not save aliases due to an internal file system inconsistency. Please report this issue.", { isInstant: true, isError: true });
                }
            }
            async function expand(commandInputText, depth = 0) {
                if (depth > Config.TERMINAL.MAX_ALIAS_EXPANSION_DEPTH) {
                    OutputManager.appendToOutput(`alias: Maximum expansion depth exceeded (possible loop).`, { isInstant: true, isError: true });
                    return commandInputText;
                }
                const parts = commandInputText.trim().split(' ');
                const potentialAlias = parts[0];
                if (userAliases.hasOwnProperty(potentialAlias)) {
                    const aliasValue = userAliases[potentialAlias];
                    const remainingArgs = parts.slice(1).join(' ');
                    const expandedCommand = (aliasValue + (remainingArgs ? ' ' + remainingArgs : '')).trim();
                    const nextPotentialAlias = expandedCommand.split(' ')[0];
                    if (userAliases.hasOwnProperty(nextPotentialAlias) && nextPotentialAlias !== potentialAlias) {
                        return await expand(expandedCommand, depth + 1);
                    }
                    return expandedCommand;
                }
                return commandInputText;
            }
            function getAliases() {
                return { ...userAliases };
            }
            function setAlias(name, value) {
                userAliases[name] = value;
            }
            function removeAlias(name) {
                delete userAliases[name];
            }
            function hasAlias(name) {
                return userAliases.hasOwnProperty(name);
            }
            return { load, save, expand, getAliases, setAlias, removeAlias, hasAlias };
        })();

        const HistoryManager = (() => {
            'use strict';
            let commandHistory = [];
            let historyIndex = 0;
            function add(command) {
                const trimmedCommand = command.trim();
                if (trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                    commandHistory.push(trimmedCommand);
                    if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) {
                        commandHistory.shift();
                    }
                }
                historyIndex = commandHistory.length;
            }
            function getPrevious() {
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    return commandHistory[historyIndex];
                }
                return null;
            }
            function getNext() {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    return commandHistory[historyIndex];
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    return "";
                }
                return null;
            }
            function resetIndex() {
                historyIndex = commandHistory.length;
            }
            function getFullHistory() {
                return [...commandHistory];
            }
            function clearHistory() {
                commandHistory = [];
                historyIndex = 0;
            }
            function setHistory(newHistory) {
                commandHistory = Array.isArray(newHistory) ? [...newHistory] : [];
                historyIndex = commandHistory.length;
            }
            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();

        const ConfirmationManager = (() => {
            'use strict';
            let awaitingConfirmation = false;
            let confirmationContext = null;
            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
                awaitingConfirmation = true;
                confirmationContext = {
                    promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                    data: dataForAction,
                    onConfirm: onConfirmCallback,
                    onCancel: onCancelCallback
                };
                confirmationContext.promptMessageLines.forEach(line =>
                    OutputManager.appendToOutput(line, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG })
                );
                OutputManager.appendToOutput(Config.MESSAGES.CONFIRMATION_PROMPT, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
            }
            async function handleConfirmation(input) {
                if (!awaitingConfirmation || !confirmationContext) return false;
                let processed = false;
                if (input.trim() === 'YES' && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                    processed = true;
                } else {
                    if (typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    }
                    processed = true;
                }
                awaitingConfirmation = false;
                confirmationContext = null;
                return processed;
            }
            function isAwaiting() {
                return awaitingConfirmation;
            }
            return { request, handleConfirmation, isAwaiting };
        })();

        const EditorManager = (() => {
            'use strict';
            let isActiveState = false;
            let currentFilePath = null;
            let currentFileMode = Config.EDITOR.DEFAULT_MODE;
            let currentViewMode = Config.EDITOR.VIEW_MODES.SPLIT;
            let debounceTimer = null;
            let editorContainerDiv = null;
            let editorControlsDiv = null;
            let editorFilenameDisplay = null;
            let viewToggleButton = null;
            let editorMainAreaDiv = null;
            let editorTextareaWrapper = null;
            let editorTextareaElement = null;
            let editorPreviewWrapper = null;
            let editorPreviewPaneDiv = null;
            let editorInstructionsFooter = null;
            function _determineMode(filePath) {
                const extension = Utils.getFileExtension(filePath);
                return Config.EDITOR.EXTENSIONS_MAP[extension] || Config.EDITOR.DEFAULT_MODE;
            }
            function _updatePreview() {
                if (!editorTextareaElement || !editorPreviewPaneDiv) return;
                const content = editorTextareaElement.value;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        if (typeof marked !== 'undefined') {
                            editorPreviewPaneDiv.innerHTML = marked.parse(content);
                        } else {
                            editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded.";
                        }
                    } else if (currentFileMode === Config.EDITOR.MODES.HTML) {
                        let iframe = editorPreviewPaneDiv.querySelector('iframe');
                        if (!iframe) {
                            iframe = document.createElement('iframe');
                            editorPreviewPaneDiv.innerHTML = '';
                            editorPreviewPaneDiv.appendChild(iframe);
                        }
                        iframe.srcdoc = content;
                    }
                }, Config.EDITOR.DEBOUNCE_DELAY_MS);
            }
            function _setupEditorLayout() {
                editorContainerDiv = document.createElement('div');
                editorContainerDiv.id = 'editor-container';
                editorControlsDiv = document.createElement('div');
                editorControlsDiv.id = 'editor-controls';
                editorFilenameDisplay = document.createElement('span');
                editorFilenameDisplay.id = 'editor-filename-display';
                editorFilenameDisplay.textContent = `File: ${currentFilePath}`;
                viewToggleButton = document.createElement('button');
                viewToggleButton.id = 'editor-view-toggle';
                viewToggleButton.addEventListener('click', _toggleViewMode);
                editorControlsDiv.appendChild(editorFilenameDisplay);
                editorControlsDiv.appendChild(viewToggleButton);
                editorContainerDiv.appendChild(editorControlsDiv);
                editorMainAreaDiv = document.createElement('div');
                editorMainAreaDiv.id = 'editor-main-area';
                editorTextareaWrapper = document.createElement('div');
                editorTextareaWrapper.id = 'editor-textarea-wrapper';
                editorTextareaWrapper.classList.add('editor-pane');
                editorTextareaElement = document.createElement('textarea');
                editorTextareaElement.id = 'editor-textarea';
                editorTextareaWrapper.appendChild(editorTextareaElement);
                editorMainAreaDiv.appendChild(editorTextareaWrapper);
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    editorPreviewWrapper = document.createElement('div');
                    editorPreviewWrapper.id = 'editor-preview-wrapper';
                    editorPreviewWrapper.classList.add('editor-pane');
                    editorPreviewPaneDiv = document.createElement('div');
                    editorPreviewPaneDiv.id = 'editor-preview-content';
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        editorPreviewPaneDiv.classList.add('markdown-preview');
                    }
                    editorPreviewWrapper.appendChild(editorPreviewPaneDiv);
                    editorMainAreaDiv.appendChild(editorPreviewWrapper);
                    _setViewModeUI(currentViewMode);
                } else {
                    viewToggleButton.style.display = 'none';
                    editorTextareaWrapper.style.borderRight = 'none';
                }
                editorContainerDiv.appendChild(editorMainAreaDiv);
                editorInstructionsFooter = document.createElement('div');
                editorInstructionsFooter.id = 'editor-instructions-footer';
                editorInstructionsFooter.textContent = `Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving | Ctrl+P: Toggle Preview (MD/HTML)`;
                editorContainerDiv.appendChild(editorInstructionsFooter);
                DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv);
            }
            function _setViewModeUI(mode) {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                currentViewMode = mode;
                const showTextarea = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                const showPreview = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY;
                editorTextareaWrapper.style.display = showTextarea ? "block" : "none";
                editorPreviewWrapper.style.display = showPreview ? "block" : "none";
                if (mode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    viewToggleButton.textContent = "Edit Only";
                    editorTextareaWrapper.style.flex = "1";
                    editorPreviewWrapper.style.flex = "1";
                    editorTextareaWrapper.style.borderRight = '1px solid #333';
                } else if (mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                    viewToggleButton.textContent = "Preview Only";
                    editorTextareaWrapper.style.flex = "2";
                    editorTextareaWrapper.style.borderRight = 'none';
                } else if (mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY) {
                    viewToggleButton.textContent = "Split View";
                    editorPreviewWrapper.style.flex = "2";
                }
            }
            function _toggleViewMode() {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                if (currentViewMode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.EDIT_ONLY);
                } else if (currentViewMode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                     _setViewModeUI(Config.EDITOR.VIEW_MODES.PREVIEW_ONLY);
                } else {
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.SPLIT);
                }
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") {
                    editorTextareaElement.focus();
                }
            }
            function enter(filePath, content) {
                if (isActiveState) {
                    OutputManager.appendToOutput("Editor already active.", { isInstant: true, typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                    return;
                }
                isActiveState = true;
                OutputManager.setEditorActive(true);
                currentFilePath = filePath;
                currentFileMode = _determineMode(filePath);
                currentViewMode = (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML)
                                  ? Config.EDITOR.VIEW_MODES.SPLIT
                                  : Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                DOM.outputDiv.style.display = 'none';
                DOM.inputLineContainerDiv.style.display = 'none';
                _setupEditorLayout();
                editorTextareaElement.value = content;
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview();
                    editorTextareaElement.addEventListener('input', _updatePreview);
                }
                editorTextareaElement.focus();
                editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
                editorTextareaElement.addEventListener('keydown', handleKeyDown);
            }
            async function exit(saveChanges = false) {
                let success = true;
                if (saveChanges && editorTextareaElement && currentFilePath) {
                    const newContent = editorTextareaElement.value;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath);
                    if (parentDirResult.error) {
                        OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { isInstant: true, isError: true, typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                        success = false;
                    } else {
                        const parentNode = parentDirResult.parentNode;
                        if (parentNode) {
                            const fileName = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: newContent };
                            const currentUser = UserManager.getCurrentUser();
                            if (currentUser) {
                                if (await FileSystemManager.save(currentUser.name)) {
                                    OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                } else {
                                    OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { isInstant: true, isError: true });
                                    success = false;
                                }
                            } else {
                                OutputManager.appendToOutput(`Error saving file: No current user context.`, { isInstant: true, isError: true });
                                success = false;
                            }
                        } else {
                             OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { isInstant: true, isError: true });
                             success = false;
                        }
                    }
                } else if (currentFilePath) {
                    OutputManager.appendToOutput(`Exited editor for '${currentFilePath}' without saving.`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) {
                    DOM.terminalDiv.removeChild(editorContainerDiv);
                }
                if (editorTextareaElement) {
                    editorTextareaElement.removeEventListener('keydown', handleKeyDown);
                    editorTextareaElement.removeEventListener('input', _updatePreview);
                }
                editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = null;
                editorMainAreaDiv = editorTextareaWrapper = editorTextareaElement = null;
                editorPreviewWrapper = editorPreviewPaneDiv = editorInstructionsFooter = null;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = null;
                isActiveState = false;
                OutputManager.setEditorActive(false);
                currentFilePath = null;
                currentFileMode = Config.EDITOR.DEFAULT_MODE;
                DOM.outputDiv.style.display = '';
                DOM.inputLineContainerDiv.style.display = '';
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                TerminalUI.focusInput();
                TerminalUI.updatePrompt();
                return success;
            }
            async function handleKeyDown(event) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + Config.EDITOR.TAB_REPLACEMENT + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + Config.EDITOR.TAB_REPLACEMENT.length;
                    return;
                }
                if (event.ctrlKey) {
                    switch (event.key.toLowerCase()) {
                        case 's':
                            event.preventDefault();
                            await exit(true);
                            break;
                        case 'o':
                            event.preventDefault();
                            await exit(false);
                            break;
                        case 'p':
                            event.preventDefault();
                            if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                                _toggleViewMode();
                            }
                            break;
                    }
                }
            }
            return { isActive: () => isActiveState, enter, exit };
        })();

        const UserManager = (() => {
            'use strict';
            let currentUser = { name: Config.USER.DEFAULT_NAME }; 
            function getCurrentUser() {
                return currentUser;
            }
            async function register(username) {
                const users = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (users[username]) {
                    return { success: false, error: `User '${username}' already exists.` };
                }
                if (Config.USER.RESERVED_USERNAMES.includes(username.toLowerCase())) {
                     return { success: false, error: `Cannot register '${username}'. This username is reserved.` };
                }
                if (username.includes(" ")) {
                    return { success: false, error: "Username cannot contain spaces." };
                }

                users[username] = {}; // Store user, no password data needed
                if (StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, users, "User list")) {
                    await FileSystemManager.initialize(username);
                    await FileSystemManager.save(username);
                    await AliasManager.load(username);
                    return { success: true, message: `User '${username}' registered. You can now login.` };
                } else {
                    return { success: false, error: "Failed to save new user." };
                }
            }
            async function login(username) {
                if (currentUser.name === username && (!CommandExecutor || !CommandExecutor.isDiagActive())) {
                    return { success: true, message: `${Config.MESSAGES.ALREADY_LOGGED_IN_AS_PREFIX}${username}${Config.MESSAGES.ALREADY_LOGGED_IN_AS_SUFFIX}`, noAction: true };
                }

                const users = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (!users.hasOwnProperty(username)) {
                     return { success: false, error: "Invalid username." };
                }
                
                if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username && (!CommandExecutor || !CommandExecutor.isDiagActive())) {
                    SessionManager.saveAutomaticState(currentUser.name);
                }

                currentUser = { name: username };
                HistoryManager.clearHistory();
                await FileSystemManager.load(username);
                await AliasManager.load(username);
                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                    SessionManager.loadAutomaticState(username);
                }
                TerminalUI.updatePrompt();
                return { success: true, message: `Logged in as ${username}.` };
            }
            async function logout() {
                if (currentUser.name === Config.USER.DEFAULT_NAME) {
                    return { success: true, message: `Already logged in as Guest. ${Config.MESSAGES.NO_ACTION_TAKEN}`, noAction: true };
                }
                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                    SessionManager.saveAutomaticState(currentUser.name);
                }
                const prevUserName = currentUser.name;
                currentUser = { name: Config.USER.DEFAULT_NAME };
                HistoryManager.clearHistory();
                await FileSystemManager.load(Config.USER.DEFAULT_NAME);
                await AliasManager.load(Config.USER.DEFAULT_NAME);
                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                    SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME);
                }
                TerminalUI.updatePrompt();
                return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` };
            }
            function setCurrentUserObject(userObject) {
                currentUser = userObject;
            }
            function getDefaultUser() {
                return Config.USER.DEFAULT_NAME;
            }
            return {
                getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser
            };
        })();

        const SessionManager = (() => {
            'use strict';
            function _getAutomaticSessionStateKey(user) {
                return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`;
            }
            function _getManualUserTerminalStateKey(user) {
                return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${user.name || user}`;
            }
            function saveAutomaticState(username) {
                const currentInput = TerminalUI.getCurrentInputValue();
                const autoState = {
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML,
                    currentInput: currentInput,
                    commandHistory: HistoryManager.getFullHistory()
                };
                StorageManager.saveJSON(_getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`);
            }
            function loadAutomaticState(username) {
                const autoState = StorageManager.loadJSON(_getAutomaticSessionStateKey(username), `Auto session for ${username}`);
                const isDiag = CommandExecutor && CommandExecutor.isDiagActive();
                if (autoState) {
                    FileSystemManager.setCurrentPath(autoState.currentPath || Config.FILESYSTEM.ROOT_PATH);
                    if (!isDiag && autoState.hasOwnProperty('outputHTML')) {
                        DOM.outputDiv.innerHTML = autoState.outputHTML || '';
                    } else if (!isDiag && !autoState.hasOwnProperty('outputHTML')) {
                        if(!isDiag) DOM.outputDiv.innerHTML = '';
                    }
                    TerminalUI.setCurrentInputValue(autoState.currentInput || '');
                    HistoryManager.setHistory(autoState.commandHistory || []);
                } else {
                    if (!isDiag) DOM.outputDiv.innerHTML = '';
                    TerminalUI.setCurrentInputValue('');
                    FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH);
                    HistoryManager.clearHistory();
                    if (!isDiag) {
                        OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`, { isInstant: true });
                    }
                }
                TerminalUI.updatePrompt();
                if (!isDiag) {
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                }
                return !!autoState;
            }
            async function saveManualState() {
                const currentUser = UserManager.getCurrentUser();
                const currentInput = TerminalUI.getCurrentInputValue();
                const manualStateData = {
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML,
                    currentInput: currentInput,
                    fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    commandHistory: HistoryManager.getFullHistory()
                };
                if (StorageManager.saveJSON(_getManualUserTerminalStateKey(currentUser), manualStateData, `Manual save for ${currentUser.name}`)) {
                    return { success: true, message: `${Config.MESSAGES.SESSION_SAVED_FOR_PREFIX}${currentUser.name}.` };
                } else {
                    return { success: false, error: "Failed to save session." };
                }
            }
            async function loadManualState() {
                const currentUser = UserManager.getCurrentUser();
                const manualStateData = StorageManager.loadJSON(_getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`);
                if (manualStateData) {
                    ConfirmationManager.request(
                        [`Load manually saved state for '${currentUser.name}'? This overwrites current session & filesystem.`],
                        { pendingData: manualStateData, userName: currentUser.name },
                        async (data) => {
                            FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                            FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                            DOM.outputDiv.innerHTML = data.pendingData.outputHTML || '';
                            TerminalUI.setCurrentInputValue(data.pendingData.currentInput || '');
                            HistoryManager.setHistory(data.pendingData.commandHistory || []);
                            await FileSystemManager.save(data.userName);
                            OutputManager.appendToOutput(Config.MESSAGES.SESSION_LOADED_MSG, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                            TerminalUI.updatePrompt();
                            DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        },
                        () => {
                            OutputManager.appendToOutput(Config.MESSAGES.LOAD_STATE_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, message: "Confirmation requested for loading state." };
                } else {
                    return { success: false, message: `${Config.MESSAGES.NO_MANUAL_SAVE_FOUND_PREFIX}${currentUser.name}.` };
                }
            }
            async function performFullReset() {
                OutputManager.clearOutput();
                TerminalUI.clearInput();
                const keysToRemove = [];
                const allKeys = StorageManager.getAllLocalStorageKeys();
                allKeys.forEach(key => {
                    if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) ||
                        key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) ||
                        key === Config.STORAGE_KEYS.USER_CREDENTIALS) {
                        keysToRemove.push(key);
                    }
                });
                keysToRemove.forEach(key => StorageManager.removeItem(key));
                await OutputManager.appendToOutput("All session states and credentials cleared from local storage.", { isInstant: true });
                try {
                    await FileSystemManager.clearAllFS();
                    await OutputManager.appendToOutput("All user filesystems cleared from DB.", { isInstant: true });
                } catch (error) {
                }
                HistoryManager.clearHistory();
                const guestUser = { name: Config.USER.DEFAULT_NAME };
                UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.initialize(Config.USER.DEFAULT_NAME);
                await FileSystemManager.save(Config.USER.DEFAULT_NAME);
                await AliasManager.load(Config.USER.DEFAULT_NAME);
                loadAutomaticState(Config.USER.DEFAULT_NAME);
                await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                TerminalUI.updatePrompt();
            }
            return {
                saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset
            };
        })();

        const TerminalUI = (() => {
            'use strict';
            let isNavigatingHistory = false;
            function updatePrompt() {
                const user = UserManager.getCurrentUser();
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.DEFAULT_HOST_NAME;
                DOM.promptPathSpan.textContent = FileSystemManager.getCurrentPath().trim() === '' ? Config.FILESYSTEM.ROOT_PATH : FileSystemManager.getCurrentPath();
            }
            function focusInput() {
                 if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.focus();
                    if (DOM.editableInputDiv.textContent.length === 0) {
                        setCaretToEnd(DOM.editableInputDiv);
                    }
                }
            }
            function clearInput() {
                if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = '';
            }
            function getCurrentInputValue() {
                return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : '';
            }
            function setCurrentInputValue(value, setAtEnd = true) {
                if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.textContent = value;
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv);
                }
            }
            function setCaretToEnd(element) {
                if (!element) return;
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(element);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            }
            function isPasswordInputActiveState() { return false; } 
            function getPasswordContext() { return null; }
            function switchToPasswordInput(promptContext) { /* No longer used */ }
            function switchToEditableInput() { /* No longer used, always editable */ }

            function setIsNavigatingHistory(status) {
                isNavigatingHistory = status;
            }
            function getIsNavigatingHistory() {
                return isNavigatingHistory;
            }
            return {
                updatePrompt, focusInput, clearInput, setCurrentInputValue, getCurrentInputValue,
                isPasswordInputActiveState, getPasswordContext, switchToPasswordInput,
                switchToEditableInput, setCaretToEnd, setIsNavigatingHistory, getIsNavigatingHistory
            };
        })();

        const CommandExecutor = (() => {
            'use strict';
            let lastCommandFailed = false;
            let isDiagActiveState = false;
            
            async function processSingleCommand(rawCommandText, isInteractive = true) {
                lastCommandFailed = false;
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false, awaitingPassword: false };
                if (EditorManager.isActive() && !isDiagActiveState) return finalResult;
                if (ConfirmationManager.isAwaiting()) {
                    await ConfirmationManager.handleConfirmation(rawCommandText);
                     if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }
                let commandToExecute = rawCommandText.trim();
                let executedCommandTextForDisplay = commandToExecute;
                
                if (isInteractive) {
                    DOM.inputLineContainerDiv.style.visibility = 'hidden';
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                    await OutputManager.appendToOutput(`${promptText}${executedCommandTextForDisplay}`, { isInstant: true });
                }
                if (commandToExecute === '') {
                    if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }
                if (isInteractive) {
                    HistoryManager.add(rawCommandText.trim());
                }
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) {
                     HistoryManager.resetIndex();
                }
                const expandedCommandText = await AliasManager.expand(commandToExecute);
                if (commandToExecute !== expandedCommandText && isInteractive) {
                    await OutputManager.appendToOutput(`> ${expandedCommandText}`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                const parsedCommand = _parseInputAndRedirection(rawCommandText.trim(), expandedCommandText);
                const cmdOptions = {
                    force: (parsedCommand.baseCommand === Config.COMMAND_NAMES.RM && !isInteractive) ||
                           (parsedCommand.args.includes('-f') || parsedCommand.args.includes('--force'))
                };
                const cmdResult = await _executeCommandHandler(parsedCommand, cmdOptions);
                finalResult = await _processCommandOutput(parsedCommand, cmdResult, isInteractive);
                if (isInteractive) { // No more awaitingPassword state
                    await _finalizeInteractiveModeUI();
                }
                return finalResult;
            }

            const commandHelpData = {
                'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms unless forced).', syntax: 'rm [-f] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation. The -f or --force option bypasses confirmation (used internally by scripts). The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
                'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
                'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
                'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { usage: 'register <username>', summary: 'Creates a new user profile.', syntax: 'register USERNAME', details: 'Registers a new user. Usernames are unique. The username "Guest" is reserved.', examples: ['register myuser']},
                'login': { usage: 'login <username>', summary: 'Logs in as a specified user.', syntax: 'login USERNAME', details: 'Logs in as the specified USERNAME. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser']},
                'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states. This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
                'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
                'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving, Ctrl+P to toggle preview for MD/HTML.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
                'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
                'head': { usage: 'head [-n N] <filename>', summary: 'Displays the beginning of a file.', syntax: 'head [-n N] FILE', details: 'Prints the first N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt'] },
                'tail': { usage: 'tail [-n N] <filename>', summary: 'Displays the end of a file.', syntax: 'tail [-n N] FILE', details: 'Prints the last N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt'] },
                'export': { usage: 'export <path/to/filename>', summary: 'Exports a file to your local disk.', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log'] },
                'backup': { usage: 'backup', summary: 'Backs up current user session to a local file.', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup'] },
                'import': { usage: 'import', summary: 'Imports a user session from a local backup file.', syntax: 'import', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['import'] },
                'wc': { usage: 'wc [-l] [-w] [-c] <filename>', summary: 'Counts lines, words, and bytes in a file.', syntax: 'wc [OPTION]... [FILE]', details: 'Prints newline, word, and byte counts for the specified FILE. A word is a non-zero-length sequence of characters delimited by white space. With no OPTION, prints all three counts.\n  -c, --bytes         print the byte counts\n  -l, --lines         print the newline counts\n  -w, --words         print the word counts', examples: ['wc myfile.txt', 'wc -l story.txt', 'wc -w -c report.doc', 'wc -lwc data.csv'] },
                'diff': { usage: 'diff <file1> <file2>', summary: 'Compares two files line by line.', syntax: 'diff FILE1 FILE2', details: 'Compares FILE1 and FILE2 line by line and outputs the differences. Common lines are prefixed with two spaces. Lines unique to FILE1 are prefixed with "< ". Lines unique to FILE2 are prefixed with "> ".', examples: ['diff old_version.txt new_version.txt', 'diff /config/main.conf /config/backup.conf'] },
                'history': { usage: 'history', summary: 'Displays the command history.', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history'] },
                'alias': { usage: 'alias [name[=value] ...]', summary: 'Define or display aliases.', syntax: 'alias [NAME[=VALUE]...]', details: '`alias` with no arguments prints the list of aliases in the form `name=\'value\'`.\n`alias name` prints the alias for `name`.\n`alias name=value` defines an alias. `value` can be a string containing commands. If `value` contains spaces, it should be quoted.\n`alias name=` unsets the alias `name`.', examples: ['alias', 'alias ll', "alias ll='ls -alF'", "alias mydocs='cd /home/user/documents'", "alias lsl="] },
                'unalias': { usage: 'unalias <name>', summary: 'Remove an alias.', syntax: 'unalias NAME', details: 'Removes the alias specified by NAME from the current user\'s alias list.', examples: ['unalias ll'] }
            };

            async function handleLs(args, cmdOptions) {
                const targetPathArg = args[0];
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.LS, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                if (validation.error) return { success: false, error: validation.error };
                const childrenNames = Object.keys(validation.node.children).sort();
                if (childrenNames.length === 0) return { success: true, output: Config.MESSAGES.DIRECTORY_EMPTY };
                let outputLines = [];
                childrenNames.forEach(name => {
                    const childNode = validation.node.children[name];
                    let line = name;
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        line += Config.FILESYSTEM.PATH_SEPARATOR;
                    }
                    outputLines.push(line);
                });
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleCd(args, cmdOptions) {
                const targetPathArg = args[0];
                if (targetPathArg === undefined) return { success: false, error: `cd: missing operand\nUsage: ${commandHelpData.cd.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CD, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                if (validation.resolvedPath === FileSystemManager.getCurrentPath()) {
                    return { success: true, output: `${Config.MESSAGES.ALREADY_IN_DIRECTORY_PREFIX}${validation.resolvedPath}${Config.MESSAGES.ALREADY_IN_DIRECTORY_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                FileSystemManager.setCurrentPath(validation.resolvedPath);
                TerminalUI.updatePrompt();
                return { success: true, output: null };
            }
            async function handleMkdir(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return { success: false, error: `mkdir: missing operand\nUsage: ${commandHelpData.mkdir.usage}` };
                if (fullPathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || fullPathArg === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MKDIR, fullPathArg, {
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error && validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` };
                }
                if (validation.error && validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { success: false, error: validation.error };
                }
                if (validation.error && !validation.node && !validation.optionsUsed?.allowMissing) {
                     return { success: false, error: validation.error };
                }
                const targetAbsPath = validation.resolvedPath;
                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` };
                const parentNode = parentDirResult.parentNode;
                if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}'` };
                const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` };
                parentNode.children[dirToCreateName] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `Directory '${fullPathArg}${Config.MESSAGES.DIRECTORY_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleTouch(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return { success: false, error: `touch: missing file operand\nUsage: ${commandHelpData.touch.usage}` };
                if (fullPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                     return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.TOUCH, fullPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const targetAbsPath = validation.resolvedPath;
                if (validation.node) {
                    return { success: true, output: `${Config.MESSAGES.TIMESTAMP_UPDATED_PREFIX}${fullPathArg}${Config.MESSAGES.TIMESTAMP_UPDATED_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` };
                const parentNode = parentDirResult.parentNode;
                 if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}'`};
                const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: "" };
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                     return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `File '${fullPathArg}${Config.MESSAGES.FILE_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCat(args, cmdOptions) {
                const targetPathArg = args[0];
                if (!targetPathArg) return { success: false, error: `cat: missing file operand\nUsage: ${commandHelpData.cat.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CAT, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                return { success: true, output: validation.node.content };
            }
            async function handleEcho(args, cmdOptions) {
                let outputString = args.join(' ');
                if (outputString.length >= 2) {
                    const firstChar = outputString[0];
                    const lastChar = outputString[outputString.length - 1];
                    if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                        outputString = outputString.substring(1, outputString.length - 1);
                    }
                }
                return { success: true, output: outputString };
            }
            async function handleMv(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: "mv: missing source and/or destination operands" };
                const sourcePathArg = args[0], destPathArg = args[1];
                const sourceValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MV, sourcePathArg, {
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;
                const destValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MV, destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (destValidation.error && !(destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE )) {
                     return { success: false, error: destValidation.error };
                }
                let absDestPath = destValidation.resolvedPath;
                const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath);
                if (!sourceParentNode || !sourceParentNode.children || !sourceParentNode.children[sourceName]) {
                    return { success: false, error: `${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX}${sourceName}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE}${sourceParentPath}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX}` };
                }
                let finalDestParentNode, finalDestName;
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName;
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath);
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                    if(parentDirResult.error) return { success: false, error: `mv: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `mv: could not obtain parent for '${absDestPath}'`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }
                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mv: invalid destination name '${finalDestName}'` };
                }
                if (absSourcePath === absDestPath) {
                    return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                if (finalDestParentNode.children[finalDestName]) {
                    return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destValidation.node ? destPathArg : absDestPath.substring(0, absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH }'.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one of its subdirectories ('${destPathArg}')` };
                }
                finalDestParentNode.children[finalDestName] = sourceNode;
                delete sourceParentNode.children[sourceName];
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: "mv: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.MOVED_PREFIX}${sourcePathArg}${Config.MESSAGES.MOVED_TO}${destPathArg}${Config.MESSAGES.MOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCp(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: "cp: missing source and/or destination operands" };
                const sourcePathArg = args[0], destPathArg = args[1];
                const sourceValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CP, sourcePathArg, {
                    disallowRoot: false,
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;
                const destValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CP, destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (destValidation.error && !(destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE)) {
                     return { success: false, error: destValidation.error };
                }
                let absDestPath = destValidation.resolvedPath;
                const sourceName = absSourcePath === Config.FILESYSTEM.ROOT_PATH ? 'root_copy' : absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                let finalDestParentNode, finalDestName;
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName;
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath);
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                     if(parentDirResult.error) return { success: false, error: `cp: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `cp: could not obtain parent for '${absDestPath}'`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }
                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `cp: invalid destination name '${finalDestName}'` };
                }
                if (finalDestParentNode.children[finalDestName]) {
                    return { success: false, error: `cp: destination '${finalDestName}' already exists.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `cp: cannot copy a directory into itself or one of its subdirectories.` };
                }
                const copiedNode = Utils.deepCopyNode(sourceNode);
                if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` };
                finalDestParentNode.children[finalDestName] = copiedNode;
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: "cp: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.COPIED_PREFIX}${sourcePathArg}${Config.MESSAGES.COPIED_TO}${destPathArg}${Config.MESSAGES.COPIED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleRm(args, cmdOptions = {}) {
                const { force: initialForce } = cmdOptions;
                let effectiveForce = initialForce;
                const remainingArgs = [...args];
                let pathArgForValidation;
                const forceFlagIndex = remainingArgs.findIndex(arg => arg === '-f' || arg === '--force');
                if (forceFlagIndex !== -1) {
                    effectiveForce = true;
                    remainingArgs.splice(forceFlagIndex, 1);
                }
                pathArgForValidation = remainingArgs[0];
                if (!pathArgForValidation) return { success: false, error: `rm: missing operand\nUsage: ${commandHelpData.rm.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.RM, pathArgForValidation, {
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) {
                    if (effectiveForce && validation.error.includes("No such file or directory")) {
                        return { success: true, output: null };
                    }
                    return { success: false, error: validation.error };
                }
                const itemType = validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? 'directory' : 'file';
                const dataForConfirm = {
                    path: validation.resolvedPath,
                    arg: pathArgForValidation,
                    userName: UserManager.getCurrentUser().name
                };
                if (effectiveForce) {
                    const parentPath = dataForConfirm.path.substring(0, dataForConfirm.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                    const itemName = dataForConfirm.path.substring(dataForConfirm.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const parentNode = FileSystemManager.getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await FileSystemManager.save(dataForConfirm.userName)) {
                            return { success: false, error: `Error saving filesystem after force removing '${dataForConfirm.path}'.` };
                        } else {
                            return { success: true, output: `${Config.MESSAGES.FORCIBLY_REMOVED_PREFIX}${pathArgForValidation}${Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                    } else {
                        return { success: false, error: `Error force removing '${dataForConfirm.path}': Item not found or parent changed.` };
                    }
                } else {
                    ConfirmationManager.request(
                        [`Are you sure you want to remove ${itemType} '${pathArgForValidation}'? This action cannot be undone.`],
                        dataForConfirm,
                        async (data) => {
                            const parentPath = data.path.substring(0, data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                            const itemName = data.path.substring(data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            const parentNode = FileSystemManager.getNodeByPath(parentPath);
                            if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                delete parentNode.children[itemName];
                                if(!await FileSystemManager.save(data.userName)) {
                                    await OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'.`, { isInstant: true, isError: true });
                                } else {
                                    await OutputManager.appendToOutput(`'${data.arg}${Config.MESSAGES.ITEM_REMOVED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                }
                            } else {
                                await OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, { isInstant: true, isError: true });
                            }
                        },
                        (data) => {
                            OutputManager.appendToOutput(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${data.arg || 'item'}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, output: null };
                }
            }
            async function handlePwd(args, cmdOptions) {
                return { success: true, output: FileSystemManager.getCurrentPath() };
            }
            async function handleDate(args, cmdOptions) {
                return { success: true, output: new Date().toString() };
            }
            async function handleWhoami(args, cmdOptions) {
                return { success: true, output: UserManager.getCurrentUser().name };
            }
            async function handleRun(args, cmdOptions) {
                const scriptPathArg = args[0];
                if (!scriptPathArg) return { success: false, error: `run: missing script file operand\nUsage: ${commandHelpData.run.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.RUN, scriptPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const scriptContent = validation.node.content || "";
                const scriptLines = scriptContent.split('\n');
                await OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                (async () => {
                    for (let i = 0; i < scriptLines.length; i++) {
                        const line = scriptLines[i];
                        const trimmedLine = line.trim();
                        if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;
                        const cmdResult = await processSingleCommand(trimmedLine, false);
                        if (!cmdResult.success) {
                            await OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, { isError: true });
                            if (cmdResult.error) await OutputManager.appendToOutput(cmdResult.error, { isError: true });
                            return;
                        }
                    }
                    await OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                })();
                return { success: true, output: null };
            }
            async function handleGrep(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: `grep: usage: grep PATTERN FILE\nUsage: ${commandHelpData.grep.usage}` };
                const filePathArg = args[args.length - 1];
                let pattern = args.slice(0, args.length - 1).join(' ');
                if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                    pattern = pattern.substring(1, pattern.length - 1);
                }
                if (!pattern) return { success: false, error: "grep: pattern cannot be empty" };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.GREP, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const matchingLines = lines.filter(line => line.includes(pattern));
                return { success: true, output: matchingLines.length > 0 ? matchingLines.join('\n') : "" };
            }
            async function handleSort(args, cmdOptions) {
                const filePathArg = args[0];
                if (!filePathArg) return { success: false, error: `sort: missing file operand\nUsage: ${commandHelpData.sort.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.SORT, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                if (fileContent.trim() === "") return { success: true, output: "" };
                const lines = fileContent.split('\n');
                lines.sort();
                return { success: true, output: lines.join('\n') };
            }
            async function handleClear(args, cmdOptions) {
                OutputManager.clearOutput();
                return { success: true, output: null };
            }
            async function handleRegisterCmd(args, cmdOptions) {
                const username = args[0];
                if (!username) {
                     return { success: false, error: `Usage: ${commandHelpData.register.usage}` };
                }
                const result = await UserManager.register(username);
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error };
            }
            async function handleLoginCmd(args, cmdOptions) {
                const username = args[0];
                if (!username) {
                     return { success: false, error: `Usage: ${commandHelpData.login.usage}` };
                }
                const result = await UserManager.login(username);
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error };
            }
            async function handleLogoutCmd(args, cmdOptions) {
                const result = await UserManager.logout();
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Logout failed." };
            }
            async function handleSavestate(args, cmdOptions) {
                const result = await SessionManager.saveManualState();
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Failed to save state." };
            }
            async function handleLoadstate(args, cmdOptions) {
                const result = await SessionManager.loadManualState();
                return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG };
            }
            async function handleReset(args, cmdOptions) {
                ConfirmationManager.request(
                    ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."],
                    null,
                    async () => { await SessionManager.performFullReset(); },
                    () => { OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); }
                );
                return { success: true, output: null };
            }
            async function handleHelp(args, cmdOptions) {
                let outputLines = [];
                if (!args.length) {
                    outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                    const commandNames = Object.keys(commandRegistry).sort();
                    commandNames.forEach(cmdName => {
                        const summary = commandHelpData[cmdName]?.summary || 'No summary available.';
                        outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`);
                    });
                } else {
                    const commandName = args[0].toLowerCase();
                    const helpInfo = commandHelpData[commandName];
                    if (helpInfo) {
                        outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                        outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                        outputLines.push(`  For more details, type: man ${commandName}`);
                    } else return { success: false, error: `No help available for '${commandName}'. Try 'man ${commandName}'.` };
                }
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleMan(args, cmdOptions) {
                function escapeHtml(unsafe) {
                    if (typeof unsafe !== 'string') return '';
                    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                }
                if (args.length === 0) return { success: true, output: "What manual page do you want? (e.g., man ls)", messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                const commandName = args[0].toLowerCase();
                const manData = commandHelpData[commandName];
                if (manData) {
                    let manOutputHtmlLines = [];
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">NAME</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">SYNOPSIS</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">DESCRIPTION</span></div>`);
                    const detailLines = (manData.details || 'No detailed description available.').split('\n');
                    detailLines.forEach(line => {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`);
                    });
                    if (manData.examples && manData.examples.length > 0) {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">EXAMPLES</span></div>`);
                        manData.examples.forEach(example => {
                            manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">        <span class="${Config.CSS_CLASSES.MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`);
                        });
                    }
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    OutputManager.appendHtmlToOutput(manOutputHtmlLines.join(''));
                    return { success: true, output: null, isHtmlOutput: true };
                } else return { success: false, error: `No manual entry for ${commandName}` };
            }
            async function handleEditCmd(args, cmdOptions) {
                if (EditorManager.isActive()) {
                    return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MSG };
                }
                const targetPathArg = args[0];
                if (!targetPathArg) return { success: false, error: `edit: missing file operand\nUsage: ${commandHelpData.edit.usage}` };
                if (targetPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.EDIT, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const content = validation.node ? validation.node.content : "";
                EditorManager.enter(validation.resolvedPath, content);
                return { success: true, output: null };
            }
            async function handleTree(args, cmdOptions) {
                const targetPathArg = args[0];
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.TREE, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                if (validation.error) return { success: false, error: validation.error };
                const outputLines = [];
                const startingDirName = validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH ? Config.FILESYSTEM.ROOT_PATH : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || validation.resolvedPath;
                outputLines.push(startingDirName);
                function generateTreeLinesRecursive(directoryNode, prefix) {
                    const childrenNames = Object.keys(directoryNode.children).sort();
                    childrenNames.forEach((name, index) => {
                        const childNode = directoryNode.children[name];
                        const isLast = index === childrenNames.length - 1;
                        const connector = isLast ? "└── " : "├── ";
                        let line = prefix + connector + name;
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) line += Config.FILESYSTEM.PATH_SEPARATOR;
                        outputLines.push(line);
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            const newPrefix = prefix + (isLast ? "    " : "│   ");
                            generateTreeLinesRecursive(childNode, newPrefix);
                        }
                    });
                }
                generateTreeLinesRecursive(validation.node, "");
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleDu(args, cmdOptions) {
                const outputLines = [];
                let pathsToProcess = args.length > 0 ? args : [Config.FILESYSTEM.CURRENT_DIR_SYMBOL];
                let overallSuccess = true;
                for (const pathArg of pathsToProcess) {
                    const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.DU, pathArg, {
                        defaultToCurrentIfEmpty: (args.length === 0)
                    });
                    if (validation.error) {
                        await OutputManager.appendToOutput(validation.error, { isError: true });
                        overallSuccess = false;
                        continue;
                    }
                    const rawSize = FileSystemManager.calculateNodeSize(validation.node);
                    const formattedSize = Utils.formatBytes(rawSize);
                    let displayPath = pathArg;
                    if (validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && pathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        displayPath = './';
                    } else if (validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && !pathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR) && pathArg !== Config.FILESYSTEM.ROOT_PATH) {
                        displayPath += Config.FILESYSTEM.PATH_SEPARATOR;
                    }
                    outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`);
                }
                return { success: overallSuccess, output: outputLines.join('\n') };
            }
            async function handleHead(args, cmdOptions) {
                const defaultNumLines = 10;
                const commandName = Config.COMMAND_NAMES.HEAD;
                const options = Utils.parseNumericOption(args, "-n", defaultNumLines);
                let numLines = options.value;
                let errorMessages = [];
                if (options.error) {
                    errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`);
                }
                const filePathArg = options.remainingArgs[0];
                if (!filePathArg && options.remainingArgs.length === 0) {
                    return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandHelpData.head.usage}` };
                }
                if (options.remainingArgs.length > 1) {
                    return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` };
                }
                const validation = FileSystemManager.validatePath(commandName, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const outputLines = lines.slice(0, numLines);
                const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n');
                const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null;
                return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleTail(args, cmdOptions) {
                const defaultNumLines = 10;
                const commandName = Config.COMMAND_NAMES.TAIL;
                const options = Utils.parseNumericOption(args, "-n", defaultNumLines);
                let numLines = options.value;
                let errorMessages = [];
                if (options.error) {
                    errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`);
                }
                const filePathArg = options.remainingArgs[0];
                if (!filePathArg && options.remainingArgs.length === 0) {
                    return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandHelpData.tail.usage}` };
                }
                if (options.remainingArgs.length > 1) {
                    return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` };
                }
                const validation = FileSystemManager.validatePath(commandName, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const outputLines = lines.slice(Math.max(0, lines.length - numLines));
                const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n');
                const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null;
                return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleExport(args, cmdOptions) {
                const filePathArg = args[0];
                if (!filePathArg) return { success: false, error: `export: missing file operand\nUsage: ${commandHelpData.export.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.EXPORT, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || 'downloaded_file.txt';
                const fileContent = validation.node.content || "";
                const mimeType = "text/plain";
                try {
                    const blob = new Blob([fileContent], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return { success: true, output: `${Config.MESSAGES.EXPORTING_PREFIX}${fileName}${Config.MESSAGES.EXPORTING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Export failed:", error);
                    return { success: false, error: `Error exporting file '${fileName}': ${error.message}` };
                }
            }
            async function handleBackup(args, cmdOptions) {
                const currentUser = UserManager.getCurrentUser();
                const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
                const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`;
                const backupData = {
                    backupVersion: "1.0",
                    osVersion: Config.OS.VERSION,
                    user: currentUser.name,
                    timestamp: new Date().toISOString(),
                    filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    currentPath: FileSystemManager.getCurrentPath(),
                    commandHistory: HistoryManager.getFullHistory()
                };
                try {
                    const jsonString = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = backupFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return { success: true, output: `${Config.MESSAGES.BACKUP_CREATING_PREFIX}${backupFileName}${Config.MESSAGES.BACKUP_CREATING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Backup failed:", error);
                    return { success: false, error: `Error creating backup: ${error.message}` };
                }
            }
            async function handleImport(args, cmdOptions) {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                return new Promise((resolveCommand) => {
                    fileInput.onchange = async (event) => {
                        const file = event.target.files[0];
                        if (!file) {
                            await OutputManager.appendToOutput(Config.MESSAGES.IMPORT_CANCELLED_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            resolveCommand({ success: true, output: null });
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const fileContent = e.target.result;
                                const parsedData = JSON.parse(fileContent);
                                if (typeof parsedData !== 'object' || parsedData === null ||
                                    !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') ||
                                    !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') ||
                                    !parsedData.hasOwnProperty('backupVersion')) {
                                    await OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", { isError: true });
                                    resolveCommand({ success: false, error: "Invalid backup file." });
                                    return;
                                }
                                if (parsedData.backupVersion !== "1.0") {
                                    await OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                                }
                                const dataForConfirm = { parsedData: parsedData, fileName: file.name };
                                ConfirmationManager.request(
                                    [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`],
                                    dataForConfirm,
                                    async (data) => {
                                        const importedUser = data.parsedData.user;
                                        const currentActiveUser = UserManager.getCurrentUser();
                                        if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser && !isDiagActiveState) {
                                            SessionManager.saveAutomaticState(currentActiveUser.name);
                                        }
                                        UserManager.setCurrentUserObject({ name: importedUser }); // No credentials needed
                                        FileSystemManager.setFsData(Utils.deepCopyNode(data.parsedData.filesystem) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                                        FileSystemManager.setCurrentPath(data.parsedData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                                        HistoryManager.setHistory(data.parsedData.commandHistory || []);
                                        OutputManager.clearOutput();
                                        TerminalUI.clearInput();
                                        await FileSystemManager.save(importedUser);
                                        await AliasManager.load(importedUser);
                                        
                                        await OutputManager.appendToOutput(`${Config.MESSAGES.IMPORT_SUCCESS_PREFIX}${importedUser}${Config.MESSAGES.IMPORT_SUCCESS_MIDDLE}${data.fileName}${Config.MESSAGES.IMPORT_SUCCESS_SUFFIX}`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                        TerminalUI.updatePrompt();
                                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                                        resolveCommand({ success: true, output: null});
                                    },
                                    () => {
                                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                                        resolveCommand({ success: true, output: null});
                                    }
                                );
                            } catch (parseError) {
                                console.error("Import error - parsing JSON:", parseError);
                                await OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", { isError: true });
                                resolveCommand({ success: false, error: "Could not parse backup file."});
                            }
                        };
                        reader.onerror = async (e) => {
                            console.error("Import error - reading file:", e);
                            await OutputManager.appendToOutput("Error: Could not read the selected file.", { isError: true });
                            resolveCommand({ success: false, error: "Could not read file."});
                        };
                        reader.readAsText(file);
                    };
                    fileInput.click();
                });
            }
            async function handleDiff(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.DIFF;
                if (args.length !== 2) return { success: false, error: `${commandName}: missing operand. Requires two file arguments.\nUsage: ${commandHelpData.diff.usage}` };
                const file1PathArg = args[0], file2PathArg = args[1];
                const validation1 = FileSystemManager.validatePath(commandName, file1PathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false });
                if (validation1.error) return { success: false, error: validation1.error };
                const validation2 = FileSystemManager.validatePath(commandName, file2PathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false });
                if (validation2.error) return { success: false, error: validation2.error };
                const lines1 = (validation1.node.content || "").split('\n');
                const lines2 = (validation2.node.content || "").split('\n');
                const lcsArray = Utils.findLCS(lines1, lines2);
                let ptr1 = 0, ptr2 = 0, ptrLcs = 0;
                const diffOutput = [];
                let differencesFound = false;
                while (ptr1 < lines1.length || ptr2 < lines2.length) {
                    const line1Exists = ptr1 < lines1.length;
                    const line2Exists = ptr2 < lines2.length;
                    const lcsExists = ptrLcs < lcsArray.length;
                    if (lcsExists && line1Exists && lines1[ptr1] === lcsArray[ptrLcs] && line2Exists && lines2[ptr2] === lcsArray[ptrLcs]) {
                        ptr1++; ptr2++; ptrLcs++;
                    } else {
                        differencesFound = true;
                        if (line1Exists && (!lcsExists || lines1[ptr1] !== lcsArray[ptrLcs])) {
                            if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                                diffOutput.push(`< ${lines1[ptr1]}`);
                                diffOutput.push(`> ${lines2[ptr2]}`);
                                ptr1++; ptr2++;
                            } else {
                                diffOutput.push(`< ${lines1[ptr1]}`);
                                ptr1++;
                            }
                        } else if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                            diffOutput.push(`> ${lines2[ptr2]}`);
                            ptr2++;
                        } else {
                            if (ptr1 < lines1.length) { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; }
                            else if (ptr2 < lines2.length) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; }
                            else break;
                        }
                    }
                }
                return { success: true, output: differencesFound ? diffOutput.join('\n') : "" };
            }
            async function handleHistoryCmd(args, cmdOptions) {
                const history = HistoryManager.getFullHistory();
                if (history.length === 0) return { success: true, output: Config.MESSAGES.NO_COMMANDS_IN_HISTORY };
                return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') };
            }
            async function handleAliasCmd(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.ALIAS;
                const currentUser = UserManager.getCurrentUser().name;
                if (args.length === 0) {
                    const aliases = AliasManager.getAliases();
                    if (Object.keys(aliases).length === 0) return { success: true, output: Config.MESSAGES.NO_ALIASES_DEFINED };
                    const output = [];
                    for (const name in aliases) {
                        let value = aliases[name];
                        if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                            value = `'${value.replace(/'/g, "'\\''")}'`;
                        }
                        output.push(`${name}=${value}`);
                    }
                    return { success: true, output: output.join('\n') };
                }
                const firstArg = args.join(" ");
                const assignmentIndex = firstArg.indexOf('=');
                if (assignmentIndex === -1) {
                    const aliasName = args[0];
                    if (AliasManager.hasAlias(aliasName)) {
                        let value = AliasManager.getAliases()[aliasName];
                        if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                            value = `'${value.replace(/'/g, "'\\''")}'`;
                        }
                        return { success: true, output: `alias ${aliasName}=${value}` };
                    } else return { success: false, error: `${commandName}: ${aliasName}: not found` };
                } else {
                    const aliasName = firstArg.substring(0, assignmentIndex).trim();
                    let commandString = firstArg.substring(assignmentIndex + 1).trim();
                    if (!aliasName) return { success: false, error: `${commandName}: invalid alias name.` };
                    if (aliasName.includes(" ")) return { success: false, error: `${commandName}: alias name cannot contain spaces.` };
                    if (commandRegistry.hasOwnProperty(aliasName) && aliasName !== Config.COMMAND_NAMES.ALIAS && aliasName !== Config.COMMAND_NAMES.UNALIAS) {
                        return { success: false, error: `${commandName}: '${aliasName}' is a built-in command. Cannot create alias.` };
                    }
                    if (commandString === "") {
                        if (AliasManager.hasAlias(aliasName)) {
                            AliasManager.removeAlias(aliasName);
                            await AliasManager.save(currentUser);
                            return { success: true, output: `${aliasName}${Config.MESSAGES.ALIAS_UNSET_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                        return { success: true, output: null };
                    }
                    if ((commandString.startsWith("'") && commandString.endsWith("'")) || (commandString.startsWith('"') && commandString.endsWith('"'))) {
                        commandString = commandString.substring(1, commandString.length - 1);
                    }
                    if (aliasName === commandString.split(' ')[0]) {
                        return { success: false, error: `${commandName}: cannot alias '${aliasName}' to itself directly.` };
                    }
                    AliasManager.setAlias(aliasName, commandString);
                    await AliasManager.save(currentUser);
                    return { success: true, output: `Alias '${aliasName}'${Config.MESSAGES.ALIAS_SET_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                }
            }
            async function handleUnaliasCmd(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.UNALIAS;
                const currentUser = UserManager.getCurrentUser().name;
                if (args.length !== 1) return { success: false, error: `${commandName}: usage: unalias <name>` };
                const aliasName = args[0];
                if (AliasManager.hasAlias(aliasName)) {
                    AliasManager.removeAlias(aliasName);
                    await AliasManager.save(currentUser);
                    return { success: true, output: `Alias '${aliasName}' removed.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } else return { success: false, error: `${commandName}: ${aliasName}: not found` };
            }
            async function handleFind(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.FIND;
                const parsedArgs = _parseFindArgs(args);
                if (parsedArgs.error) return { success: false, error: `${commandName}: ${parsedArgs.error}` };
                const { searchPathArg, pattern } = parsedArgs;
                const validation = FileSystemManager.validatePath(commandName, searchPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                let startingNode = validation.node;
                let startingPath = validation.resolvedPath;
                if (validation.error) {
                    if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        const fileName = startingPath.substring(startingPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        try {
                            if (_matchFindPattern(fileName, pattern)) {
                                return { success: true, output: startingPath };
                            } else {
                                return { success: true, output: "" };
                            }
                        } catch (e) {
                             return { success: false, error: `${commandName}: ${e.message}` };
                        }
                    }
                    return { success: false, error: validation.error };
                }
                const foundItems = [];
                try {
                    _findRecursive(startingNode, startingPath, pattern, foundItems);
                } catch (e) {
                    return { success: false, error: `${commandName}: ${e.message}` };
                }
                return { success: true, output: foundItems.length > 0 ? foundItems.join('\n') : "" };
            }
            function _parseFindArgs(args) {
                let searchPathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                let pattern = null;
                const nameOptionIndex = args.indexOf('-name');
                if (nameOptionIndex === -1) {
                    return { error: `usage: find [path] -name "<pattern>"` };
                }
                if (nameOptionIndex === 0) {
                    if (args.length < 2) return { error: "missing pattern after -name" };
                    pattern = args[1];
                } else {
                    searchPathArg = args.slice(0, nameOptionIndex).join(' ');
                    if (nameOptionIndex + 1 >= args.length) return { error: "missing pattern after -name" };
                    pattern = args[nameOptionIndex + 1];
                }
                if (pattern && pattern.length >= 2) {
                    const firstChar = pattern[0];
                    const lastChar = pattern[pattern.length - 1];
                    if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                        pattern = pattern.substring(1, pattern.length - 1);
                    }
                }
                if (!pattern) return { error: "pattern cannot be empty" };
                return { searchPathArg, pattern };
            }
            function _findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) {
                if (!currentSearchNode || currentSearchNode.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return;
                }
                const childrenNames = Object.keys(currentSearchNode.children).sort();
                for (const name of childrenNames) {
                    const childNode = currentSearchNode.children[name];
                    const childFullPath = FileSystemManager.getAbsolutePath(name, currentSearchPath);
                    if (_matchFindPattern(name, pattern)) {
                        foundItems.push(childFullPath + (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? Config.FILESYSTEM.PATH_SEPARATOR : ''));
                    }
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        _findRecursive(childNode, childFullPath, pattern, foundItems);
                    }
                }
            }
            function _matchFindPattern(name, pattern) {
                let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.');
                const regex = new RegExp(`^${regexPattern}$`);
                return regex.test(name);
            }
            async function handleWc(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.WC;
                let showLines = false, showWords = false, showBytes = false;
                let optionsSpecified = false;
                const tempArgs = [...args];
                const filesToProcess = [];
                while (tempArgs.length > 0 && tempArgs[0].startsWith('-')) {
                    const optionGroup = tempArgs.shift();
                    optionsSpecified = true;
                    if (optionGroup.length === 1) {
                        return { success: false, error: `${commandName}: invalid option -- '-'\nUsage: ${commandHelpData.wc.usage}` };
                    }
                    for (let i = 1; i < optionGroup.length; i++) {
                        const char = optionGroup[i];
                        switch (char) {
                            case 'l': showLines = true; break;
                            case 'w': showWords = true; break;
                            case 'c': showBytes = true; break;
                            default:
                                return { success: false, error: `${commandName}: invalid option -- '${char}'\nUsage: ${commandHelpData.wc.usage}` };
                        }
                    }
                }
                filesToProcess.push(...tempArgs);
                if (filesToProcess.length === 0) {
                    return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandHelpData.wc.usage}` };
                }
                const defaultAll = !optionsSpecified;
                if (defaultAll) {
                    showLines = showWords = showBytes = true;
                }
                let totalLines = 0, totalWords = 0, totalBytes = 0;
                const outputResults = [];
                let anyFileFailed = false;
                for (const filePathArg of filesToProcess) {
                    const validation = FileSystemManager.validatePath(commandName, filePathArg, {
                        expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                        defaultToCurrentIfEmpty: false
                    });
                    if (validation.error) {
                        await OutputManager.appendToOutput(validation.error, { isError: true });
                        anyFileFailed = true;
                        continue;
                    }
                    const fileContent = validation.node.content || "";
                    const counts = _calculateWcCounts(fileContent, showLines, defaultAll);
                    totalLines += counts.lines;
                    totalWords += counts.words;
                    totalBytes += counts.bytes;
                    outputResults.push(_formatWcLine(counts, filePathArg, showLines, showWords, showBytes, defaultAll));
                }
                if (filesToProcess.length > 1 && !anyFileFailed) {
                    const totalCounts = { lines: totalLines, words: totalWords, bytes: totalBytes };
                    outputResults.push(_formatWcLine(totalCounts, "total", showLines, showWords, showBytes, defaultAll));
                }
                return { success: !anyFileFailed, output: outputResults.join('\n') };
            }
            function _calculateWcCounts(content, countNewlinesOnlyForDisplay, isDefaultAll) {
                const bytes = content.length;
                const words = content.trim() === "" ? 0 : content.trim().split(/\s+/).filter(Boolean).length;
                let lines;
                const newlineCount = (content.match(/\n/g) || []).length;
                if (isDefaultAll) {
                    if (content === "") lines = 0;
                    else {
                        lines = newlineCount;
                        if (content.length > 0 && !content.endsWith('\n')) lines++;
                    }
                } else {
                     lines = newlineCount;
                }
                 return { lines, words, bytes };
            }
            function _formatWcLine(counts, label, showL, showW, showB, isDefAll) {
                let resultLine = "";
                const padWidth = 7;
                if (showL || isDefAll) resultLine += `${String(counts.lines).padStart(padWidth)} `;
                if (showW || isDefAll) resultLine += `${String(counts.words).padStart(padWidth)} `;
                if (showB || isDefAll) resultLine += `${String(counts.bytes).padStart(padWidth)} `;
                resultLine += label;
                return resultLine.trim();
            }
            
            async function handleDiag(args, cmdOptions) {
                isDiagActiveState = true;
                OutputManager.setDiagRunning(true);
                OutputManager.clearOutput();
                await OutputManager.appendToOutput("OopisOs Diagnostics Initializing...", { typeClass: Config.CSS_CLASSES.DIAG_SECTION_TITLE });
                const originalUser = UserManager.getCurrentUser(); 
                const diagUserName = Config.DIAGNOSTICS.TEST_USER_NAME;
                const diagUserPass = Config.DIAGNOSTICS.TEST_USER_PASS; // Still defined, but not used for login
                let totalTests = 0;
                let passes = 0;
                let failures = 0;

                const diagContext = {
                    log: async (message, type = 'info') => {
                        let cssClass = Config.CSS_CLASSES.DIAG_OUTPUT;
                        let prefix = "  ";
                        switch(type) {
                            case 'pass': cssClass = Config.CSS_CLASSES.DIAG_PASS; prefix = "  PASS: "; break;
                            case 'fail': cssClass = Config.CSS_CLASSES.DIAG_FAIL; prefix = "  FAIL: "; break;
                            case 'detail': cssClass = Config.CSS_CLASSES.DIAG_DETAIL; prefix = "    "; break;
                            case 'section': cssClass = Config.CSS_CLASSES.DIAG_SECTION_TITLE; prefix = ""; break;
                        }
                        await OutputManager.appendToOutput(`${prefix}${message}`, { isInstant: true, typeClass: cssClass });
                    },
                    assert: async function(condition, testName, failureDetails = "") {
                        totalTests++;
                        if (condition) {
                            passes++;
                            await this.log(`${testName}`, 'pass');
                            return true;
                        } else {
                            failures++;
                            await this.log(`${testName}${failureDetails ? ` - ${failureDetails}` : ''}`, 'fail');
                            if (failureDetails) await this.log(failureDetails, 'detail');
                            return false;
                        }
                    },
                    currentTestUser: diagUserName,
                    runCmd: async (commandString) => await processSingleCommand(commandString, false),
                    createTestFile: async function(filePath, content) {
                        const escapedContent = content.replace(/"/g, '\\"').replace(/\n/g, '\\n');
                        const result = await this.runCmd(`${Config.COMMAND_NAMES.ECHO} "${escapedContent}" > "${filePath}"`);
                        if (!result.success) {
                            await this.log(`Helper createTestFile failed for ${filePath}: ${result.error || 'Unknown error'}`, 'fail');
                        }
                        return result.success;
                    },
                    cleanupTestItem: async function(itemPath) {
                        await this.runCmd(`${Config.COMMAND_NAMES.RM} -f "${itemPath}"`);
                    },
                    getTestBasePath: () => Config.DIAGNOSTICS.TEST_BASE_DIR_PATH_PREFIX + Config.DIAGNOSTICS.TEST_BASE_DIR_NAME
                };

                await diagContext.log("Setting up diagnostic environment...", 'section');
                let loginResult = await UserManager.login(diagUserName); // Passwordless login
                if (!loginResult.success || (loginResult.error && loginResult.error.includes("Invalid username"))) {
                    await UserManager.register(diagUserName); // Passwordless register
                    loginResult = await UserManager.login(diagUserName);
                }

                if (!loginResult.success) {
                    await diagContext.log("CRITICAL: Failed to set up diagnostic user. Aborting diagnostics.", 'fail');
                    if (originalUser.name !== diagUserName && originalUser.name !== Config.USER.DEFAULT_NAME) {
                        const logoutToGuest = await UserManager.logout(); 
                        if(logoutToGuest.success) {
                             await OutputManager.appendToOutput(`Diagnostics aborted. Original user ${originalUser.name} logged out. Session reverted to Guest. Please log in again if needed.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        } else {
                             await OutputManager.appendToOutput(`Diagnostics aborted. Failed to revert to Guest session. Current user: ${UserManager.getCurrentUser().name}. Please try logging out or resetting.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        }
                    } else if (originalUser.name === Config.USER.DEFAULT_NAME && UserManager.getCurrentUser().name !== Config.USER.DEFAULT_NAME) {
                         await UserManager.logout(); 
                    }
                    TerminalUI.updatePrompt();
                    isDiagActiveState = false;
                    OutputManager.setDiagRunning(false);
                    return { success: false, error: "Diag setup failed." };
                }
                
                const testBaseDir = diagContext.getTestBasePath();
                await diagContext.runCmd(`${Config.COMMAND_NAMES.RM} -f "${testBaseDir}"`);
                await diagContext.runCmd(`${Config.COMMAND_NAMES.MKDIR} "${testBaseDir}"`);
                await diagContext.runCmd(`${Config.COMMAND_NAMES.CD} "${testBaseDir}"`);
                
                await diagContext.log("Running Test Suites...", 'section');
                const testSuites = [
                    testSuitePathResolution,
                    testSuiteNodeOperations,
                    testSuiteAlias,
                    testSuiteRedirection,
                    testSuiteFileContentCommands,
                    testSuiteBasicCommands,
                    testSuiteUserManagement,
                ];

                for (const runSuite of testSuites) {
                    if (typeof runSuite === 'function') {
                        try {
                            await diagContext.log(`Starting Test Suite: ${runSuite.name || 'Unnamed Suite'}`, 'info');
                            await runSuite(diagContext);
                        } catch (e) {
                            failures++;
                            await diagContext.log(`CRITICAL ERROR during test suite ${runSuite.name || 'Unnamed Suite'}: ${e.message}`, 'fail');
                            console.error(`Diag suite error (${runSuite.name || 'Unnamed Suite'}):`, e);
                        }
                    }
                }
                
                await diagContext.log("Cleaning up diagnostic environment...", 'section');
                await diagContext.runCmd(`${Config.COMMAND_NAMES.CD} "${Config.FILESYSTEM.ROOT_PATH}"`);
                await diagContext.runCmd(`${Config.COMMAND_NAMES.RM} -f "${testBaseDir}"`);
                
                const currentDiagUser = UserManager.getCurrentUser();
                if (currentDiagUser.name === diagUserName) {
                    await UserManager.logout(); 
                }

                if (originalUser.name !== Config.USER.DEFAULT_NAME && UserManager.getCurrentUser().name === Config.USER.DEFAULT_NAME) {
                     await OutputManager.appendToOutput(`Diagnostics complete. Original user was '${originalUser.name}'. Session is now Guest. Please log in again if needed.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                } else if (originalUser.name === UserManager.getCurrentUser().name) {
                     await OutputManager.appendToOutput(`Diagnostics complete. Session restored for user '${originalUser.name}'.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                } else {
                     await OutputManager.appendToOutput(`Diagnostics complete. Current user: ${UserManager.getCurrentUser().name}. Original user was: ${originalUser.name}.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                TerminalUI.updatePrompt();


                await OutputManager.appendToOutput("-------------------------------", {typeClass: Config.CSS_CLASSES.DIAG_SECTION_TITLE});
                await OutputManager.appendToOutput(`Diagnostics Summary: ${totalTests} tests run, ${passes} PASSED, ${failures} FAILED.`);
                await OutputManager.appendToOutput("-------------------------------", {typeClass: Config.CSS_CLASSES.DIAG_SECTION_TITLE});

                isDiagActiveState = false;
                OutputManager.setDiagRunning(false);
                TerminalUI.focusInput();
                return { success: failures === 0, output: null };
            }

            return {
                processSingleCommand,
                isDiagActive: () => isDiagActiveState,
                getLastCommandFailed: () => lastCommandFailed
            };
        })();

        function initializeTerminalEventListeners() {
            DOM.terminalDiv.addEventListener('click', e => {
                if (EditorManager.isActive()) { return; }
                if (!e.target.closest('button, a') || e.target.closest('.input-line-container')) {
                    TerminalUI.focusInput();
                }
            });
            const getCurrentInputTarget = () => {
                 return DOM.editableInputDiv;
            };
            document.addEventListener('keydown', async e => {
                if (EditorManager.isActive()) return;
                const activeInputTarget = getCurrentInputTarget();
                if (document.activeElement !== activeInputTarget) return;
                TerminalUI.setIsNavigatingHistory(false);
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const commandText = TerminalUI.getCurrentInputValue();
                    await CommandExecutor.processSingleCommand(commandText, true);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prevCommand = HistoryManager.getPrevious();
                    if (prevCommand !== null) {
                        TerminalUI.setIsNavigatingHistory(true);
                        TerminalUI.setCurrentInputValue(prevCommand, true);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const nextCommand = HistoryManager.getNext();
                    if (nextCommand !== null) {
                        TerminalUI.setIsNavigatingHistory(true);
                        TerminalUI.setCurrentInputValue(nextCommand, true);
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    if (DOM.editableInputDiv && document.activeElement === DOM.editableInputDiv) {
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        const range = selection.getRangeAt(0);
                        const tabNode = document.createTextNode(Config.EDITOR.TAB_REPLACEMENT);
                        range.deleteContents();
                        range.insertNode(tabNode);
                        range.setStartAfter(tabNode);
                        range.setEndAfter(tabNode);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            });
            if (DOM.editableInputDiv) {
                DOM.editableInputDiv.addEventListener('paste', e => {
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' '));
                });
            }
        }

        window.diagInitializedForOutput = false;
        window.onload = async () => {
            await OutputManager.appendToOutput("User accounts are now passwordless.", { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
            try {
                await IndexedDBManager.init();
                const guestUser = { name: UserManager.getDefaultUser() };
                UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.load(UserManager.getDefaultUser());
                await AliasManager.load(UserManager.getDefaultUser());
                SessionManager.loadAutomaticState(UserManager.getDefaultUser());
                initializeTerminalEventListeners();
                TerminalUI.focusInput();
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                await OutputManager.appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details and browser storage settings.", { isInstant: true, isError: true });
            }
        };
    </script>
</body>
</html>
