<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOs v.1.0.6</title> <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
        }

        .input-line { display: flex; align-items: center; width: 100%; }
        .prompt-user { margin-right: 2px; color: #7fdbff; }
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #visual-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        #input-before-cursor, #input-after-cursor {
            white-space: pre;
            display: inline-block;
        }
        .cursor {
            width: 10px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #hidden-input { position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .file-item { }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }

        /* Editor specific styles */
        #editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #editor-textarea {
            flex-grow: 1;
            width: 100%;
            background-color: #0c0c0c;
            color: #00dd00;
            border: 1px solid #222;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            resize: none;
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 4px;
            overflow-y: auto;
        }
        #editor-instructions {
            padding: 5px 0;
            font-size: 0.9em;
            text-align: center;
            color: #aaa;
            flex-shrink: 0;
        }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line">
                <span id="prompt-user" class="prompt-user"></span>
                <span class="prompt-separator">@</span>
                <span id="prompt-host" class="prompt-host">OopisOs</span>
                <span class="prompt-separator">:</span>
                <span id="prompt-path" class="prompt-path"></span>
                <span class="prompt-char">&gt;</span>
                <div id="visual-input-container">
                    <span id="input-before-cursor"></span>
                    <div class="cursor"></div>
                    <span id="input-after-cursor"></span>
                </div>
            </div>
            <input type="text" id="hidden-input" autofocus autocapitalize="none" autocorrect="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const terminalDiv = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const standardInputLineDiv = terminalDiv.querySelector('.input-line');
        const inputBeforeCursorSpan = document.getElementById('input-before-cursor');
        const inputAfterCursorSpan = document.getElementById('input-after-cursor');
        const hiddenInput = document.getElementById('hidden-input');
        const promptUserSpan = document.getElementById('prompt-user');
        const promptPathSpan = document.getElementById('prompt-path');
        const promptHostSpan = document.getElementById('prompt-host');

        // --- Constants ---
        const USER_CREDENTIALS_KEY = 'oopisOsUserCredentials';
        const FILE_SYSTEM_KEY_PREFIX = 'oopisOsFileSystem_';
        const USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsUserTerminalState_';
        const MANUAL_USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsManualUserTerminalState_';
        const DEFAULT_USER = "Guest";
        const OS_NAME = "OopisOs";
        const OS_VERSION = "1.0.6"; // Updated OS Version
        const MAX_HISTORY_SIZE = 50;

        // --- CSS Classes ---
        const CSS_ERROR_MSG = 'error-message';
        const CSS_SUCCESS_MSG = 'success-message';
        const CSS_CONSOLE_LOG_MSG = 'console-log-message';
        const CSS_WARNING_MSG = 'warning-message';
        const CSS_DIR_ITEM = 'directory-item';
        const CSS_FILE_ITEM = 'file-item';
        const CSS_HELP_CMD_NAME = 'help-command-name';
        const CSS_HELP_DESC = 'help-description';
        const CSS_OUTPUT_LINE = 'output-line';
        const CSS_MAN_SECTION_TITLE = 'man-section-title';
        const CSS_MAN_SECTION_CONTENT = 'man-section-content';
        const CSS_MAN_EXAMPLE = 'man-example';
        const CSS_SYSMON_LABEL = 'sysmon-label';

        // --- Application State ---
        let fsData = {};
        let currentPath = '/';
        let currentUser = DEFAULT_USER;
        let awaitingResetConfirmation = false;
        let awaitingLoadstateConfirmation = false;
        let awaitingRmConfirmation = false;
        let itemToRemovePath = null;
        let pendingManualStateToLoad = null;
        let commandHistory = [];
        let historyIndex = 0;
        let lastCommandFailed = false;
        let isPasswordInputActive = false;
        let passwordMaskStartIndex = -1;
        let isEditingFile = false;
        let editingFilePath = null;
        let editorWrapperDiv = null;
        let editorTextareaElement = null;
        let editorInstructionsDiv = null;

        // --- Helper to format console arguments ---
        function formatConsoleArgs(args) {
            return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
        }

        // --- Output Management ---
        function appendToOutput(text, isError = false, typeClass = null) {
            if (isEditingFile && typeClass !== 'editor-message') return;
            const newLine = document.createElement('div');
            newLine.classList.add(CSS_OUTPUT_LINE);
            if (typeClass) newLine.classList.add(typeClass);
            if (isError && !typeClass) newLine.classList.add(CSS_ERROR_MSG);
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
            outputDiv.scrollTop = outputDiv.scrollHeight;
            if(isError) lastCommandFailed = true;
        }
        function appendStyledOutput(label, value) {
            if (isEditingFile) return;
            const line = document.createElement('div');
            line.classList.add(CSS_OUTPUT_LINE);
            const labelSpan = document.createElement('span');
            labelSpan.classList.add(CSS_SYSMON_LABEL);
            labelSpan.textContent = label.padEnd(20, ' ');
            const valueSpan = document.createElement('span');
            valueSpan.textContent = value;
            line.appendChild(labelSpan);
            line.appendChild(valueSpan);
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        // --- Console Output Redirection ---
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        console.log = (...args) => { if (!isEditingFile) appendToOutput(`LOG: ${formatConsoleArgs(args)}`, false, CSS_CONSOLE_LOG_MSG); originalConsoleLog.apply(console, args); };
        console.warn = (...args) => { if (!isEditingFile) appendToOutput(`WARN: ${formatConsoleArgs(args)}`, false, CSS_WARNING_MSG); originalConsoleWarn.apply(console, args); };
        console.error = (...args) => { if (!isEditingFile) appendToOutput(`ERROR: ${formatConsoleArgs(args)}`, true, CSS_ERROR_MSG); originalConsoleError.apply(console, args); };

        // --- Unified LocalStorage Helpers ---
        function loadJSONFromStorage(key, itemName, defaultValue = null) {
            try {
                const storedValue = localStorage.getItem(key);
                if (storedValue) return JSON.parse(storedValue);
            } catch (e) {
                console.error(`Error loading ${itemName} for '${key}':`, e.message);
                appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, true, CSS_WARNING_MSG);
            }
            return defaultValue;
        }
        function saveJSONToStorage(key, data, itemName) {
            try { localStorage.setItem(key, JSON.stringify(data)); return true; }
            catch (e) {
                console.error(`Error saving ${itemName} for '${key}':`, e.message);
                appendToOutput(`Critical Error: Could not save ${itemName} for '${key}'.`, true, CSS_ERROR_MSG);
            }
            return false;
        }

        // --- Filesystem Management ---
        function getFileSystemKey(user) { return `${FILE_SYSTEM_KEY_PREFIX}${user}`; }
        function initializeFileSystem(user = currentUser) {
            fsData = { '/': { type: 'directory', children: {} } };
            saveFileSystemData(user);
        }
        function saveFileSystemData(user = currentUser) { return saveJSONToStorage(getFileSystemKey(user), fsData, `FS for ${user}`); }
        function loadFileSystemData(user) {
            const loadedFs = loadJSONFromStorage(getFileSystemKey(user), `FS for ${user}`);
            if (loadedFs?.['/']?.type === 'directory') fsData = loadedFs;
            else {
                appendToOutput(loadedFs ? `Invalid FS for ${user}. Reinitializing.` : `No FS for ${user}. Initializing.`, false, loadedFs ? CSS_WARNING_MSG : CSS_CONSOLE_LOG_MSG);
                initializeFileSystem(user);
            }
        }

        // --- Visual Input Update ---
        function updateVisualInput() {
            const inputValue = hiddenInput.value;
            const cursorPos = hiddenInput.selectionStart;
            let visualString = inputValue;
            if (isPasswordInputActive && passwordMaskStartIndex !== -1) {
                if (inputValue.length > passwordMaskStartIndex) {
                    const prefix = inputValue.substring(0, passwordMaskStartIndex);
                    const suffixToMask = inputValue.substring(passwordMaskStartIndex);
                    visualString = prefix + '*'.repeat(suffixToMask.length);
                }
            }
            inputBeforeCursorSpan.textContent = visualString.substring(0, cursorPos);
            inputAfterCursorSpan.textContent = visualString.substring(cursorPos);
        }

        // --- Automatic Session State (UI only) ---
        function getAutomaticSessionStateKey(user) { return `${USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }
        function saveAutomaticSessionState() {
             const autoState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value };
            saveJSONToStorage(getAutomaticSessionStateKey(currentUser), autoState, `Auto session for ${currentUser}`);
        }
        function loadAutomaticSessionState(user = currentUser) {
            const autoState = loadJSONFromStorage(getAutomaticSessionStateKey(user), `Auto session for ${user}`);
            if (autoState) {
                currentPath = autoState.currentPath || '/';
                outputDiv.innerHTML = autoState.outputHTML || '';
                hiddenInput.value = autoState.currentInput || '';
            } else {
                outputDiv.innerHTML = ''; hiddenInput.value = ''; currentPath = '/';
                appendToOutput(`Welcome, ${user}! Type 'help' for commands.`, false, CSS_CONSOLE_LOG_MSG);
                appendToOutput(`NOTE: Passwords are now hashed. Existing users may need to re-register.`, false, CSS_WARNING_MSG);
            }
            updateVisualInput();
            updatePrompt();
            outputDiv.scrollTop = outputDiv.scrollHeight;
            return !!autoState;
        }

        // --- Manual Save State (UI + Filesystem Snapshot) ---
        function getManualUserTerminalStateKey(user) { return `${MANUAL_USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }

        // --- Path and Node Utilities ---
        function getAbsolutePath(targetPath, basePath) {
            if (!targetPath) targetPath = '.';
            if (targetPath.startsWith('/')) basePath = '/';
            const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s);
            const targetSegments = targetPath.split('/').filter(s => s);
            let resolvedSegments = [...baseSegments];
            for (const segment of targetSegments) {
                if (segment === '.') continue;
                if (segment === '..') { if (resolvedSegments.length > 0) resolvedSegments.pop(); }
                else resolvedSegments.push(segment);
            }
            return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/');
        }
        function getNodeByPath(path) {
            if (path === '/') return fsData['/'];
            const segments = path.substring(1).split('/').filter(s => s);
            let currentNode = fsData['/'];
            for (const segment of segments) {
                if (currentNode?.type === 'directory' && currentNode.children?.[segment]) {
                    currentNode = currentNode.children[segment];
                } else return null;
            }
            return currentNode;
        }
        function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }

        // --- User Credentials Management ---
        function getUserCredentials() { return loadJSONFromStorage(USER_CREDENTIALS_KEY, "User creds", {}); }
        function saveUserCredentials(credentials) { return saveJSONToStorage(USER_CREDENTIALS_KEY, credentials, "User creds"); }

        // --- Password Hashing ---
        async function hashPassword(password) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            } catch (error) {
                console.error("Password hashing failed:", error);
                appendToOutput("Critical error: Password hashing service unavailable.", true, CSS_ERROR_MSG);
                throw error;
            }
        }

        // --- Helper to create parent directories ---
        function createParentDirectoriesIfNeeded(targetAbsPath) {
            if (targetAbsPath === '/') return null;
            const lastSlashIndex = targetAbsPath.lastIndexOf('/');
            if (lastSlashIndex === -1) return null;
            const parentPath = lastSlashIndex === 0 ? '/' : targetAbsPath.substring(0, lastSlashIndex);
            const newFileName = targetAbsPath.substring(lastSlashIndex + 1);
            if (!newFileName || newFileName === "." || newFileName === "..") {
                appendToOutput(`Error: Invalid file name '${newFileName}' in path '${targetAbsPath}'`, true, 'editor-message');
                return null;
            }
            if (parentPath === '/') return fsData['/'];
            const parentPathSegments = parentPath.substring(1).split('/').filter(s => s);
            let currentDirNode = fsData['/'];
            let currentBuiltParentPath = "";
            for (const segment of parentPathSegments) {
                currentBuiltParentPath += "/" + segment;
                if (!currentDirNode.children[segment]) {
                    currentDirNode.children[segment] = { type: 'directory', children: {} };
                } else if (currentDirNode.children[segment].type !== 'directory') {
                    appendToOutput(`Error: Cannot create path component '${currentBuiltParentPath}': It's a file.`, true, 'editor-message');
                    return null;
                }
                currentDirNode = currentDirNode.children[segment];
            }
            return currentDirNode;
        }

        // --- Command Help Data ---
        const commandHelpData = {
            'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
            'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
            'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p).', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
            'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file, including parent directories.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change).', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
            'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
            'echo': { usage: 'echo [text]', summary: 'Displays text.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo "Another line" >> notes.txt']},
            'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
            'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
            'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms).', syntax: 'rm ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command requires confirmation before deletion as it cannot be undone. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder']},
            'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
            'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
            'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
            'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
            'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
            'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
            'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
            'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
            'register': { usage: 'register <username> <password>', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME PASSWORD', details: 'Registers a new user with the given USERNAME and PASSWORD. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage and input is masked.', examples: ['register myuser mysecretpass']},
            'login': { usage: 'login <username> <password>', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME PASSWORD', details: 'Logs in as the specified USERNAME using the provided PASSWORD. The entered password will be hashed, compared against the stored hash, and input is masked. This loads the user\'s unique filesystem and session state.', examples: ['login myuser mysecretpass']},
            'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
            'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
            'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
            'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
            'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
            'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
            'edit': {
                usage: 'edit <path/to/filename>',
                summary: 'Edits a text file or creates a new one.',
                syntax: 'edit FILE_PATH',
                details: 'Opens the specified FILE_PATH in a simple text editor. ' +
                         'If the file does not exist, it will be created upon saving. ' +
                         'Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving.', // UPDATED
                examples: [
                    'edit my_notes.txt',
                    'edit /projects/config.ini'
                ]
            }
        };

        // --- Command Handlers ---
        function handleLs(args) {
            const targetPathArg = args[0] || '.';
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') {
                const childrenNames = Object.keys(node.children);
                if (childrenNames.length === 0) return "Directory is empty.";
                let outputLines = [];
                childrenNames.sort().forEach(name => {
                    const childNode = node.children[name];
                    let line = name;
                    if (childNode.type === 'directory') line += '/';
                    outputLines.push(line);
                });
                return outputLines.join('\n');
            } else if (node) {
                appendToOutput(`ls: '${targetPathArg}': Not a directory`, true);
                return null;
            } else {
                appendToOutput(`ls: cannot access '${targetPathArg}': No such file or directory`, true);
                return null;
            }
        }
        function handleCd(args) {
            if (!args.length) { appendToOutput("cd: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') { currentPath = resolvedPath; updatePrompt(); }
            else if (node) appendToOutput(`cd: '${targetPathArg}': Not a directory`, true);
            else appendToOutput(`cd: '${targetPathArg}': No such file or directory`, true);
            return null;
        }
        function handleMkdir(args) {
            if (args.length === 0) { appendToOutput("mkdir: missing operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg === '/' || fullPathArg === '.' || fullPathArg === '..') {
                appendToOutput(`mkdir: invalid directory name '${fullPathArg}'`, true); return null;
            }
            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') { appendToOutput(`mkdir: cannot create directory '/': Root already exists`, true); return null; }
            const lastSlash = targetAbsPath.lastIndexOf('/');
            const parentToMkdirPath = lastSlash === 0 ? '/' : targetAbsPath.substring(0, lastSlash);
            const dirToMakeName = targetAbsPath.substring(lastSlash + 1);
            let parentNode = fsData['/'];
            if (parentToMkdirPath !== '/') {
                 parentNode = createParentDirectoriesIfNeeded(targetAbsPath);
                 if (!parentNode) {
                    return null;
                 }
            }
            if (parentNode.children[dirToMakeName]?.type === 'file') {
                appendToOutput(`mkdir: cannot create directory '${fullPathArg}': A file with this name exists.`, true); return null;
            }
            if (!parentNode.children[dirToMakeName]) {
                 parentNode.children[dirToMakeName] = { type: 'directory', children: {} };
                 saveFileSystemData();
            }
            return null;
        }
        function handleTouch(args) {
            if (args.length === 0) { appendToOutput("touch: missing file operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg.endsWith('/')) { appendToOutput(`touch: invalid argument '${fullPathArg}'`, true); return null; }
            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') { appendToOutput(`touch: cannot create file at root '/'`, true); return null; }
            const parentNode = createParentDirectoriesIfNeeded(targetAbsPath);
            if (!parentNode) return null;
            const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);
            if (parentNode.children[newFileName]?.type === 'directory') {
                appendToOutput(`touch: cannot touch '${fullPathArg}': It is a directory.`, true); return null;
            }
            if (!parentNode.children[newFileName]) {
                parentNode.children[newFileName] = { type: 'file', content: "" };
                saveFileSystemData();
            }
            return null;
        }
        function handleCat(args) {
            if (args.length === 0) { appendToOutput("cat: missing file operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`cat: ${targetPathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`cat: ${targetPathArg}: Is a directory`, true); return null; }
            return node.content;
        }
        function handleEcho(args) { return args.join(' ');}
        function handleMv(args) {
            if (args.length < 2) { appendToOutput("mv: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);
            if (absSourcePath === '/') { appendToOutput("mv: cannot move root '/'", true); return null; }
            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`mv: '${sourcePathArg}': No such file or directory`, true); return null; }
            const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/';
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            const sourceParentNode = getNodeByPath(sourceParentPath);
            if (!sourceParentNode?.children?.[sourceName]) { appendToOutput(`mv: internal error: source '${sourceName}' not in parent`, true); return null; }
            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);
            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }
            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`mv: invalid destination name '${finalDestName}'`, true); return null; }
            if (absSourcePath === absDestPath) { appendToOutput(`mv: '${sourcePathArg}' and '${destPathArg}' are the same.`, false, CSS_CONSOLE_LOG_MSG); return null; }
            if (finalDestParentNode.children[finalDestName]) {
                if (!(destNodeAtFullPath?.type === 'directory' && sourceNode.type !== 'directory')) {
                    appendToOutput(`mv: destination '${finalDestName}' already exists.`, true); return null;
                }
            }
            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`mv: cannot move directory into itself`, true); return null;
            }
            finalDestParentNode.children[finalDestName] = sourceNode;
            delete sourceParentNode.children[sourceName];
            if (saveFileSystemData()) appendToOutput(`Moved '${sourcePathArg}' to '${destPathArg}'`, false, CSS_SUCCESS_MSG);
            return null;
        }
        function handleCp(args) {
            if (args.length < 2) { appendToOutput("cp: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);
            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`cp: '${sourcePathArg}': No such file or directory`, true); return null; }
            if (absSourcePath === '/') { appendToOutput("cp: cannot copy root '/' itself.", true); return null; }
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);
            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }
            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`cp: invalid destination name '${finalDestName}'`, true); return null; }
            if (finalDestParentNode.children[finalDestName]) {
                appendToOutput(`cp: destination '${finalDestName}' already exists.`, true); return null;
            }
            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`cp: cannot copy directory into itself`, true); return null;
            }
            const copiedNode = deepCopyNode(sourceNode);
            if (!copiedNode) { appendToOutput(`cp: internal error copying '${sourcePathArg}'.`, true); return null; }
            finalDestParentNode.children[finalDestName] = copiedNode;
            if (saveFileSystemData()) appendToOutput(`Copied '${sourcePathArg}' to '${destPathArg}'`, false, CSS_SUCCESS_MSG);
            return null;
        }
        function handleRm(args) {
            if (args.length === 0) { appendToOutput("rm: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            if (resolvedPath === '/') { appendToOutput("rm: cannot remove root directory '/'", true); return null; }
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`rm: cannot remove '${targetPathArg}': No such file or directory`, true); return null; }
            itemToRemovePath = resolvedPath;
            awaitingRmConfirmation = true;
            const itemType = node.type === 'directory' ? 'directory' : 'file';
            appendToOutput(`Are you sure you want to remove ${itemType} '${targetPathArg}'? This action cannot be undone.`, false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            return null;
        }
        function handlePwd(args) { return currentPath;}
        function handleDate(args) { return new Date().toString();}
        function handleWhoami(args) { return currentUser;}
        function handleGrep(args) {
            if (args.length < 2) { appendToOutput("grep: usage: grep PATTERN FILE", true); return null; }
            const filePathArg = args[args.length - 1];
            let patternParts = args.slice(0, args.length - 1);
            let pattern = patternParts.join(' ');
            if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                pattern = pattern.substring(1, pattern.length - 1);
            }
            if (!pattern) { appendToOutput("grep: pattern cannot be empty", true); return null; }
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`grep: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`grep: ${filePathArg}: Is a directory`, true); return null; }
            const fileContent = node.content || "";
            const lines = fileContent.split('\n');
            const matchingLines = [];
            for (const line of lines) { if (line.includes(pattern)) { matchingLines.push(line); } }
            return matchingLines.length > 0 ? matchingLines.join('\n') : "";
        }
        function handleRun(args) {
            if (args.length === 0) { appendToOutput("run: missing script file operand", true); return null; }
            const scriptPathArg = args[0];
            const resolvedPath = getAbsolutePath(scriptPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`run: cannot access script '${scriptPathArg}': No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`run: cannot execute '${scriptPathArg}': It is a directory`, true); return null; }
            const scriptContent = node.content || "";
            const scriptLines = scriptContent.split('\n');
            appendToOutput(`Executing script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            (async () => {
                for (let i = 0; i < scriptLines.length; i++) {
                    const line = scriptLines[i];
                    const trimmedLine = line.trim();
                    if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;
                    const commandSuccessful = await processCommand(trimmedLine, false);
                    if (!commandSuccessful) {
                        appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, true);
                        return;
                    }
                }
                appendToOutput(`Finished script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            })();
            return null;
        }
        function handleSysmon(args) {
            const output = [
                "Ooputer 1 - System Monitor", "----------------------------------",
                `OS Name:          ${OS_NAME}`, `OS Version:       ${OS_VERSION}`,
                `Current User:     ${currentUser}`, "", "CPU:", `  Type:           OopisCPU Mark I`,
                `  Architecture:   CISC-ish`, `  Cores:          1 (Conceptual)`,
                `  Clock Speed:    ~1-5 OopoHertz (Variable Burst)`, "", "MEMORY (RAM):",
                `  Type:           DJHAR`, `  Capacity:       ~640 KB (Active Working Memory)`,
                "", "STORAGE (LS-SSD):", `  Type:           LocalStore Solid State Drive`,
                `  Capacity:       5 MB (Max Browser localStorage)`, "", "DISPLAY (OTDA):",
                `  Type:           GreenScreen Deluxe`, `  Mode:           Text-Mode`,
                "----------------------------------"
            ];
            return output.join('\n');
        }
        function handleSort(args) {
            if (args.length === 0) { appendToOutput("sort: missing file operand", true); return null; }
            const filePathArg = args[0];
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`sort: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`sort: ${filePathArg}: Is a directory`, true); return null; }
            const fileContent = node.content || "";
            if (fileContent.trim() === "") return "";
            const lines = fileContent.split('\n');
            lines.sort();
            return lines.join('\n');
        }
        function handleClear() { if (!isEditingFile) outputDiv.innerHTML = ''; return null; }
        function handleManualSaveState() {
            const manualState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value, fsDataSnapshot: deepCopyNode(fsData) };
            if (saveJSONToStorage(getManualUserTerminalStateKey(currentUser), manualState, `Manual save for ${currentUser}`)) {
                appendToOutput(`Session manually saved for ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        function handleManualLoadState() {
            pendingManualStateToLoad = loadJSONFromStorage(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser}`);
            if (pendingManualStateToLoad) {
                appendToOutput("Load manually saved state? This overwrites current session & filesystem.", false, CSS_WARNING_MSG);
                appendToOutput("Type 'YES' to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
                awaitingLoadstateConfirmation = true;
            } else appendToOutput(`No manually saved state found for ${currentUser}.`, false, CSS_CONSOLE_LOG_MSG);
            return null;
        }
        function performFullReset() {
            outputDiv.innerHTML = ''; hiddenInput.value = ''; updateVisualInput();
            localStorage.removeItem(getAutomaticSessionStateKey(currentUser));
            localStorage.removeItem(getFileSystemKey(currentUser));
            localStorage.removeItem(getManualUserTerminalStateKey(currentUser));
            if (currentUser !== DEFAULT_USER) {
                localStorage.removeItem(getAutomaticSessionStateKey(DEFAULT_USER));
                localStorage.removeItem(getFileSystemKey(DEFAULT_USER));
                localStorage.removeItem(getManualUserTerminalStateKey(DEFAULT_USER));
            }
            localStorage.removeItem(USER_CREDENTIALS_KEY);
            commandHistory = []; historyIndex = commandHistory.length; currentUser = DEFAULT_USER;
            initializeFileSystem(DEFAULT_USER); loadAutomaticSessionState(DEFAULT_USER);
            appendToOutput("Terminal fully reset. All user data and states cleared.", false, CSS_SUCCESS_MSG);
        }
        function handleReset() {
            appendToOutput("Reset ALL terminal data? This cannot be undone.", false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            awaitingResetConfirmation = true; return null;
        }
        async function handleRegister(args) {
            if (args.length < 2) { appendToOutput("Usage: register <username> <password>", true); return null; }
            const [username, password] = args;
            const credentials = getUserCredentials();
            if (credentials[username]) { appendToOutput(`Error: User '${username}' already exists.`, true); return null; }
            if (username.toLowerCase() === DEFAULT_USER.toLowerCase()) { appendToOutput(`Error: Cannot register '${DEFAULT_USER}'.`, true); return null; }
            try {
                const hashedPassword = await hashPassword(password);
                credentials[username] = hashedPassword;
                if (saveUserCredentials(credentials)) {
                    initializeFileSystem(username);
                    appendToOutput(`User '${username}' registered. You can now login.`, false, CSS_SUCCESS_MSG);
                }
            } catch (error) { appendToOutput(`Registration failed for '${username}' due to hashing error.`, true); }
            return null;
        }
        async function handleLogin(args) {
            if (args.length < 2) { appendToOutput("Usage: login <username> <password>", true); return null; }
            const [username, password] = args;
            const credentials = getUserCredentials();
            const storedPasswordHash = credentials[username];
            if (!storedPasswordHash) { appendToOutput("Login failed: Invalid username or password.", true); return null; }
            try {
                const enteredPasswordHash = await hashPassword(password);
                if (storedPasswordHash === enteredPasswordHash) {
                    if (currentUser !== DEFAULT_USER && currentUser !== username) saveAutomaticSessionState();
                    currentUser = username; commandHistory = []; historyIndex = commandHistory.length;
                    loadFileSystemData(currentUser); loadAutomaticSessionState(currentUser);
                    appendToOutput(`Logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
                } else { appendToOutput("Login failed: Invalid username or password.", true); }
            } catch (error) { appendToOutput("Login failed due to a system error during password verification.", true); }
            return null;
        }
        function handleLogout() {
            if (currentUser === DEFAULT_USER) { appendToOutput("Already Guest.", false, CSS_CONSOLE_LOG_MSG); return null; }
            saveAutomaticSessionState(); const prevUser = currentUser; currentUser = DEFAULT_USER;
            commandHistory = []; historyIndex = commandHistory.length;
            loadFileSystemData(DEFAULT_USER); loadAutomaticSessionState(DEFAULT_USER);
            appendToOutput(`User ${prevUser} logged out. Now ${currentUser}.`, false, CSS_SUCCESS_MSG);
            return null;
        }
        function handleHelp(args) {
            let outputLines = [];
            if (!args.length) {
                outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                const commandNames = Object.keys(commandRegistry).sort();
                commandNames.forEach(cmdName => { outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${commandHelpData[cmdName]?.summary || ''}`); });
            } else {
                const commandName = args[0].toLowerCase();
                const helpInfo = commandHelpData[commandName];
                if (helpInfo) {
                    outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                    outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                    outputLines.push(`  For more details, type: man ${commandName}`);
                } else { appendToOutput(`No help available for '${commandName}'. Try 'man ${commandName}'.`, true); return null; }
            }
            return outputLines.join('\n');
        }
        function handleMan(args) {
            if (args.length === 0) return "What manual page do you want? (e.g., man ls)";
            const commandName = args[0].toLowerCase();
            const manDataFromHelp = commandHelpData[commandName]; let outputLines = [];
            if (manDataFromHelp) {
                outputLines.push(`NAME`); outputLines.push(`    ${commandName} - ${manDataFromHelp.summary || 'No summary available.'}`);
                outputLines.push(`\nSYNOPSIS`); outputLines.push(`    ${manDataFromHelp.syntax || manDataFromHelp.usage || 'No syntax information available.'}`);
                outputLines.push(`\nDESCRIPTION`); outputLines.push(`    ${manDataFromHelp.details || 'No detailed description available.'}`);
                if (manDataFromHelp.examples && manDataFromHelp.examples.length > 0) {
                    outputLines.push(`\nEXAMPLES`);
                    manDataFromHelp.examples.forEach(example => { outputLines.push(`        ${example}`); });
                }
                outputLines.push(""); return outputLines.join('\n');
            } else { appendToOutput(`No manual entry for ${commandName}`, true); return null; }
        }

        function handleEdit(args) {
            if (isEditingFile) {
                appendToOutput("Editor already active. Ctrl+S to save, Ctrl+O to quit.", false, 'editor-message');
                return null;
            }
            if (args.length === 0) {
                appendToOutput("edit: missing file operand", true);
                return null;
            }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            if (resolvedPath.endsWith('/')) {
                 appendToOutput(`edit: '${targetPathArg}' is a directory path, not a file.`, true);
                 return null;
            }
            const node = getNodeByPath(resolvedPath);
            if (node && node.type === 'directory') {
                appendToOutput(`edit: '${targetPathArg}' is a directory. Cannot edit directories.`, true);
                return null;
            }
            const content = node?.content || "";
            enterEditMode(resolvedPath, content);
            return null;
        }

        function enterEditMode(filePath, content) {
            isEditingFile = true;
            editingFilePath = filePath;
            outputDiv.style.display = 'none';
            standardInputLineDiv.style.display = 'none';
            hiddenInput.blur();
            editorWrapperDiv = document.createElement('div');
            editorWrapperDiv.id = 'editor-wrapper';
            editorTextareaElement = document.createElement('textarea');
            editorTextareaElement.id = 'editor-textarea';
            editorTextareaElement.value = content;
            editorInstructionsDiv = document.createElement('div');
            editorInstructionsDiv.id = 'editor-instructions';
            editorInstructionsDiv.textContent = `Editing: ${filePath} | Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving`; // UPDATED
            editorWrapperDiv.appendChild(editorTextareaElement);
            editorWrapperDiv.appendChild(editorInstructionsDiv);
            terminalDiv.insertBefore(editorWrapperDiv, standardInputLineDiv);
            editorTextareaElement.focus();
            editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
            editorTextareaElement.addEventListener('keydown', handleEditorKeyDown);
        }

        function exitEditMode(saveChanges = false) {
            let success = true;
            if (saveChanges && editorTextareaElement && editingFilePath) {
                const newContent = editorTextareaElement.value;
                const parentNode = createParentDirectoriesIfNeeded(editingFilePath);
                if (parentNode) {
                    const fileName = editingFilePath.substring(editingFilePath.lastIndexOf('/') + 1);
                    parentNode.children[fileName] = { type: 'file', content: newContent };
                    if (saveFileSystemData()) {
                        appendToOutput(`File '${editingFilePath}' saved.`, false, CSS_SUCCESS_MSG);
                    } else {
                        appendToOutput(`Error saving file '${editingFilePath}'.`, true, CSS_ERROR_MSG);
                        success = false;
                    }
                } else {
                    appendToOutput(`Failed to save '${editingFilePath}'. Parent path issue.`, true, CSS_ERROR_MSG);
                    success = false;
                }
            } else if (editingFilePath) {
                appendToOutput(`Exited editor for '${editingFilePath}' without saving.`, false, CSS_CONSOLE_LOG_MSG);
            }
            if (editorWrapperDiv && editorWrapperDiv.parentNode === terminalDiv) {
                terminalDiv.removeChild(editorWrapperDiv);
            }
            if (editorTextareaElement) {
                editorTextareaElement.removeEventListener('keydown', handleEditorKeyDown);
            }
            editorWrapperDiv = null;
            editorTextareaElement = null;
            editorInstructionsDiv = null;
            isEditingFile = false;
            editingFilePath = null;
            outputDiv.style.display = '';
            standardInputLineDiv.style.display = '';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            hiddenInput.focus();
            updatePrompt();
            return success;
        }

        function handleEditorKeyDown(event) {
            if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                exitEditMode(true);
            } else if (event.ctrlKey && (event.key === 'o' || event.key === 'O')) { // UPDATED to 'o' or 'O'
                event.preventDefault();
                exitEditMode(false);
            }
            if (event.key === 'Tab') {
                event.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
            }
        }

        // --- Command Registry ---
        const commandRegistry = {
            'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch,
            'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd,
            'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep,
            'sort': handleSort,
            'sysmon': handleSysmon,
            'mv': handleMv, 'cp': handleCp,
            'clear': handleClear,
            'register': handleRegister, 'login': handleLogin, 'logout': handleLogout,
            'savestate': handleManualSaveState, 'loadstate': handleManualLoadState,
            'reset': handleReset, 'help': handleHelp, 'man': handleMan,
            'edit': handleEdit
        };

        // --- UI Update Functions ---
        function updatePrompt() {
            promptUserSpan.textContent = currentUser;
            promptHostSpan.textContent = OS_NAME;
            promptPathSpan.textContent = currentPath.trim() === '' ? '/' : currentPath;
        }

        // --- Command Processing ---
        async function processCommand(commandInputText, isInteractive = true) {
            if (isEditingFile) return true;
            lastCommandFailed = false;
            const trimmedCommand = commandInputText.trim();
            if (isInteractive) {
                let displayCommand = trimmedCommand;
                if (isPasswordInputActive && passwordMaskStartIndex !== -1 && trimmedCommand.length > passwordMaskStartIndex) {
                    const prefix = trimmedCommand.substring(0, passwordMaskStartIndex);
                    const suffixToMask = trimmedCommand.substring(passwordMaskStartIndex);
                    displayCommand = prefix + '*'.repeat(suffixToMask.length);
                }
                const promptText = `${currentUser}@${OS_NAME}:${promptPathSpan.textContent}> `;
                appendToOutput(`${promptText}${displayCommand}`);
            } else {
                appendToOutput(`> ${trimmedCommand}`);
            }
            if (isInteractive && trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                commandHistory.push(trimmedCommand);
                if (commandHistory.length > MAX_HISTORY_SIZE) commandHistory.shift();
            }
            if (isInteractive) {
                historyIndex = commandHistory.length;
            }
            let commandSuccessful = true;
            if (awaitingResetConfirmation) {
                if (trimmedCommand === 'YES') { performFullReset(); appendToOutput("Full reset complete.", false, CSS_SUCCESS_MSG); }
                else { appendToOutput("Reset cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingResetConfirmation = false;
            } else if (awaitingLoadstateConfirmation) {
                 if (trimmedCommand === 'YES' && pendingManualStateToLoad) {
                    fsData = deepCopyNode(pendingManualStateToLoad.fsDataSnapshot) || { '/': { type: 'directory', children: {} } };
                    currentPath = pendingManualStateToLoad.currentPath || '/';
                    outputDiv.innerHTML = pendingManualStateToLoad.outputHTML || '';
                    hiddenInput.value = pendingManualStateToLoad.currentInput || '';
                    saveFileSystemData();
                    appendToOutput("Session loaded from manual save.", false, CSS_SUCCESS_MSG);
                    updateVisualInput();
                    updatePrompt();
                    outputDiv.scrollTop = outputDiv.scrollHeight;
                } else { appendToOutput("Load state cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingLoadstateConfirmation = false; pendingManualStateToLoad = null;
            } else if (awaitingRmConfirmation) {
                if (trimmedCommand === 'YES' && itemToRemovePath) {
                    const parentPath = itemToRemovePath.substring(0, itemToRemovePath.lastIndexOf('/')) || '/';
                    const itemName = itemToRemovePath.substring(itemToRemovePath.lastIndexOf('/') + 1);
                    const parentNode = getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(saveFileSystemData()) appendToOutput(`'${itemToRemovePath}' removed.`, false, CSS_SUCCESS_MSG);
                    } else { appendToOutput(`Error removing '${itemToRemovePath}': Item not found or parent changed.`, true); }
                } else { appendToOutput(`Removal of '${itemToRemovePath || 'item'}' cancelled.`, false, CSS_CONSOLE_LOG_MSG); }
                awaitingRmConfirmation = false; itemToRemovePath = null;
            } else {
                let commandToExecute = trimmedCommand;
                let redirectionType = null;
                let redirectionFile = null;
                const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/);
                const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/);
                if (appendMatch) {
                    redirectionType = 'append'; redirectionFile = appendMatch[1];
                    commandToExecute = commandToExecute.substring(0, appendMatch.index).trim();
                } else if (overwriteMatch) {
                    redirectionType = 'overwrite'; redirectionFile = overwriteMatch[1];
                    commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim();
                }
                if (commandToExecute !== '') {
                    const parts = commandToExecute.split(' ').filter(p => p);
                    const baseCommand = parts[0].toLowerCase();
                    const args = parts.slice(1);
                    const handler = commandRegistry[baseCommand];
                    if (handler) {
                        try {
                            const commandOutput = await handler(args);
                            if (commandOutput === null && lastCommandFailed) {
                                commandSuccessful = false;
                            } else if (redirectionType && redirectionFile) {
                                const targetAbsPathForRedir = getAbsolutePath(redirectionFile, currentPath);
                                if (targetAbsPathForRedir === '/') {
                                    appendToOutput(`Error: cannot redirect to root '/'`, true);
                                    commandSuccessful = false;
                                } else {
                                    const parentNodeForRedir = createParentDirectoriesIfNeeded(targetAbsPathForRedir);
                                    if (!parentNodeForRedir) {
                                        commandSuccessful = false;
                                    } else {
                                        const newFileNameForRedir = targetAbsPathForRedir.substring(targetAbsPathForRedir.lastIndexOf('/') + 1);
                                        const targetNodeForRedir = parentNodeForRedir.children[newFileNameForRedir];
                                        if (targetNodeForRedir?.type === 'directory') {
                                            appendToOutput(`Error: cannot write to '${redirectionFile}': It is a directory.`, true);
                                            commandSuccessful = false;
                                        } else {
                                            if (commandOutput !== null && commandOutput !== undefined) {
                                                if (redirectionType === 'overwrite' || !targetNodeForRedir) {
                                                    parentNodeForRedir.children[newFileNameForRedir] = { type: 'file', content: String(commandOutput) };
                                                } else if (redirectionType === 'append') {
                                                    const existingContent = targetNodeForRedir?.content || "";
                                                    parentNodeForRedir.children[newFileNameForRedir].content = existingContent + (existingContent ? "\n" : "") + String(commandOutput);
                                                }
                                            } else if (commandOutput === null && redirectionType === 'overwrite') {
                                                 parentNodeForRedir.children[newFileNameForRedir] = { type: 'file', content: "" };
                                            }
                                            if(!saveFileSystemData()) commandSuccessful = false;
                                        }
                                    }
                                }
                            } else if (commandOutput !== null && commandOutput !== undefined) {
                                const lines = String(commandOutput).split('\n');
                                lines.forEach(line => {
                                    if (baseCommand === 'man') {
                                        if (/^[A-Z\s]+$/.test(line.trim()) && line.trim() === line.trim().toUpperCase() && line.trim() === line && line.trim().length > 0 && line.trim().length < 20) { appendToOutput(line.trim(), false, CSS_MAN_SECTION_TITLE); }
                                        else if (line.startsWith("        ")) { appendToOutput(line, false, CSS_MAN_EXAMPLE); }
                                        else if (line.startsWith("    ")) { appendToOutput(line, false, CSS_MAN_SECTION_CONTENT); }
                                        else { appendToOutput(line); }
                                    } else if (baseCommand === 'sysmon' && line.includes(':')) {
                                        const parts = line.split(/:(.+)/);
                                        if (parts.length > 1) { appendStyledOutput(parts[0] + ':', parts[1].trim()); } else { appendToOutput(line); }
                                    } else if (baseCommand === 'ls') {
                                        const div = document.createElement('div'); div.classList.add(CSS_OUTPUT_LINE);
                                        const isDir = line.endsWith('/'); div.textContent = line;
                                        if (isDir) div.classList.add(CSS_DIR_ITEM); else div.classList.add(CSS_FILE_ITEM);
                                        outputDiv.appendChild(div); outputDiv.scrollTop = outputDiv.scrollHeight;
                                    } else { appendToOutput(line); }
                                });
                            }
                            if (commandOutput === null && !lastCommandFailed) { commandSuccessful = true; }
                            else if (commandOutput === null && lastCommandFailed) { commandSuccessful = false; }
                            else if (commandOutput !== null && commandOutput !== undefined && !lastCommandFailed) { commandSuccessful = true; }
                        } catch (e) {
                            console.error(`Error in '${baseCommand}':`, e);
                            appendToOutput(`Unexpected error in '${baseCommand}'. Check console.`, true);
                            commandSuccessful = false;
                        }
                    } else {
                        appendToOutput(`Error: Command not found: "${parts[0]}"`, true);
                        commandSuccessful = false;
                    }
                } else if (trimmedCommand === '') {
                    commandSuccessful = true;
                }
            }
            if (isInteractive) {
                hiddenInput.value = '';
                isPasswordInputActive = false; passwordMaskStartIndex = -1;
                updateVisualInput();
            }
            if (!isEditingFile && !awaitingLoadstateConfirmation && !awaitingResetConfirmation && !awaitingRmConfirmation) {
                updatePrompt();
            }
            return commandSuccessful;
        }

        // --- Event Listeners ---
        terminalDiv.addEventListener('click', e => {
            if (isEditingFile) {
                if (editorTextareaElement && e.target !== editorTextareaElement) {
                    editorTextareaElement.focus();
                }
                return;
            }
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A' && !e.target.closest('#visual-input-container')) {
                 hiddenInput.focus();
            }
            if (e.target.closest('#visual-input-container') || e.target.classList.contains('input-line')) {
                hiddenInput.focus();
            }
        });

        hiddenInput.addEventListener('keydown', async e => {
            if (isEditingFile) {
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                await processCommand(hiddenInput.value, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--; hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                    historyIndex++; hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length; hiddenInput.value = "";
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
            } else if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'Backspace', 'Delete'].includes(e.key)) {
                setTimeout(() => hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })), 0);
            }
        });

        hiddenInput.addEventListener('input', () => {
            if (isEditingFile) return;
            const rawInput = hiddenInput.value;
            isPasswordInputActive = false; passwordMaskStartIndex = -1;
            const passwordCommandRegex = /^(login|register)(\s+)(\S+)(\s+)(.*)$/i;
            const match = rawInput.match(passwordCommandRegex);
            if (match) {
                passwordMaskStartIndex = match[1].length + match[2].length + match[3].length + match[4].length;
                isPasswordInputActive = true;
            } else {
                const prefixRegex = /^(login|register)(\s+)(\S+)(\s*)$/i;
                const prefixMatch = rawInput.match(prefixRegex);
                if (prefixMatch) {
                    if (prefixMatch[4] && prefixMatch[4].length > 0 && /\s$/.test(rawInput)) {
                        isPasswordInputActive = true;
                        passwordMaskStartIndex = rawInput.length;
                    }
                }
            }
            updateVisualInput();
            if (!['ArrowUp', 'ArrowDown'].includes(event?.key)) {
                 historyIndex = commandHistory.length;
            }
        });

        // --- Initialization ---
        window.onload = () => {
            console.warn("SECURITY NOTE: User credentials HASHED, password input MASKED. For true security, server-side auth is needed. Existing users must re-register.");
            currentUser = DEFAULT_USER;
            loadFileSystemData(currentUser);
            loadAutomaticSessionState(currentUser);
            setTimeout(() => { if (!isEditingFile) hiddenInput.focus(); }, 100);
            console.log(`${OS_NAME} v.${OS_VERSION} (Editor Shortcut Update) loaded. Welcome!`);
        };
    </script></body>
</html>
