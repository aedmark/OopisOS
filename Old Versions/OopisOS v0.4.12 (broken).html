<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 0.4.12, 'Silent Alps'</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
            line-height: 1.2em;
        }

        .input-line-container {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }
        .prompt-container {
            display: flex;
            align-items: center;
            line-height: 1.2em;
            flex-shrink: 0;
            white-space: nowrap;
            padding-top: 0.1em;
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container {
            flex-grow: 1;
            min-width: 0;
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            outline: none;
            caret-color: #00ff00;
            color: #00ff00;
            width: 100%;
        }
        
        #password-input-field {
            background-color: transparent;
            border: none;
            outline: none;
            color: #00ff00;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            height: 1.2em;
            padding: 0;
            margin: 0;
            width: 100%;
            flex-grow: 1;
        }

        #hidden-legacy-input {
             position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;
        }

        .error-message { color: #ff4136; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .console-log-message { color: #aaaaaa; }
        .editor-message { color: #7fdbff; }
        .diag-output { color: #dddddd; }
        .diag-section-title { color: #00ffff; font-weight: bold; margin-top: 8px; margin-bottom: 3px; }


        .directory-item { color: #7fdbff; }
        .file-item { color: #00ff00; }

        .help-command-name { color: #7fdbff; font-weight: bold; }
        .help-description { margin-left: 10px; }
        .man-section-title { color: #7fdbff; font-weight: bold; }
        .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }

        .sysmon-label { color: #7fdbff; }

        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; }
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        #editor-textarea-wrapper { border-right: 1px solid #333; }
        #editor-textarea { width: 100%; height: 100%; background-color: #0c0c0c; color: #00dd00; border: none; font-family: 'VT323', monospace; font-size: 1em; line-height: 1.2em; resize: none; outline: none; padding: 0; }
        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre > code { display: block; padding: 10px; overflow-x: auto; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }
        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            <input type="text" id="hidden-legacy-input" style="position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px;">
        </div>
    </div>

    <script>
        const Config = (() => {
            'use strict';
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore"
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "0.4.12",
                    DEFAULT_HOST_NAME: "OopisOs"
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                    RESERVED_USERNAMES: ["guest"]
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    MAX_ALIAS_EXPANSION_DEPTH: 10,
                    DEFAULT_TYPING_SPEED: 35,
                    PROMPT_CHAR: ">",
                    PROMPT_SEPARATOR: ":",
                    PROMPT_AT: "@"
                },
                STORAGE_KEYS: {
                    USER_CREDENTIALS: 'oopisOsUserCredentials',
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                    ALIAS_FILE_PATH: "/.aliases"
                },
                CSS_CLASSES: {
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    EDITOR_MSG: 'editor-message',
                    DIAG_OUTPUT: 'diag-output',
                    DIAG_SECTION_TITLE: 'diag-section-title',
                    DIR_ITEM: 'directory-item',
                    FILE_ITEM: 'file-item',
                    HELP_CMD_NAME: 'help-command-name',
                    HELP_DESC: 'help-description',
                    OUTPUT_LINE: 'output-line',
                    MAN_SECTION_TITLE: 'man-section-title',
                    MAN_SECTION_CONTENT: 'man-section-content',
                    MAN_EXAMPLE: 'man-example',
                    SYSMON_LABEL: 'sysmon-label'
                },
                EDITOR: {
                    DEBOUNCE_DELAY_MS: 250,
                    TAB_REPLACEMENT: "\t",
                    CTRL_S_ACTION: 'save_exit',
                    CTRL_O_ACTION: 'exit_no_save',
                    CTRL_P_ACTION: 'toggle_preview',
                    DEFAULT_MODE: 'text',
                    MODES: {
                        TEXT: 'text',
                        MARKDOWN: 'markdown',
                        HTML: 'html'
                    },
                    EXTENSIONS_MAP: {
                        'md': 'markdown',
                        'html': 'html',
                        'htm': 'html'
                    },
                    VIEW_MODES: {
                        SPLIT: 'split',
                        EDIT_ONLY: 'edit',
                        PREVIEW_ONLY: 'preview'
                    }
                },
                FILESYSTEM: {
                    ROOT_PATH: '/',
                    CURRENT_DIR_SYMBOL: '.',
                    PARENT_DIR_SYMBOL: '..',
                    DEFAULT_DIRECTORY_TYPE: 'directory',
                    DEFAULT_FILE_TYPE: 'file',
                    PATH_SEPARATOR: '/'
                },
                MESSAGES: {
                    PASSWORD_PROMPT_SUFFIX: ": ",
                    PASSWORD_MASK_CHAR: "*",
                    CONFIRMATION_PROMPT: "Type 'YES' (all caps) to confirm, or any other input to cancel.",
                    OPERATION_CANCELLED: "Operation cancelled.",
                    ALREADY_LOGGED_IN_AS_PREFIX: "Already logged in as '",
                    ALREADY_LOGGED_IN_AS_SUFFIX: "'.",
                    NO_ACTION_TAKEN: "No action taken.",
                    ALREADY_IN_DIRECTORY_PREFIX: "Already in '",
                    ALREADY_IN_DIRECTORY_SUFFIX: "'.",
                    DIRECTORY_EMPTY: "Directory is empty.",
                    TIMESTAMP_UPDATED_PREFIX: "Timestamp of '",
                    TIMESTAMP_UPDATED_SUFFIX: "' updated.",
                    FILE_CREATED_SUFFIX: "' created.",
                    DIRECTORY_CREATED_SUFFIX: "' created.",
                    ITEM_REMOVED_SUFFIX: "' removed.",
                    FORCIBLY_REMOVED_PREFIX: "Forcibly removed '",
                    FORCIBLY_REMOVED_SUFFIX: "'.",
                    REMOVAL_CANCELLED_PREFIX: "Removal of '",
                    REMOVAL_CANCELLED_SUFFIX: "' cancelled.",
                    MOVED_PREFIX: "Moved '",
                    MOVED_TO: "' to '",
                    MOVED_SUFFIX: "'.",
                    COPIED_PREFIX: "Copied '",
                    COPIED_TO: "' to '",
                    COPIED_SUFFIX: "'.",
                    SESSION_SAVED_FOR_PREFIX: "Session manually saved for ",
                    SESSION_LOADED_MSG: "Session loaded from manual save.",
                    LOAD_STATE_CANCELLED: "Load state cancelled.",
                    NO_MANUAL_SAVE_FOUND_PREFIX: "No manually saved state found for ",
                    WELCOME_PREFIX: "Welcome, ",
                    WELCOME_SUFFIX: "! Type 'help' for commands.",
                    EXPORTING_PREFIX: "Exporting '",
                    EXPORTING_SUFFIX: "'... Check your browser downloads.",
                    BACKUP_CREATING_PREFIX: "Creating backup '",
                    BACKUP_CREATING_SUFFIX: "'... Check your browser downloads.",
                    IMPORT_CANCELLED_NO_FILE: "Import cancelled: No file selected.",
                    IMPORT_SUCCESS_PREFIX: "Session for user '",
                    IMPORT_SUCCESS_MIDDLE: "' successfully imported and restored from '",
                    IMPORT_SUCCESS_SUFFIX: "'.",
                    ALIAS_UNSET_SUFFIX: " alias unset.",
                    ALIAS_SET_SUFFIX: " set.",
                    NO_ALIASES_DEFINED: "No aliases defined.",
                    NO_COMMANDS_IN_HISTORY: "No commands in history."
                },
                INTERNAL_ERRORS: {
                    DB_NOT_INITIALIZED_FS_SAVE: "DB not initialized for FS save",
                    DB_NOT_INITIALIZED_FS_LOAD: "DB not initialized for FS load",
                    DB_NOT_INITIALIZED_FS_DELETE: "DB not initialized for FS delete",
                    DB_NOT_INITIALIZED_FS_CLEAR: "DB not initialized for clearing all FS",
                    CORRUPTED_FS_DATA_PRE_SAVE: "Corrupted FS data before saving.",
                    PASSWORD_HASHING_FAILED: "Password hashing service unavailable.",
                    REDIRECTION_FILE_NOT_SPECIFIED: "internal error: redirection file not specified.",
                    SOURCE_NOT_FOUND_IN_PARENT_PREFIX: "internal error: source '",
                    SOURCE_NOT_FOUND_IN_PARENT_MIDDLE: "' not found in parent '",
                    SOURCE_NOT_FOUND_IN_PARENT_SUFFIX: "'"
                },
                COMMAND_NAMES: {
                    RM: 'rm', LS: 'ls', CD: 'cd', MKDIR: 'mkdir', TOUCH: 'touch',
                    CAT: 'cat', ECHO: 'echo', MV: 'mv', CP: 'cp', PWD: 'pwd',
                    DATE: 'date', WHOAMI: 'whoami', RUN: 'run', GREP: 'grep',
                    SORT: 'sort', SYSMON: 'sysmon', CLEAR: 'clear', REGISTER: 'register',
                    LOGIN: 'login', LOGOUT: 'logout', SAVESTATE: 'savestate',
                    LOADSTATE: 'loadstate', RESET: 'reset', HELP: 'help', MAN: 'man',
                    EDIT: 'edit', DIAG: 'diag', TREE: 'tree', FIND: 'find', DU: 'du',
                    HEAD: 'head', TAIL: 'tail', EXPORT: 'export', BACKUP: 'backup',
                    IMPORT: 'import', WC: 'wc', DIFF: 'diff', HISTORY: 'history',
                    ALIAS: 'alias', UNALIAS: 'unalias'
                },
                DIAGNOSTICS: {
                    TEST_USER_NAME: "__diag_cmd_user__",
                    TEST_USER_PASS: "diagTestPass123",
                    TEST_BASE_DIR_NAME: "__diag_cmd_tests__",
                    TEST_BASE_DIR_PATH_PREFIX: "/tmp/",
                    DEFAULT_TEST_FILENAME: "testfile.txt",
                    DEFAULT_TEST_FILE_CONTENT: "content",
                    REDIRECT_TEST_FILENAME: "redir.txt",
                    REDIRECT_TEST_CONTENT_OVERWRITE: "redirect test",
                    REDIRECT_TEST_CONTENT_APPEND: "append test",
                    WC_TEST_FILENAME: "wc_test.txt",
                    WC_TEST_CONTENT: "one two three\nfour five\n\nsix seven eight nine ten",
                    HT_TEST_FILENAME: "ht_file.txt",
                    HT_TEST_CONTENT: "Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\nLine 11\nLine 12",
                    EMPTY_TEST_FILENAME: "empty_file.txt",
                    DIFF_FILE1_NAME: "diff1.txt",
                    DIFF_FILE1_CONTENT: "apple\nbanana\ncherry",
                    DIFF_FILE2_NAME: "diff2.txt",
                    DIFF_FILE2_CONTENT: "apple\nbanana\ncherry",
                    DIFF_FILE3_NAME: "diff3.txt",
                    DIFF_FILE3_CONTENT: "apple\ndate\nbanana\ncherry",
                    DIFF_FILE4_NAME: "diff4.txt",
                    DIFF_FILE4_CONTENT: "apple\ncherry",
                    DIFF_FILE5_NAME: "diff5.txt",
                    DIFF_FILE5_CONTENT: "apple\nblueberry\ncherry",
                }
            };
        })();

        const DOM = (() => {
            'use strict';
            return {
                terminalDiv: document.getElementById('terminal'),
                outputDiv: document.getElementById('output'),
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'),
                promptHostSpan: document.getElementById('prompt-host')
            };
        })();

        const Utils = (() => {
            'use strict';
            function formatConsoleArgs(args) {
                return Array.from(args)
                    .map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg))
                    .join(' ');
            }
            function deepCopyNode(node) {
                return node ? JSON.parse(JSON.stringify(node)) : null;
            }
            async function hashPassword(password) {
                try {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(password);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                } catch (error) {
                    console.error("Password hashing failed:", error);
                    throw new Error(Config.INTERNAL_ERRORS.PASSWORD_HASHING_FAILED);
                }
            }
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            function parseNumericOption(args, optionStr, defaultValue) {
                let numericValue = defaultValue;
                const remainingArgs = [...args];
                let error = null;
                const optionIndex = remainingArgs.indexOf(optionStr);
                if (optionIndex !== -1) {
                    if (optionIndex + 1 < remainingArgs.length) {
                        const potentialNumber = remainingArgs[optionIndex + 1];
                        const parsedNumber = parseInt(potentialNumber, 10);
                        if (!isNaN(parsedNumber) && parsedNumber >= 0) {
                            numericValue = parsedNumber;
                            remainingArgs.splice(optionIndex, 2);
                        } else {
                            error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`;
                            remainingArgs.splice(optionIndex, 2);
                        }
                    } else {
                        error = `option ${optionStr} requires an argument`;
                        remainingArgs.splice(optionIndex, 1);
                    }
                }
                return { value: numericValue, remainingArgs, error };
            }
            function findLCS(X, Y) {
                const m = X.length;
                const n = Y.length;
                const L = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
                for (let i = 0; i <= m; i++) {
                    for (let j = 0; j <= n; j++) {
                        if (i === 0 || j === 0) {
                            L[i][j] = 0;
                        } else if (X[i - 1] === Y[j - 1]) {
                            L[i][j] = L[i - 1][j - 1] + 1;
                        } else {
                            L[i][j] = Math.max(L[i - 1][j], L[i][j - 1]);
                        }
                    }
                }
                let index = L[m][n];
                const lcs = Array(index);
                let i = m, j = n;
                while (i > 0 && j > 0) {
                    if (X[i - 1] === Y[j - 1]) {
                        lcs[index - 1] = X[i - 1];
                        i--; j--; index--;
                    } else if (L[i - 1][j] > L[i][j - 1]) {
                        i--;
                    } else {
                        j--;
                    }
                }
                return lcs;
            }
            function getFileExtension(filePath) {
                if (!filePath || typeof filePath !== 'string') return '';
                const name = filePath.substring(filePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const lastDot = name.lastIndexOf('.');
                if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) {
                    return '';
                }
                return name.substring(lastDot + 1).toLowerCase();
            }
            return {
                formatConsoleArgs,
                deepCopyNode,
                hashPassword,
                formatBytes,
                parseNumericOption,
                findLCS,
                getFileExtension
            };
        })();

        const OutputManager = (() => {
            'use strict';
            let isEditorActive = false;
            let isDiagRunning = false;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;
            function setEditorActive(status) {
                isEditorActive = status;
            }
            function setDiagRunning(status) {
                isDiagRunning = status;
            }
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            async function _typeTextCinematically(element, text, speed) {
                for (const char of text) {
                    element.textContent += char;
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                    await sleep(speed);
                }
            }
            async function appendToOutput(text, options = {}) {
                if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MSG && !isDiagRunning) {
                    return;
                }
                const {
                    isInstant = false,
                    typingSpeed = Config.TERMINAL.DEFAULT_TYPING_SPEED,
                    isError = false,
                    typeClass = null
                } = options;
                const lines = String(text).split('\n');
                const forceInstant = isError ||
                                     typeClass === Config.CSS_CLASSES.WARNING_MSG ||
                                     typeClass === Config.CSS_CLASSES.CONSOLE_LOG_MSG ||
                                     typeClass === Config.CSS_CLASSES.DIAG_OUTPUT ||
                                     typeClass === Config.CSS_CLASSES.DIAG_SECTION_TITLE ||
                                     (CommandExecutor && CommandExecutor.isDiagActive() && typeClass !== null);
                for (const line of lines) {
                    const newLine = document.createElement('div');
                    newLine.classList.add(Config.CSS_CLASSES.OUTPUT_LINE);
                    if (typeClass) {
                        newLine.classList.add(typeClass);
                    } else if (isError) {
                        newLine.classList.add(Config.CSS_CLASSES.ERROR_MSG);
                    }
                    DOM.outputDiv.appendChild(newLine);
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                    if (isInstant || forceInstant) {
                        newLine.textContent = line;
                    } else {
                        await _typeTextCinematically(newLine, line, typingSpeed);
                    }
                }
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }
            function appendHtmlToOutput(htmlContent) {
                if (isEditorActive && !isDiagRunning) return;
                const blockDiv = document.createElement('div');
                blockDiv.innerHTML = htmlContent;
                DOM.outputDiv.appendChild(blockDiv);
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
            }
            function appendStyledOutput(label, value) {
                if (isEditorActive) return;
                OutputManager.appendToOutput(
                    `${label.padEnd(20, ' ')}${value}`,
                    { isInstant: true, typeClass: Config.CSS_CLASSES.SYSMON_LABEL }
                );
            }
            function clearOutput() {
                if (!isEditorActive) {
                    DOM.outputDiv.innerHTML = '';
                }
            }
            console.log = (...args) => {
                appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                originalConsoleLog.apply(console, args);
            };
            console.warn = (...args) => {
                appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                originalConsoleWarn.apply(console, args);
            };
            console.error = (...args) => {
                appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { isError: true });
                originalConsoleError.apply(console, args);
            };
            return {
                setEditorActive,
                setDiagRunning,
                appendToOutput,
                appendHtmlToOutput,
                appendStyledOutput,
                clearOutput
            };
        })();

        const StorageManager = (() => {
            'use strict';
            function loadJSON(key, itemName, defaultValue = null) {
                try {
                    const storedValue = localStorage.getItem(key);
                    if (storedValue) {
                        return JSON.parse(storedValue);
                    }
                } catch (e) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                         OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                    }
                }
                return defaultValue;
            }
            function saveJSON(key, data, itemName) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { isInstant: true, isError: true });
                    }
                }
                return false;
            }
            function removeItem(key) {
                localStorage.removeItem(key);
            }
            function getAllLocalStorageKeys() {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    keys.push(localStorage.key(i));
                }
                return keys;
            }
            return {
                loadJSON,
                saveJSON,
                removeItem,
                getAllLocalStorageKeys
            };
        })();

        const IndexedDBManager = (() => {
            'use strict';
            let dbInstance = null;
            function init() {
                return new Promise((resolve, reject) => {
                    if (dbInstance) {
                        resolve(dbInstance);
                        return;
                    }
                    const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION);
                    request.onupgradeneeded = (event) => {
                        const tempDb = event.target.result;
                        if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) {
                            tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        if ((!CommandExecutor || !CommandExecutor.isDiagActive()) && !window.diagInitializedForOutput) {
                             OutputManager.appendToOutput("FileSystem DB initialized.", { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                             window.diagInitializedForOutput = true;
                        }
                        resolve(dbInstance);
                    };
                    request.onerror = (event) => {
                        console.error("Database error: ", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private browsing mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.", { isInstant: true, isError: true });
                        reject(event.target.error);
                    };
                });
            }
            function getDbInstance() {
                if (!dbInstance) {
                    OutputManager.appendToOutput("Error: OopisOs file system storage is not available. Please ensure browser storage is enabled.", { isInstant: true, isError: true });
                    throw new Error("IndexedDB not initialized.");
                }
                return dbInstance;
            }
            return {
                init,
                getDbInstance
            };
        })();

        const FileSystemManager = (() => {
            'use strict';
            let fsData = {};
            let currentPath = Config.FILESYSTEM.ROOT_PATH;
            function _getFileSystemKey(user) {
                return `fs_${user}`;
            }
            async function initialize(user) {
                fsData = {
                    [Config.FILESYSTEM.ROOT_PATH]: {
                        type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                        children: {}
                    }
                };
            }
            async function save(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { isInstant: true, isError: true });
                    }
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_SAVE);
                }
                return new Promise((resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const dataToSave = Utils.deepCopyNode(fsData);
                        if (!dataToSave || typeof dataToSave !== 'object' ||
                            !dataToSave[Config.FILESYSTEM.ROOT_PATH] ||
                            dataToSave[Config.FILESYSTEM.ROOT_PATH].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            console.error("Attempted to save invalid fsData structure for user:", user, dataToSave);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { isInstant: true, isError: true });
                            }
                            return reject(new Error(Config.INTERNAL_ERRORS.CORRUPTED_FS_DATA_PRE_SAVE));
                        }
                        const request = store.put({ id: _getFileSystemKey(user), data: dataToSave });
                        request.onsuccess = () => resolve(true);
                        request.onerror = (event) => {
                            console.error(`Error saving FS for ${user}:`, event.target.error);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { isInstant: true, isError: true });
                            }
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating save transaction for ${user}:`, e);
                         if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                            OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { isInstant: true, isError: true });
                         }
                        reject(e);
                    }
                });
            }
            async function load(user) {
                const db = IndexedDBManager.getDbInstance();
                 if (!db) {
                    if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                        OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { isInstant: true, isError: true });
                    }
                    await initialize(user);
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_LOAD);
                }
                return new Promise(async (resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const request = store.get(_getFileSystemKey(user));
                        request.onsuccess = async (event) => {
                            const result = event.target.result;
                            if (result && result.data && result.data[Config.FILESYSTEM.ROOT_PATH]?.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                fsData = result.data;
                            } else {
                                const message = result ? `Warning: File system for '${user}' appears invalid. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`;
                                const messageType = result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG;
                                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                    OutputManager.appendToOutput(message, { isInstant: true, typeClass: messageType });
                                }
                                await initialize(user);
                                await save(user);
                            }
                            resolve();
                        };
                        request.onerror = async (event) => {
                            console.error(`Error loading FS for ${user}:`, event.target.error);
                            if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                                OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            }
                            await initialize(user);
                            await save(user);
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating load transaction for ${user}:`, e);
                        if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                             OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        }
                        await initialize(user);
                        await save(user);
                        reject(e);
                    }
                });
            }
            async function deleteUserFS(user) {
                const db = IndexedDBManager.getDbInstance();
                if (!db) return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_DELETE);
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.delete(_getFileSystemKey(user));
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error deleting FS for ${user}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            async function clearAllFS() {
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                     OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { isInstant: true, isError: true });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_CLEAR);
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.clear();
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error("Error clearing FileSystemsStore:", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { isInstant: true, isError: true });
                        reject(event.target.error);
                    };
                });
            }
            function getCurrentPath() {
                return currentPath;
            }
            function setCurrentPath(path) {
                currentPath = path;
            }
            function getFsData() {
                return fsData;
            }
            function setFsData(newData) {
                fsData = newData;
            }
            function getAbsolutePath(targetPath, basePath) {
                if (!targetPath) targetPath = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                let effectiveBasePath = basePath;
                if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    effectiveBasePath = Config.FILESYSTEM.ROOT_PATH;
                }
                const baseSegments = effectiveBasePath === Config.FILESYSTEM.ROOT_PATH ? [] : effectiveBasePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s && s !== Config.FILESYSTEM.CURRENT_DIR_SYMBOL);
                let resolvedSegments = [...baseSegments];
                const targetSegments = targetPath.split(Config.FILESYSTEM.PATH_SEPARATOR);
                for (const segment of targetSegments) {
                    if (segment === '' || segment === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR) && resolvedSegments.length === 0 && segment === '') {
                        }
                        continue;
                    }
                    if (segment === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                        if (resolvedSegments.length > 0) {
                            resolvedSegments.pop();
                        }
                    } else {
                        resolvedSegments.push(segment);
                    }
                }
                if (resolvedSegments.length === 0) {
                    return Config.FILESYSTEM.ROOT_PATH;
                }
                return Config.FILESYSTEM.PATH_SEPARATOR + resolvedSegments.join(Config.FILESYSTEM.PATH_SEPARATOR);
            }
            function getNodeByPath(path) {
                const absolutePath = getAbsolutePath(path, currentPath);
                if (absolutePath === Config.FILESYSTEM.ROOT_PATH) {
                    return fsData[Config.FILESYSTEM.ROOT_PATH];
                }
                const segments = absolutePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                for (const segment of segments) {
                    if (currentNode && currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && currentNode.children && currentNode.children[segment]) {
                        currentNode = currentNode.children[segment];
                    } else {
                        return null;
                    }
                }
                return currentNode;
            }
            function createParentDirectoriesIfNeeded(fullPath) {
                if (fullPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: null, error: "Cannot create parent for root." };
                }
                const lastSlashIndex = fullPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                const parentPath = (lastSlashIndex === 0) ? Config.FILESYSTEM.ROOT_PATH : fullPath.substring(0, lastSlashIndex);
                const newFileName = fullPath.substring(lastSlashIndex + 1);
                if (!newFileName || newFileName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || newFileName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` };
                }
                if (parentPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: fsData[Config.FILESYSTEM.ROOT_PATH], error: null };
                }
                const parentPathSegments = parentPath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentDirNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                let currentBuiltParentPath = "";
                for (const segment of parentPathSegments) {
                    currentBuiltParentPath += Config.FILESYSTEM.PATH_SEPARATOR + segment;
                    if (!currentDirNode.children[segment]) {
                        currentDirNode.children[segment] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                    } else if (currentDirNode.children[segment].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                    }
                    currentDirNode = currentDirNode.children[segment];
                }
                return { parentNode: currentDirNode, error: null };
            }
            function calculateNodeSize(node) {
                if (!node) return 0;
                if (node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return (node.content || "").length;
                }
                if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    let totalSize = 0;
                    for (const childName in node.children) {
                        totalSize += calculateNodeSize(node.children[childName]);
                    }
                    return totalSize;
                }
                return 0;
            }
            function validatePath(commandName, pathArg, options = {}) {
                const {
                    expectedType = 'any',
                    allowMissing = false,
                    disallowRoot = false,
                    defaultToCurrentIfEmpty = true
                } = options;
                let effectivePathArg = pathArg;
                if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) {
                    effectivePathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                }
                if (effectivePathArg === undefined || effectivePathArg === null) {
                    return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
                }
                const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath());
                const node = getNodeByPath(resolvedPath);
                if (disallowRoot && resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '${Config.FILESYSTEM.ROOT_PATH}'` };
                }
                if (node) {
                    if (expectedType === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                    }
                    if (expectedType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                    }
                    return { node: node, resolvedPath: resolvedPath, error: null };
                } else {
                    if (allowMissing) {
                        return { node: null, resolvedPath: resolvedPath, error: null };
                    } else {
                        return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory` };
                    }
                }
            }
            return {
                initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath,
                getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded,
                calculateNodeSize, validatePath
            };
        })();

        const AliasManager = (() => {
            'use strict';
            let userAliases = {};
            async function load(currentUser) {
                userAliases = {};
                const aliasFileNode = FileSystemManager.getNodeByPath(Config.STORAGE_KEYS.ALIAS_FILE_PATH);
                if (aliasFileNode && aliasFileNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    try {
                        const parsed = JSON.parse(aliasFileNode.content);
                        if (typeof parsed === 'object' && parsed !== null) {
                            userAliases = parsed;
                        }
                    } catch (e) {
                        userAliases = {};
                    }
                }
            }
            async function save(currentUser) {
                const aliasJsonString = JSON.stringify(userAliases, null, 2);
                const aliasFilePath = Config.STORAGE_KEYS.ALIAS_FILE_PATH;
                const rootNode = FileSystemManager.getFsData()[Config.FILESYSTEM.ROOT_PATH];
                if (rootNode && rootNode.children) {
                    const aliasFileName = aliasFilePath.substring(1);
                    rootNode.children[aliasFileName] = {
                        type: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                        content: aliasJsonString
                    };
                    await FileSystemManager.save(currentUser);
                } else {
                    OutputManager.appendToOutput("Error: Could not save aliases due to an internal file system inconsistency. Please report this issue.", { isInstant: true, isError: true });
                }
            }
            async function expand(commandInputText, depth = 0) {
                if (depth > Config.TERMINAL.MAX_ALIAS_EXPANSION_DEPTH) {
                    OutputManager.appendToOutput(`alias: Maximum expansion depth exceeded (possible loop).`, { isInstant: true, isError: true });
                    return commandInputText;
                }
                const parts = commandInputText.trim().split(' ');
                const potentialAlias = parts[0];
                if (userAliases.hasOwnProperty(potentialAlias)) {
                    const aliasValue = userAliases[potentialAlias];
                    const remainingArgs = parts.slice(1).join(' ');
                    const expandedCommand = (aliasValue + (remainingArgs ? ' ' + remainingArgs : '')).trim();
                    const nextPotentialAlias = expandedCommand.split(' ')[0];
                    if (userAliases.hasOwnProperty(nextPotentialAlias) && nextPotentialAlias !== potentialAlias) {
                        return await expand(expandedCommand, depth + 1);
                    }
                    return expandedCommand;
                }
                return commandInputText;
            }
            function getAliases() {
                return { ...userAliases };
            }
            function setAlias(name, value) {
                userAliases[name] = value;
            }
            function removeAlias(name) {
                delete userAliases[name];
            }
            function hasAlias(name) {
                return userAliases.hasOwnProperty(name);
            }
            return { load, save, expand, getAliases, setAlias, removeAlias, hasAlias };
        })();

        const HistoryManager = (() => {
            'use strict';
            let commandHistory = [];
            let historyIndex = 0;
            function add(command) {
                const trimmedCommand = command.trim();
                if (trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                    commandHistory.push(trimmedCommand);
                    if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) {
                        commandHistory.shift();
                    }
                }
                historyIndex = commandHistory.length;
            }
            function getPrevious() {
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    return commandHistory[historyIndex];
                }
                return null;
            }
            function getNext() {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    return commandHistory[historyIndex];
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    return "";
                }
                return null;
            }
            function resetIndex() {
                historyIndex = commandHistory.length;
            }
            function getFullHistory() {
                return [...commandHistory];
            }
            function clearHistory() {
                commandHistory = [];
                historyIndex = 0;
            }
            function setHistory(newHistory) {
                commandHistory = Array.isArray(newHistory) ? [...newHistory] : [];
                historyIndex = commandHistory.length;
            }
            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();

        const ConfirmationManager = (() => {
            'use strict';
            let awaitingConfirmation = false;
            let confirmationContext = null;
            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
                awaitingConfirmation = true;
                confirmationContext = {
                    promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                    data: dataForAction,
                    onConfirm: onConfirmCallback,
                    onCancel: onCancelCallback
                };
                confirmationContext.promptMessageLines.forEach(line =>
                    OutputManager.appendToOutput(line, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG })
                );
                OutputManager.appendToOutput(Config.MESSAGES.CONFIRMATION_PROMPT, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
            }
            async function handleConfirmation(input) {
                if (!awaitingConfirmation || !confirmationContext) return false;
                let processed = false;
                if (input.trim() === 'YES' && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                    processed = true;
                } else {
                    if (typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    }
                    processed = true;
                }
                awaitingConfirmation = false;
                confirmationContext = null;
                return processed;
            }
            function isAwaiting() {
                return awaitingConfirmation;
            }
            return { request, handleConfirmation, isAwaiting };
        })();

        const EditorManager = (() => {
            'use strict';
            let isActiveState = false;
            let currentFilePath = null;
            let currentFileMode = Config.EDITOR.DEFAULT_MODE;
            let currentViewMode = Config.EDITOR.VIEW_MODES.SPLIT;
            let debounceTimer = null;
            let editorContainerDiv = null;
            let editorControlsDiv = null;
            let editorFilenameDisplay = null;
            let viewToggleButton = null;
            let editorMainAreaDiv = null;
            let editorTextareaWrapper = null;
            let editorTextareaElement = null;
            let editorPreviewWrapper = null;
            let editorPreviewPaneDiv = null;
            let editorInstructionsFooter = null;
            function _determineMode(filePath) {
                const extension = Utils.getFileExtension(filePath);
                return Config.EDITOR.EXTENSIONS_MAP[extension] || Config.EDITOR.DEFAULT_MODE;
            }
            function _updatePreview() {
                if (!editorTextareaElement || !editorPreviewPaneDiv) return;
                const content = editorTextareaElement.value;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        if (typeof marked !== 'undefined') {
                            editorPreviewPaneDiv.innerHTML = marked.parse(content);
                        } else {
                            editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded.";
                        }
                    } else if (currentFileMode === Config.EDITOR.MODES.HTML) {
                        let iframe = editorPreviewPaneDiv.querySelector('iframe');
                        if (!iframe) {
                            iframe = document.createElement('iframe');
                            editorPreviewPaneDiv.innerHTML = '';
                            editorPreviewPaneDiv.appendChild(iframe);
                        }
                        iframe.srcdoc = content;
                    }
                }, Config.EDITOR.DEBOUNCE_DELAY_MS);
            }
            function _setupEditorLayout() {
                editorContainerDiv = document.createElement('div');
                editorContainerDiv.id = 'editor-container';
                editorControlsDiv = document.createElement('div');
                editorControlsDiv.id = 'editor-controls';
                editorFilenameDisplay = document.createElement('span');
                editorFilenameDisplay.id = 'editor-filename-display';
                editorFilenameDisplay.textContent = `File: ${currentFilePath}`;
                viewToggleButton = document.createElement('button');
                viewToggleButton.id = 'editor-view-toggle';
                viewToggleButton.addEventListener('click', _toggleViewMode);
                editorControlsDiv.appendChild(editorFilenameDisplay);
                editorControlsDiv.appendChild(viewToggleButton);
                editorContainerDiv.appendChild(editorControlsDiv);
                editorMainAreaDiv = document.createElement('div');
                editorMainAreaDiv.id = 'editor-main-area';
                editorTextareaWrapper = document.createElement('div');
                editorTextareaWrapper.id = 'editor-textarea-wrapper';
                editorTextareaWrapper.classList.add('editor-pane');
                editorTextareaElement = document.createElement('textarea');
                editorTextareaElement.id = 'editor-textarea';
                editorTextareaWrapper.appendChild(editorTextareaElement);
                editorMainAreaDiv.appendChild(editorTextareaWrapper);
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    editorPreviewWrapper = document.createElement('div');
                    editorPreviewWrapper.id = 'editor-preview-wrapper';
                    editorPreviewWrapper.classList.add('editor-pane');
                    editorPreviewPaneDiv = document.createElement('div');
                    editorPreviewPaneDiv.id = 'editor-preview-content';
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        editorPreviewPaneDiv.classList.add('markdown-preview');
                    }
                    editorPreviewWrapper.appendChild(editorPreviewPaneDiv);
                    editorMainAreaDiv.appendChild(editorPreviewWrapper);
                    _setViewModeUI(currentViewMode);
                } else {
                    viewToggleButton.style.display = 'none';
                    editorTextareaWrapper.style.borderRight = 'none';
                }
                editorContainerDiv.appendChild(editorMainAreaDiv);
                editorInstructionsFooter = document.createElement('div');
                editorInstructionsFooter.id = 'editor-instructions-footer';
                editorInstructionsFooter.textContent = `Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving | Ctrl+P: Toggle Preview (MD/HTML)`;
                editorContainerDiv.appendChild(editorInstructionsFooter);
                DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv);
            }
            function _setViewModeUI(mode) {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                currentViewMode = mode;
                const showTextarea = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                const showPreview = mode === Config.EDITOR.VIEW_MODES.SPLIT || mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY;
                editorTextareaWrapper.style.display = showTextarea ? "block" : "none";
                editorPreviewWrapper.style.display = showPreview ? "block" : "none";
                if (mode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    viewToggleButton.textContent = "Edit Only";
                    editorTextareaWrapper.style.flex = "1";
                    editorPreviewWrapper.style.flex = "1";
                    editorTextareaWrapper.style.borderRight = '1px solid #333';
                } else if (mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                    viewToggleButton.textContent = "Preview Only";
                    editorTextareaWrapper.style.flex = "2";
                    editorTextareaWrapper.style.borderRight = 'none';
                } else if (mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY) {
                    viewToggleButton.textContent = "Split View";
                    editorPreviewWrapper.style.flex = "2";
                }
            }
            function _toggleViewMode() {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                if (currentViewMode === Config.EDITOR.VIEW_MODES.SPLIT) {
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.EDIT_ONLY);
                } else if (currentViewMode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) {
                     _setViewModeUI(Config.EDITOR.VIEW_MODES.PREVIEW_ONLY);
                } else {
                    _setViewModeUI(Config.EDITOR.VIEW_MODES.SPLIT);
                }
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") {
                    editorTextareaElement.focus();
                }
            }
            function enter(filePath, content) {
                if (isActiveState) {
                    OutputManager.appendToOutput("Editor already active.", { isInstant: true, typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                    return;
                }
                isActiveState = true;
                OutputManager.setEditorActive(true);
                currentFilePath = filePath;
                currentFileMode = _determineMode(filePath);
                currentViewMode = (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML)
                                  ? Config.EDITOR.VIEW_MODES.SPLIT
                                  : Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                DOM.outputDiv.style.display = 'none';
                DOM.inputLineContainerDiv.style.display = 'none';
                _setupEditorLayout();
                editorTextareaElement.value = content;
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview();
                    editorTextareaElement.addEventListener('input', _updatePreview);
                }
                editorTextareaElement.focus();
                editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
                editorTextareaElement.addEventListener('keydown', handleKeyDown);
            }
            async function exit(saveChanges = false) {
                let success = true;
                if (saveChanges && editorTextareaElement && currentFilePath) {
                    const newContent = editorTextareaElement.value;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath);
                    if (parentDirResult.error) {
                        OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { isInstant: true, isError: true, typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                        success = false;
                    } else {
                        const parentNode = parentDirResult.parentNode;
                        if (parentNode) {
                            const fileName = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: newContent };
                            const currentUser = UserManager.getCurrentUser();
                            if (currentUser) {
                                if (await FileSystemManager.save(currentUser.name)) {
                                    OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                } else {
                                    OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { isInstant: true, isError: true });
                                    success = false;
                                }
                            } else {
                                OutputManager.appendToOutput(`Error saving file: No current user context.`, { isInstant: true, isError: true });
                                success = false;
                            }
                        } else {
                             OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { isInstant: true, isError: true });
                             success = false;
                        }
                    }
                } else if (currentFilePath) {
                    OutputManager.appendToOutput(`Exited editor for '${currentFilePath}' without saving.`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) {
                    DOM.terminalDiv.removeChild(editorContainerDiv);
                }
                if (editorTextareaElement) {
                    editorTextareaElement.removeEventListener('keydown', handleKeyDown);
                    editorTextareaElement.removeEventListener('input', _updatePreview);
                }
                editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = null;
                editorMainAreaDiv = editorTextareaWrapper = editorTextareaElement = null;
                editorPreviewWrapper = editorPreviewPaneDiv = editorInstructionsFooter = null;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = null;
                isActiveState = false;
                OutputManager.setEditorActive(false);
                currentFilePath = null;
                currentFileMode = Config.EDITOR.DEFAULT_MODE;
                DOM.outputDiv.style.display = '';
                DOM.inputLineContainerDiv.style.display = '';
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                TerminalUI.focusInput();
                TerminalUI.updatePrompt();
                return success;
            }
            async function handleKeyDown(event) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + Config.EDITOR.TAB_REPLACEMENT + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + Config.EDITOR.TAB_REPLACEMENT.length;
                    return;
                }
                if (event.ctrlKey) {
                    switch (event.key.toLowerCase()) {
                        case 's':
                            event.preventDefault();
                            await exit(true);
                            break;
                        case 'o':
                            event.preventDefault();
                            await exit(false);
                            break;
                        case 'p':
                            event.preventDefault();
                            if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                                _toggleViewMode();
                            }
                            break;
                    }
                }
            }
            return { isActive: () => isActiveState, enter, exit };
        })();

        const UserManager = (() => {
            'use strict';
            let currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} };
            function getCurrentUser() {
                return currentUser;
            }
            async function register(username, password) {
                const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User credentials", {});
                if (credentials[username]) {
                    return { success: false, error: `User '${username}' already exists.` };
                }
                if (Config.USER.RESERVED_USERNAMES.includes(username.toLowerCase())) {
                     return { success: false, error: `Cannot register '${username}'. This username is reserved.` };
                }
                if (username.includes(" ") || password.includes(" ")) {
                    return { success: false, error: "Username and password cannot contain spaces." };
                }
                try {
                    const hashedPassword = await Utils.hashPassword(password);
                    credentials[username] = hashedPassword;
                    if (StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, credentials, "User credentials")) {
                        await FileSystemManager.initialize(username);
                        await FileSystemManager.save(username);
                        await AliasManager.load(username);
                        return { success: true, message: `User '${username}' registered. You can now login.` };
                    } else {
                        return { success: false, error: "Failed to save new user credentials." };
                    }
                } catch (error) {
                    return { success: false, error: `Registration failed for '${username}': ${error.message}` };
                }
            }
            async function login(username, password) {
                if (currentUser.name === username && (!CommandExecutor || !CommandExecutor.isDiagActive())) {
                    return { success: true, message: `${Config.MESSAGES.ALREADY_LOGGED_IN_AS_PREFIX}${username}${Config.MESSAGES.ALREADY_LOGGED_IN_AS_SUFFIX}`, noAction: true };
                }
                const credentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User credentials", {});
                const storedPasswordHash = credentials[username];
                if (!storedPasswordHash) {
                    return { success: false, error: "Invalid username or password." };
                }
                try {
                    const enteredPasswordHash = await Utils.hashPassword(password);
                    if (storedPasswordHash === enteredPasswordHash) {
                        if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username && (!CommandExecutor || !CommandExecutor.isDiagActive())) {
                            SessionManager.saveAutomaticState(currentUser.name);
                        }
                        currentUser = { name: username, credentials };
                        HistoryManager.clearHistory();
                        await FileSystemManager.load(username);
                        await AliasManager.load(username);
                        if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                            SessionManager.loadAutomaticState(username);
                        }
                        TerminalUI.updatePrompt();
                        return { success: true, message: `Logged in as ${username}.` };
                    } else {
                        return { success: false, error: "Invalid username or password." };
                    }
                } catch (error) {
                    return { success: false, error: `Login failed: ${error.message}` };
                }
            }
            async function logout() {
                if (currentUser.name === Config.USER.DEFAULT_NAME) {
                    return { success: true, message: `Already logged in as Guest. ${Config.MESSAGES.NO_ACTION_TAKEN}`, noAction: true };
                }
                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                    SessionManager.saveAutomaticState(currentUser.name);
                }
                const prevUserName = currentUser.name;
                currentUser = { name: Config.USER.DEFAULT_NAME, credentials: {} };
                HistoryManager.clearHistory();
                await FileSystemManager.load(Config.USER.DEFAULT_NAME);
                await AliasManager.load(Config.USER.DEFAULT_NAME);
                if (!CommandExecutor || !CommandExecutor.isDiagActive()) {
                    SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME);
                }
                TerminalUI.updatePrompt();
                return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` };
            }
            function setCurrentUserObject(userObject) {
                currentUser = userObject;
            }
            function getDefaultUser() {
                return Config.USER.DEFAULT_NAME;
            }
            return {
                getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser
            };
        })();

        const SessionManager = (() => {
            'use strict';
            function _getAutomaticSessionStateKey(user) {
                return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`;
            }
            function _getManualUserTerminalStateKey(user) {
                return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${user.name || user}`;
            }
            function saveAutomaticState(username) {
                const currentInput = TerminalUI.isPasswordInputActiveState() ? '' : TerminalUI.getCurrentInputValue();
                const autoState = {
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML,
                    currentInput: currentInput,
                    commandHistory: HistoryManager.getFullHistory()
                };
                StorageManager.saveJSON(_getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`);
            }
            function loadAutomaticState(username) {
                const autoState = StorageManager.loadJSON(_getAutomaticSessionStateKey(username), `Auto session for ${username}`);
                const isDiag = CommandExecutor && CommandExecutor.isDiagActive();
                if (autoState) {
                    FileSystemManager.setCurrentPath(autoState.currentPath || Config.FILESYSTEM.ROOT_PATH);
                    if (!isDiag && autoState.hasOwnProperty('outputHTML')) {
                        DOM.outputDiv.innerHTML = autoState.outputHTML || '';
                    } else if (!isDiag && !autoState.hasOwnProperty('outputHTML')) {
                        if(!isDiag) DOM.outputDiv.innerHTML = '';
                    }
                    TerminalUI.setCurrentInputValue(autoState.currentInput || '');
                    HistoryManager.setHistory(autoState.commandHistory || []);
                } else {
                    if (!isDiag) DOM.outputDiv.innerHTML = '';
                    TerminalUI.setCurrentInputValue('');
                    FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH);
                    HistoryManager.clearHistory();
                    if (!isDiag) {
                        OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`, { isInstant: true });
                    }
                }
                TerminalUI.updatePrompt();
                if (!isDiag) {
                    DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                }
                return !!autoState;
            }
            async function saveManualState() {
                const currentUser = UserManager.getCurrentUser();
                const currentInput = TerminalUI.isPasswordInputActiveState() ? '' : TerminalUI.getCurrentInputValue();
                const manualStateData = {
                    currentPath: FileSystemManager.getCurrentPath(),
                    outputHTML: DOM.outputDiv.innerHTML,
                    currentInput: currentInput,
                    fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    commandHistory: HistoryManager.getFullHistory()
                };
                if (StorageManager.saveJSON(_getManualUserTerminalStateKey(currentUser), manualStateData, `Manual save for ${currentUser.name}`)) {
                    return { success: true, message: `${Config.MESSAGES.SESSION_SAVED_FOR_PREFIX}${currentUser.name}.` };
                } else {
                    return { success: false, error: "Failed to save session." };
                }
            }
            async function loadManualState() {
                const currentUser = UserManager.getCurrentUser();
                const manualStateData = StorageManager.loadJSON(_getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`);
                if (manualStateData) {
                    ConfirmationManager.request(
                        [`Load manually saved state for '${currentUser.name}'? This overwrites current session & filesystem.`],
                        { pendingData: manualStateData, userName: currentUser.name },
                        async (data) => {
                            FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                            FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                            DOM.outputDiv.innerHTML = data.pendingData.outputHTML || '';
                            TerminalUI.setCurrentInputValue(data.pendingData.currentInput || '');
                            HistoryManager.setHistory(data.pendingData.commandHistory || []);
                            await FileSystemManager.save(data.userName);
                            OutputManager.appendToOutput(Config.MESSAGES.SESSION_LOADED_MSG, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                            TerminalUI.updatePrompt();
                            DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        },
                        () => {
                            OutputManager.appendToOutput(Config.MESSAGES.LOAD_STATE_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, message: "Confirmation requested for loading state." };
                } else {
                    return { success: false, message: `${Config.MESSAGES.NO_MANUAL_SAVE_FOUND_PREFIX}${currentUser.name}.` };
                }
            }
            async function performFullReset() {
                OutputManager.clearOutput();
                TerminalUI.clearInput();
                const keysToRemove = [];
                const allKeys = StorageManager.getAllLocalStorageKeys();
                allKeys.forEach(key => {
                    if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) ||
                        key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) ||
                        key === Config.STORAGE_KEYS.USER_CREDENTIALS) {
                        keysToRemove.push(key);
                    }
                });
                keysToRemove.forEach(key => StorageManager.removeItem(key));
                await OutputManager.appendToOutput("All session states and credentials cleared from local storage.", { isInstant: true });
                try {
                    await FileSystemManager.clearAllFS();
                    await OutputManager.appendToOutput("All user filesystems cleared from DB.", { isInstant: true });
                } catch (error) {
                }
                HistoryManager.clearHistory();
                const guestUser = { name: Config.USER.DEFAULT_NAME, credentials: {} };
                UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.initialize(Config.USER.DEFAULT_NAME);
                await FileSystemManager.save(Config.USER.DEFAULT_NAME);
                await AliasManager.load(Config.USER.DEFAULT_NAME);
                loadAutomaticState(Config.USER.DEFAULT_NAME);
                await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                TerminalUI.updatePrompt();
            }
            return {
                saveAutomaticState, loadAutomaticState, saveManualState, loadManualState, performFullReset
            };
        })();

        const TerminalUI = (() => {
            'use strict';
            let isNavigatingHistory = false;
            let currentPasswordPromptContext = null;
            function updatePrompt() {
                const user = UserManager.getCurrentUser();
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.DEFAULT_HOST_NAME;
                DOM.promptPathSpan.textContent = FileSystemManager.getCurrentPath().trim() === '' ? Config.FILESYSTEM.ROOT_PATH : FileSystemManager.getCurrentPath();
            }
            function focusInput() {
                const passwordField = document.getElementById('password-input-field');
                if (passwordField && passwordField.style.display !== 'none') {
                    passwordField.focus();
                } else if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.focus();
                    if (DOM.editableInputDiv.textContent.length === 0) {
                        setCaretToEnd(DOM.editableInputDiv);
                    }
                }
            }
            function clearInput() {
                if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = '';
                const passField = document.getElementById('password-input-field');
                if (passField) passField.value = '';
            }
            function getCurrentInputValue() {
                const passField = document.getElementById('password-input-field');
                if (passField && passField.style.display !== 'none') return passField.value;
                return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : '';
            }
            function setCurrentInputValue(value, setAtEnd = true) {
                const passField = document.getElementById('password-input-field');
                if (passField && passField.style.display !== 'none') {
                } else if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.textContent = value;
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv);
                }
            }
            function setCaretToEnd(element) {
                if (!element) return;
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(element);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            }
            function switchToPasswordInput(promptContext) {
                currentPasswordPromptContext = promptContext;
                DOM.editableInputDiv.style.display = 'none';
                let passField = document.getElementById('password-input-field');
                if (!passField) {
                    passField = document.createElement('input');
                    passField.type = 'password';
                    passField.id = 'password-input-field';
                    DOM.editableInputContainerDiv.appendChild(passField);
                }
                passField.style.display = 'block';
                passField.value = '';
                passField.focus();
            }
            function switchToEditableInput() {
                const passField = document.getElementById('password-input-field');
                if (passField) {
                    passField.style.display = 'none';
                }
                DOM.editableInputDiv.style.display = 'block';
                currentPasswordPromptContext = null;
                focusInput();
            }
            function isPasswordInputActiveState() {
                return !!currentPasswordPromptContext;
            }
            function getPasswordContext() {
                return currentPasswordPromptContext;
            }
            function setIsNavigatingHistory(status) {
                isNavigatingHistory = status;
            }
            function getIsNavigatingHistory() {
                return isNavigatingHistory;
            }
            return {
                updatePrompt, focusInput, clearInput, setCurrentInputValue, getCurrentInputValue,
                isPasswordInputActiveState, getPasswordContext, switchToPasswordInput,
                switchToEditableInput, setCaretToEnd, setIsNavigatingHistory, getIsNavigatingHistory
            };
        })();

        const CommandExecutor = (() => {
            'use strict';
            let lastCommandFailed = false;
            let isDiagActiveState = false;
            const commandHelpData = {
                'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
                'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
                'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
                'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
                'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
                'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
                'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
                'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
                'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms unless forced).', syntax: 'rm [-f] ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command normally requires confirmation. The -f or --force option bypasses confirmation (used internally by scripts). The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder', 'rm -f unwanted_file.txt']},
                'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
                'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
                'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
                'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
                'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
                'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
                'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
                'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
                'register': { usage: 'register <username> [password]', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME [PASSWORD]', details: 'Registers a new user. If PASSWORD is not provided, you will be prompted for it. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage.', examples: ['register myuser', 'register newuser strongpass123']},
                'login': { usage: 'login <username> [password]', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME [PASSWORD]', details: 'Logs in as the specified USERNAME. If PASSWORD is not provided, you will be prompted for it. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser', 'login anotheruser mysecretpass']},
                'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
                'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
                'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
                'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
                'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
                'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
                'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving, Ctrl+P to toggle preview for MD/HTML.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
                'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
                'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
                'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
                'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
                'head': { usage: 'head [-n N] <filename>', summary: 'Displays the beginning of a file.', syntax: 'head [-n N] FILE', details: 'Prints the first N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt'] },
                'tail': { usage: 'tail [-n N] <filename>', summary: 'Displays the end of a file.', syntax: 'tail [-n N] FILE', details: 'Prints the last N lines (default 10) of the specified FILE to standard output. The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.', examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt'] },
                'export': { usage: 'export <path/to/filename>', summary: 'Exports a file to your local disk.', syntax: 'export FILE_PATH', details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.', examples: ['export my_document.txt', 'export /logs/today.log'] },
                'backup': { usage: 'backup', summary: 'Backs up current user session to a local file.', syntax: 'backup', details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.', examples: ['backup'] },
                'import': { usage: 'import', summary: 'Imports a user session from a local backup file.', syntax: 'import', details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).', examples: ['import'] },
                'wc': { usage: 'wc [-l] [-w] [-c] <filename>', summary: 'Counts lines, words, and bytes in a file.', syntax: 'wc [OPTION]... [FILE]', details: 'Prints newline, word, and byte counts for the specified FILE. A word is a non-zero-length sequence of characters delimited by white space. With no OPTION, prints all three counts.\n  -c, --bytes         print the byte counts\n  -l, --lines         print the newline counts\n  -w, --words         print the word counts', examples: ['wc myfile.txt', 'wc -l story.txt', 'wc -w -c report.doc', 'wc -lwc data.csv'] },
                'diff': { usage: 'diff <file1> <file2>', summary: 'Compares two files line by line.', syntax: 'diff FILE1 FILE2', details: 'Compares FILE1 and FILE2 line by line and outputs the differences. Common lines are prefixed with two spaces. Lines unique to FILE1 are prefixed with "< ". Lines unique to FILE2 are prefixed with "> ".', examples: ['diff old_version.txt new_version.txt', 'diff /config/main.conf /config/backup.conf'] },
                'history': { usage: 'history', summary: 'Displays the command history.', syntax: 'history', details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.', examples: ['history'] },
                'alias': { usage: 'alias [name[=value] ...]', summary: 'Define or display aliases.', syntax: 'alias [NAME[=VALUE]...]', details: '`alias` with no arguments prints the list of aliases in the form `name=\'value\'`.\n`alias name` prints the alias for `name`.\n`alias name=value` defines an alias. `value` can be a string containing commands. If `value` contains spaces, it should be quoted.\n`alias name=` unsets the alias `name`.', examples: ['alias', 'alias ll', "alias ll='ls -alF'", "alias mydocs='cd /home/user/documents'", "alias lsl="] },
                'unalias': { usage: 'unalias <name>', summary: 'Remove an alias.', syntax: 'unalias NAME', details: 'Removes the alias specified by NAME from the current user\'s alias list.', examples: ['unalias ll'] }
            };

            async function handleLs(args, cmdOptions) {
                const targetPathArg = args[0];
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.LS, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                if (validation.error) return { success: false, error: validation.error };
                const childrenNames = Object.keys(validation.node.children).sort();
                if (childrenNames.length === 0) return { success: true, output: Config.MESSAGES.DIRECTORY_EMPTY };
                let outputLines = [];
                childrenNames.forEach(name => {
                    const childNode = validation.node.children[name];
                    let line = name;
                    if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        line += Config.FILESYSTEM.PATH_SEPARATOR;
                    }
                    outputLines.push(line);
                });
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleCd(args, cmdOptions) {
                const targetPathArg = args[0];
                if (targetPathArg === undefined) return { success: false, error: `cd: missing operand\nUsage: ${commandHelpData.cd.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CD, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                if (validation.resolvedPath === FileSystemManager.getCurrentPath()) {
                    return { success: true, output: `${Config.MESSAGES.ALREADY_IN_DIRECTORY_PREFIX}${validation.resolvedPath}${Config.MESSAGES.ALREADY_IN_DIRECTORY_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                FileSystemManager.setCurrentPath(validation.resolvedPath);
                TerminalUI.updatePrompt();
                return { success: true, output: null };
            }
            async function handleMkdir(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return { success: false, error: `mkdir: missing operand\nUsage: ${commandHelpData.mkdir.usage}` };
                if (fullPathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || fullPathArg === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mkdir: invalid directory name '${fullPathArg}'` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MKDIR, fullPathArg, {
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error && validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.` };
                }
                if (validation.error && validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { success: false, error: validation.error };
                }
                if (validation.error && !validation.node && !validation.optionsUsed?.allowMissing) {
                     return { success: false, error: validation.error };
                }
                const targetAbsPath = validation.resolvedPath;
                if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    return { success: true, output: `mkdir: directory '${fullPathArg}' already exists.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `mkdir: ${parentDirResult.error}` };
                const parentNode = parentDirResult.parentNode;
                if (!parentNode) return { success: false, error: `mkdir: could not obtain parent directory for '${targetAbsPath}'` };
                const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                if (!dirToCreateName) return { success: false, error: `mkdir: invalid directory name in '${fullPathArg}'` };
                parentNode.children[dirToCreateName] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: `mkdir: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `Directory '${fullPathArg}${Config.MESSAGES.DIRECTORY_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleTouch(args, cmdOptions) {
                const fullPathArg = args[0];
                if (!fullPathArg) return { success: false, error: `touch: missing file operand\nUsage: ${commandHelpData.touch.usage}` };
                if (fullPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                     return { success: false, error: `touch: invalid argument '${fullPathArg}' (cannot be a directory path)` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.TOUCH, fullPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const targetAbsPath = validation.resolvedPath;
                if (validation.node) {
                    return { success: true, output: `${Config.MESSAGES.TIMESTAMP_UPDATED_PREFIX}${fullPathArg}${Config.MESSAGES.TIMESTAMP_UPDATED_SUFFIX}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) return { success: false, error: `touch: ${parentDirResult.error}` };
                const parentNode = parentDirResult.parentNode;
                 if (!parentNode) return { success: false, error: `touch: could not obtain parent for '${targetAbsPath}'`};
                const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: "" };
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                     return { success: false, error: `touch: failed to save filesystem after creating '${fullPathArg}'.` };
                }
                return { success: true, output: `File '${fullPathArg}${Config.MESSAGES.FILE_CREATED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCat(args, cmdOptions) {
                const targetPathArg = args[0];
                if (!targetPathArg) return { success: false, error: `cat: missing file operand\nUsage: ${commandHelpData.cat.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CAT, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                return { success: true, output: validation.node.content };
            }
            async function handleEcho(args, cmdOptions) {
                let outputString = args.join(' ');
                if (outputString.length >= 2) {
                    const firstChar = outputString[0];
                    const lastChar = outputString[outputString.length - 1];
                    if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                        outputString = outputString.substring(1, outputString.length - 1);
                    }
                }
                return { success: true, output: outputString };
            }
            async function handleMv(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: "mv: missing source and/or destination operands" };
                const sourcePathArg = args[0], destPathArg = args[1];
                const sourceValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MV, sourcePathArg, {
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;
                const destValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.MV, destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (destValidation.error && !(destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE )) {
                     return { success: false, error: destValidation.error };
                }
                let absDestPath = destValidation.resolvedPath;
                const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath);
                if (!sourceParentNode || !sourceParentNode.children || !sourceParentNode.children[sourceName]) {
                    return { success: false, error: `${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX}${sourceName}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE}${sourceParentPath}${Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX}` };
                }
                let finalDestParentNode, finalDestName;
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName;
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath);
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                    if(parentDirResult.error) return { success: false, error: `mv: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `mv: could not obtain parent for '${absDestPath}'`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }
                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `mv: invalid destination name '${finalDestName}'` };
                }
                if (absSourcePath === absDestPath) {
                    return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                }
                if (finalDestParentNode.children[finalDestName]) {
                    return { success: false, error: `mv: destination '${finalDestName}' already exists in '${destValidation.node ? destPathArg : absDestPath.substring(0, absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH }'.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `mv: cannot move directory '${sourcePathArg}' into itself or one of its subdirectories ('${destPathArg}')` };
                }
                finalDestParentNode.children[finalDestName] = sourceNode;
                delete sourceParentNode.children[sourceName];
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: "mv: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.MOVED_PREFIX}${sourcePathArg}${Config.MESSAGES.MOVED_TO}${destPathArg}${Config.MESSAGES.MOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleCp(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: "cp: missing source and/or destination operands" };
                const sourcePathArg = args[0], destPathArg = args[1];
                const sourceValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CP, sourcePathArg, {
                    disallowRoot: false,
                    defaultToCurrentIfEmpty: false
                });
                if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;
                const destValidation = FileSystemManager.validatePath(Config.COMMAND_NAMES.CP, destPathArg, {
                    allowMissing: true,
                    defaultToCurrentIfEmpty: false
                });
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    return { success: false, error: `cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.` };
                }
                if (destValidation.error && !(destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE)) {
                     return { success: false, error: destValidation.error };
                }
                let absDestPath = destValidation.resolvedPath;
                const sourceName = absSourcePath === Config.FILESYSTEM.ROOT_PATH ? 'root_copy' : absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                let finalDestParentNode, finalDestName;
                if (destValidation.node && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    finalDestParentNode = destValidation.node;
                    finalDestName = sourceName;
                    absDestPath = FileSystemManager.getAbsolutePath(finalDestName, absDestPath);
                } else {
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                     if(parentDirResult.error) return { success: false, error: `cp: ${parentDirResult.error}` };
                    finalDestParentNode = parentDirResult.parentNode;
                    if (!finalDestParentNode) return { success: false, error: `cp: could not obtain parent for '${absDestPath}'`};
                    finalDestName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                }
                if (!finalDestName || finalDestName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || finalDestName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { success: false, error: `cp: invalid destination name '${finalDestName}'` };
                }
                if (finalDestParentNode.children[finalDestName]) {
                    return { success: false, error: `cp: destination '${finalDestName}' already exists.` };
                }
                if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE &&
                    (absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR) || absDestPath === absSourcePath)) {
                    return { success: false, error: `cp: cannot copy a directory into itself or one of its subdirectories.` };
                }
                const copiedNode = Utils.deepCopyNode(sourceNode);
                if (!copiedNode) return { success: false, error: `cp: internal error copying '${sourcePathArg}'.` };
                finalDestParentNode.children[finalDestName] = copiedNode;
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: "cp: failed to save filesystem changes." };
                }
                return { success: true, output: `${Config.MESSAGES.COPIED_PREFIX}${sourcePathArg}${Config.MESSAGES.COPIED_TO}${destPathArg}${Config.MESSAGES.COPIED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
            }
            async function handleRm(args, cmdOptions = {}) {
                const { force: initialForce } = cmdOptions;
                let effectiveForce = initialForce;
                const remainingArgs = [...args];
                let pathArgForValidation;
                const forceFlagIndex = remainingArgs.findIndex(arg => arg === '-f' || arg === '--force');
                if (forceFlagIndex !== -1) {
                    effectiveForce = true;
                    remainingArgs.splice(forceFlagIndex, 1);
                }
                pathArgForValidation = remainingArgs[0];
                if (!pathArgForValidation) return { success: false, error: `rm: missing operand\nUsage: ${commandHelpData.rm.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.RM, pathArgForValidation, {
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) {
                    if (effectiveForce && validation.error.includes("No such file or directory")) {
                        return { success: true, output: null };
                    }
                    return { success: false, error: validation.error };
                }
                const itemType = validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? 'directory' : 'file';
                const dataForConfirm = {
                    path: validation.resolvedPath,
                    arg: pathArgForValidation,
                    userName: UserManager.getCurrentUser().name
                };
                if (effectiveForce) {
                    const parentPath = dataForConfirm.path.substring(0, dataForConfirm.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                    const itemName = dataForConfirm.path.substring(dataForConfirm.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const parentNode = FileSystemManager.getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await FileSystemManager.save(dataForConfirm.userName)) {
                            return { success: false, error: `Error saving filesystem after force removing '${dataForConfirm.path}'.` };
                        } else {
                            return { success: true, output: `${Config.MESSAGES.FORCIBLY_REMOVED_PREFIX}${pathArgForValidation}${Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                    } else {
                        return { success: false, error: `Error force removing '${dataForConfirm.path}': Item not found or parent changed.` };
                    }
                } else {
                    ConfirmationManager.request(
                        [`Are you sure you want to remove ${itemType} '${pathArgForValidation}'? This action cannot be undone.`],
                        dataForConfirm,
                        async (data) => {
                            const parentPath = data.path.substring(0, data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                            const itemName = data.path.substring(data.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            const parentNode = FileSystemManager.getNodeByPath(parentPath);
                            if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                delete parentNode.children[itemName];
                                if(!await FileSystemManager.save(data.userName)) {
                                    await OutputManager.appendToOutput(`Error saving filesystem after removing '${data.path}'.`, { isInstant: true, isError: true });
                                } else {
                                    await OutputManager.appendToOutput(`'${data.arg}${Config.MESSAGES.ITEM_REMOVED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                }
                            } else {
                                await OutputManager.appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, { isInstant: true, isError: true });
                            }
                        },
                        (data) => {
                            OutputManager.appendToOutput(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${data.arg || 'item'}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                        }
                    );
                    return { success: true, output: null };
                }
            }
            async function handlePwd(args, cmdOptions) {
                return { success: true, output: FileSystemManager.getCurrentPath() };
            }
            async function handleDate(args, cmdOptions) {
                return { success: true, output: new Date().toString() };
            }
            async function handleWhoami(args, cmdOptions) {
                return { success: true, output: UserManager.getCurrentUser().name };
            }
            async function handleRun(args, cmdOptions) {
                const scriptPathArg = args[0];
                if (!scriptPathArg) return { success: false, error: `run: missing script file operand\nUsage: ${commandHelpData.run.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.RUN, scriptPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const scriptContent = validation.node.content || "";
                const scriptLines = scriptContent.split('\n');
                await OutputManager.appendToOutput(`Executing script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                (async () => {
                    for (let i = 0; i < scriptLines.length; i++) {
                        const line = scriptLines[i];
                        const trimmedLine = line.trim();
                        if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;
                        const cmdResult = await processSingleCommand(trimmedLine, false);
                        if (!cmdResult.success) {
                            await OutputManager.appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, { isError: true });
                            if (cmdResult.error) await OutputManager.appendToOutput(cmdResult.error, { isError: true });
                            return;
                        }
                    }
                    await OutputManager.appendToOutput(`Finished script: ${scriptPathArg}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                })();
                return { success: true, output: null };
            }
            async function handleGrep(args, cmdOptions) {
                if (args.length < 2) return { success: false, error: `grep: usage: grep PATTERN FILE\nUsage: ${commandHelpData.grep.usage}` };
                const filePathArg = args[args.length - 1];
                let pattern = args.slice(0, args.length - 1).join(' ');
                if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                    pattern = pattern.substring(1, pattern.length - 1);
                }
                if (!pattern) return { success: false, error: "grep: pattern cannot be empty" };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.GREP, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const matchingLines = lines.filter(line => line.includes(pattern));
                return { success: true, output: matchingLines.length > 0 ? matchingLines.join('\n') : "" };
            }
            async function handleSort(args, cmdOptions) {
                const filePathArg = args[0];
                if (!filePathArg) return { success: false, error: `sort: missing file operand\nUsage: ${commandHelpData.sort.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.SORT, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                if (fileContent.trim() === "") return { success: true, output: "" };
                const lines = fileContent.split('\n');
                lines.sort();
                return { success: true, output: lines.join('\n') };
            }
            async function handleSysmon(args, cmdOptions) {
                const currentUser = UserManager.getCurrentUser();
                const output = [
                    "** OopisOs System Monitor v6.9 - Sub-Etha Edition **",
                    "----------------------------------------------------",
                    `Registered User:    ${currentUser.name} (Probably you, unless you stole this login!)`,
                    `OopisOs Version:    ${Config.OS.VERSION}`,
                    "", "==[ MAIN PROCESSOR UNIT (MPU) ]==",
                    `  Type:             QualmCore 9001 (Modular Edition)`,
                    `  Architecture:     Mostly Wishful Thinking with a Dash of RISC-y Business`,
                    `  Conceptual Cores: 1 (It's trying its best, okay?)`,
                    `  Clock Speed:      ~1 OopoHertz (Can reach 5 on a good day, with a tailwind)`,
                    "", "==[ RANDOM ACCESS MUD (RAM) ]==",
                    `  Type:             DJHAR (Don't Jiggle; Highly Agitated Ram)`,
                    `  Capacity:         640 KiloSegs (Should be enough for anyone, right?)`,
                    `  Current Load:     Probably too high. Did you try turning it off and on again?`,
                    "", "==[ STORAGE (Probably Borrowed) ]==",
                    `  Primary Drive:    The ol' IndexedDB Drive (Capacity: Browser's Whim)`,
                    `  Space Used:       Enough to make you question your life choices.`,
                    `  Space Free:       Less than you'd hope. Consider deleting 'that' folder.`,
                    "", "==[ VISUAL DISPLAY UNIT (VDU) ]==",
                    `  Model:            GreenScreen Deluxe (Now with 50 shades of green!)`,
                    `  Resolution:       Optimistically Text-Mode`,
                    `  Burn-in Status:   Impressive. You've been at this a while, huh?`,
                    "----------------------------------------------------",
                    "System Status:      'Nominally Operational'. (Whatever that means.)"
                ];
                let styledOutput = "";
                output.forEach(line => {
                    const parts = line.split(':');
                    if (parts.length > 1 && line.trim().startsWith(parts[0].trim())) {
                        styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.SYSMON_LABEL}">${parts[0].padEnd(20, ' ')}:</span><span>${parts.slice(1).join(':').trim()}</span></div>`;
                    } else {
                        styledOutput += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">${line}</div>`;
                    }
                });
                OutputManager.appendHtmlToOutput(styledOutput);
                return { success: true, output: null, isHtmlOutput: true };
            }
            async function handleClear(args, cmdOptions) {
                OutputManager.clearOutput();
                return { success: true, output: null };
            }
            async function handleRegisterCmd(args, cmdOptions) {
                if (args.length === 1 && args[0]) {
                    await OutputManager.appendToOutput(`Password for ${args[0]}${Config.MESSAGES.PASSWORD_PROMPT_SUFFIX}`, { isInstant: true });
                    TerminalUI.switchToPasswordInput({ commandName: Config.COMMAND_NAMES.REGISTER, username: args[0] });
                    return { success: true, output: null, awaitingPassword: true };
                } else if (args.length >= 2) {
                    const [username, password] = args;
                    const result = await UserManager.register(username, password);
                    TerminalUI.switchToEditableInput();
                    if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    else return { success: false, error: result.error };
                } else {
                    return { success: false, error: `Usage: ${commandHelpData.register.usage}` };
                }
            }
            async function handleLoginCmd(args, cmdOptions) {
                if (args.length === 1 && args[0]) {
                    await OutputManager.appendToOutput(`Password for ${args[0]}${Config.MESSAGES.PASSWORD_PROMPT_SUFFIX}`, { isInstant: true });
                    TerminalUI.switchToPasswordInput({ commandName: Config.COMMAND_NAMES.LOGIN, username: args[0] });
                    return { success: true, output: null, awaitingPassword: true };
                } else if (args.length >= 2) {
                    const [username, password] = args;
                    const result = await UserManager.login(username, password);
                     TerminalUI.switchToEditableInput();
                    if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                    else return { success: false, error: result.error };
                } else {
                    return { success: false, error: `Usage: ${commandHelpData.login.usage}` };
                }
            }
            async function handleLogoutCmd(args, cmdOptions) {
                const result = await UserManager.logout();
                if (result.success) return { success: true, output: result.message, messageType: result.noAction ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Logout failed." };
            }
            async function handleSavestate(args, cmdOptions) {
                const result = await SessionManager.saveManualState();
                if (result.success) return { success: true, output: result.message, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                else return { success: false, error: result.error || "Failed to save state." };
            }
            async function handleLoadstate(args, cmdOptions) {
                const result = await SessionManager.loadManualState();
                return { success: result.success, output: result.message, messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.WARNING_MSG };
            }
            async function handleReset(args, cmdOptions) {
                ConfirmationManager.request(
                    ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."],
                    null,
                    async () => { await SessionManager.performFullReset(); },
                    () => { OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); }
                );
                return { success: true, output: null };
            }
            async function handleHelp(args, cmdOptions) {
                let outputLines = [];
                if (!args.length) {
                    outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                    const commandNames = Object.keys(commandRegistry).sort();
                    commandNames.forEach(cmdName => {
                        const summary = commandHelpData[cmdName]?.summary || 'No summary available.';
                        outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`);
                    });
                } else {
                    const commandName = args[0].toLowerCase();
                    const helpInfo = commandHelpData[commandName];
                    if (helpInfo) {
                        outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                        outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                        outputLines.push(`  For more details, type: man ${commandName}`);
                    } else return { success: false, error: `No help available for '${commandName}'. Try 'man ${commandName}'.` };
                }
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleMan(args, cmdOptions) {
                function escapeHtml(unsafe) {
                    if (typeof unsafe !== 'string') return '';
                    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                }
                if (args.length === 0) return { success: true, output: "What manual page do you want? (e.g., man ls)", messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                const commandName = args[0].toLowerCase();
                const manData = commandHelpData[commandName];
                if (manData) {
                    let manOutputHtmlLines = [];
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">NAME</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">SYNOPSIS</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">DESCRIPTION</span></div>`);
                    const detailLines = (manData.details || 'No detailed description available.').split('\n');
                    detailLines.forEach(line => {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">    <span class="${Config.CSS_CLASSES.MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`);
                    });
                    if (manData.examples && manData.examples.length > 0) {
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                        manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}"><span class="${Config.CSS_CLASSES.MAN_SECTION_TITLE}">EXAMPLES</span></div>`);
                        manData.examples.forEach(example => {
                            manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">        <span class="${Config.CSS_CLASSES.MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`);
                        });
                    }
                    manOutputHtmlLines.push(`<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">&nbsp;</div>`);
                    OutputManager.appendHtmlToOutput(manOutputHtmlLines.join(''));
                    return { success: true, output: null, isHtmlOutput: true };
                } else return { success: false, error: `No manual entry for ${commandName}` };
            }
            async function handleEditCmd(args, cmdOptions) {
                if (EditorManager.isActive()) {
                    return { success: true, output: "Editor already active. Ctrl+S to save, Ctrl+O to quit.", messageType: Config.CSS_CLASSES.EDITOR_MSG };
                }
                const targetPathArg = args[0];
                if (!targetPathArg) return { success: false, error: `edit: missing file operand\nUsage: ${commandHelpData.edit.usage}` };
                if (targetPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    return { success: false, error: `edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.` };
                }
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.EDIT, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const content = validation.node ? validation.node.content : "";
                EditorManager.enter(validation.resolvedPath, content);
                return { success: true, output: null };
            }
            async function handleTree(args, cmdOptions) {
                const targetPathArg = args[0];
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.TREE, targetPathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE,
                    defaultToCurrentIfEmpty: true
                });
                if (validation.error) return { success: false, error: validation.error };
                const outputLines = [];
                const startingDirName = validation.resolvedPath === Config.FILESYSTEM.ROOT_PATH ? Config.FILESYSTEM.ROOT_PATH : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || validation.resolvedPath;
                outputLines.push(startingDirName);
                function generateTreeLinesRecursive(directoryNode, prefix) {
                    const childrenNames = Object.keys(directoryNode.children).sort();
                    childrenNames.forEach((name, index) => {
                        const childNode = directoryNode.children[name];
                        const isLast = index === childrenNames.length - 1;
                        const connector = isLast ? " " : " ";
                        let line = prefix + connector + name;
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) line += Config.FILESYSTEM.PATH_SEPARATOR;
                        outputLines.push(line);
                        if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            const newPrefix = prefix + (isLast ? "    " : "   ");
                            generateTreeLinesRecursive(childNode, newPrefix);
                        }
                    });
                }
                generateTreeLinesRecursive(validation.node, "");
                return { success: true, output: outputLines.join('\n') };
            }
            async function handleDu(args, cmdOptions) {
                const outputLines = [];
                let pathsToProcess = args.length > 0 ? args : [Config.FILESYSTEM.CURRENT_DIR_SYMBOL];
                let overallSuccess = true;
                for (const pathArg of pathsToProcess) {
                    const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.DU, pathArg, {
                        defaultToCurrentIfEmpty: (args.length === 0)
                    });
                    if (validation.error) {
                        await OutputManager.appendToOutput(validation.error, { isError: true });
                        overallSuccess = false;
                        continue;
                    }
                    const rawSize = FileSystemManager.calculateNodeSize(validation.node);
                    const formattedSize = Utils.formatBytes(rawSize);
                    let displayPath = pathArg;
                    if (validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && pathArg === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        displayPath = './';
                    } else if (validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && !pathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR) && pathArg !== Config.FILESYSTEM.ROOT_PATH) {
                        displayPath += Config.FILESYSTEM.PATH_SEPARATOR;
                    }
                    outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`);
                }
                return { success: overallSuccess, output: outputLines.join('\n') };
            }
            async function handleHead(args, cmdOptions) {
                const defaultNumLines = 10;
                const commandName = Config.COMMAND_NAMES.HEAD;
                const options = Utils.parseNumericOption(args, "-n", defaultNumLines);
                let numLines = options.value;
                let errorMessages = [];
                if (options.error) {
                    errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`);
                }
                const filePathArg = options.remainingArgs[0];
                if (!filePathArg && options.remainingArgs.length === 0) {
                    return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandHelpData.head.usage}` };
                }
                if (options.remainingArgs.length > 1) {
                    return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` };
                }
                const validation = FileSystemManager.validatePath(commandName, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const outputLines = lines.slice(0, numLines);
                const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n');
                const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null;
                return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleTail(args, cmdOptions) {
                const defaultNumLines = 10;
                const commandName = Config.COMMAND_NAMES.TAIL;
                const options = Utils.parseNumericOption(args, "-n", defaultNumLines);
                let numLines = options.value;
                let errorMessages = [];
                if (options.error) {
                    errorMessages.push(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`);
                }
                const filePathArg = options.remainingArgs[0];
                if (!filePathArg && options.remainingArgs.length === 0) {
                    return { success: false, error: `${commandName}: missing file operand\nUsage: ${commandHelpData.tail.usage}` };
                }
                if (options.remainingArgs.length > 1) {
                    return { success: false, error: `${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'` };
                }
                const validation = FileSystemManager.validatePath(commandName, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileContent = validation.node.content || "";
                const lines = fileContent.split('\n');
                const outputLines = lines.slice(Math.max(0, lines.length - numLines));
                const finalOutput = errorMessages.length > 0 ? errorMessages.join('\n') + '\n' + outputLines.join('\n') : outputLines.join('\n');
                const messageType = errorMessages.length > 0 ? Config.CSS_CLASSES.WARNING_MSG : null;
                return { success: true, output: finalOutput, messageType: messageType };
            }
            async function handleExport(args, cmdOptions) {
                const filePathArg = args[0];
                if (!filePathArg) return { success: false, error: `export: missing file operand\nUsage: ${commandHelpData.export.usage}` };
                const validation = FileSystemManager.validatePath(Config.COMMAND_NAMES.EXPORT, filePathArg, {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    defaultToCurrentIfEmpty: false
                });
                if (validation.error) return { success: false, error: validation.error };
                const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1) || 'downloaded_file.txt';
                const fileContent = validation.node.content || "";
                const mimeType = "text/plain";
                try {
                    const blob = new Blob([fileContent], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return { success: true, output: `${Config.MESSAGES.EXPORTING_PREFIX}${fileName}${Config.MESSAGES.EXPORTING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Export failed:", error);
                    return { success: false, error: `Error exporting file '${fileName}': ${error.message}` };
                }
            }
            async function handleBackup(args, cmdOptions) {
                const currentUser = UserManager.getCurrentUser();
                const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
                const backupFileName = `oopis_backup_${currentUser.name}_${timestamp}.json`;
                const backupData = {
                    backupVersion: "1.0",
                    osVersion: Config.OS.VERSION,
                    user: currentUser.name,
                    timestamp: new Date().toISOString(),
                    filesystem: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    currentPath: FileSystemManager.getCurrentPath(),
                    commandHistory: HistoryManager.getFullHistory()
                };
                try {
                    const jsonString = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = backupFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return { success: true, output: `${Config.MESSAGES.BACKUP_CREATING_PREFIX}${backupFileName}${Config.MESSAGES.BACKUP_CREATING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } catch (error) {
                    console.error("Backup failed:", error);
                    return { success: false, error: `Error creating backup: ${error.message}` };
                }
            }
            async function handleImport(args, cmdOptions) {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                return new Promise((resolveCommand) => {
                    fileInput.onchange = async (event) => {
                        const file = event.target.files[0];
                        if (!file) {
                            await OutputManager.appendToOutput(Config.MESSAGES.IMPORT_CANCELLED_NO_FILE, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            resolveCommand({ success: true, output: null });
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const fileContent = e.target.result;
                                const parsedData = JSON.parse(fileContent);
                                if (typeof parsedData !== 'object' || parsedData === null ||
                                    !parsedData.hasOwnProperty('filesystem') || !parsedData.hasOwnProperty('user') ||
                                    !parsedData.hasOwnProperty('currentPath') || !parsedData.hasOwnProperty('commandHistory') ||
                                    !parsedData.hasOwnProperty('backupVersion')) {
                                    await OutputManager.appendToOutput("Error: Invalid backup file format. Missing essential properties.", { isError: true });
                                    resolveCommand({ success: false, error: "Invalid backup file." });
                                    return;
                                }
                                if (parsedData.backupVersion !== "1.0") {
                                    await OutputManager.appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                                }
                                const dataForConfirm = { parsedData: parsedData, fileName: file.name };
                                ConfirmationManager.request(
                                    [`Backup file '${file.name}' for user '${parsedData.user}' selected.`, `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`],
                                    dataForConfirm,
                                    async (data) => {
                                        const importedUser = data.parsedData.user;
                                        const currentActiveUser = UserManager.getCurrentUser();
                                        if (currentActiveUser.name !== Config.USER.DEFAULT_NAME && currentActiveUser.name !== importedUser && !isDiagActiveState) {
                                            SessionManager.saveAutomaticState(currentActiveUser.name);
                                        }
                                        UserManager.setCurrentUserObject({ name: importedUser, credentials: StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {}) });
                                        FileSystemManager.setFsData(Utils.deepCopyNode(data.parsedData.filesystem) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                                        FileSystemManager.setCurrentPath(data.parsedData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                                        HistoryManager.setHistory(data.parsedData.commandHistory || []);
                                        OutputManager.clearOutput();
                                        TerminalUI.clearInput();
                                        await FileSystemManager.save(importedUser);
                                        await AliasManager.load(importedUser);
                                        const userCredentials = StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {});
                                        if (!userCredentials[importedUser] && importedUser !== Config.USER.DEFAULT_NAME) {
                                            await OutputManager.appendToOutput(`Warning: User '${importedUser}' from backup does not have credentials. Session restored, but login for this user is not possible without registering.`, { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
                                        }
                                        await OutputManager.appendToOutput(`${Config.MESSAGES.IMPORT_SUCCESS_PREFIX}${importedUser}${Config.MESSAGES.IMPORT_SUCCESS_MIDDLE}${data.fileName}${Config.MESSAGES.IMPORT_SUCCESS_SUFFIX}`, { isInstant: true, typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                        TerminalUI.updatePrompt();
                                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                                        resolveCommand({ success: true, output: null});
                                    },
                                    () => {
                                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                                        resolveCommand({ success: true, output: null});
                                    }
                                );
                            } catch (parseError) {
                                console.error("Import error - parsing JSON:", parseError);
                                await OutputManager.appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", { isError: true });
                                resolveCommand({ success: false, error: "Could not parse backup file."});
                            }
                        };
                        reader.onerror = async (e) => {
                            console.error("Import error - reading file:", e);
                            await OutputManager.appendToOutput("Error: Could not read the selected file.", { isError: true });
                            resolveCommand({ success: false, error: "Could not read file."});
                        };
                        reader.readAsText(file);
                    };
                    fileInput.click();
                });
            }
            async function handleDiff(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.DIFF;
                if (args.length !== 2) return { success: false, error: `${commandName}: missing operand. Requires two file arguments.\nUsage: ${commandHelpData.diff.usage}` };
                const file1PathArg = args[0], file2PathArg = args[1];
                const validation1 = FileSystemManager.validatePath(commandName, file1PathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false });
                if (validation1.error) return { success: false, error: validation1.error };
                const validation2 = FileSystemManager.validatePath(commandName, file2PathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, defaultToCurrentIfEmpty: false });
                if (validation2.error) return { success: false, error: validation2.error };
                const lines1 = (validation1.node.content || "").split('\n');
                const lines2 = (validation2.node.content || "").split('\n');
                const lcsArray = Utils.findLCS(lines1, lines2);
                let ptr1 = 0, ptr2 = 0, ptrLcs = 0;
                const diffOutput = [];
                let differencesFound = false;
                while (ptr1 < lines1.length || ptr2 < lines2.length) {
                    const line1Exists = ptr1 < lines1.length;
                    const line2Exists = ptr2 < lines2.length;
                    const lcsExists = ptrLcs < lcsArray.length;
                    if (lcsExists && line1Exists && lines1[ptr1] === lcsArray[ptrLcs] && line2Exists && lines2[ptr2] === lcsArray[ptrLcs]) {
                        ptr1++; ptr2++; ptrLcs++;
                    } else {
                        differencesFound = true;
                        if (line1Exists && (!lcsExists || lines1[ptr1] !== lcsArray[ptrLcs])) {
                            if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                                diffOutput.push(`< ${lines1[ptr1]}`);
                                diffOutput.push(`> ${lines2[ptr2]}`);
                                ptr1++; ptr2++;
                            } else {
                                diffOutput.push(`< ${lines1[ptr1]}`);
                                ptr1++;
                            }
                        } else if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                            diffOutput.push(`> ${lines2[ptr2]}`);
                            ptr2++;
                        } else {
                            if (ptr1 < lines1.length) { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; }
                            else if (ptr2 < lines2.length) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; }
                            else break;
                        }
                    }
                }
                return { success: true, output: differencesFound ? diffOutput.join('\n') : "" };
            }
            async function handleHistoryCmd(args, cmdOptions) {
                const history = HistoryManager.getFullHistory();
                if (history.length === 0) return { success: true, output: Config.MESSAGES.NO_COMMANDS_IN_HISTORY };
                return { success: true, output: history.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n') };
            }
            async function handleAliasCmd(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.ALIAS;
                const currentUser = UserManager.getCurrentUser().name;
                if (args.length === 0) {
                    const aliases = AliasManager.getAliases();
                    if (Object.keys(aliases).length === 0) return { success: true, output: Config.MESSAGES.NO_ALIASES_DEFINED };
                    const output = [];
                    for (const name in aliases) {
                        let value = aliases[name];
                        if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                            value = `'${value.replace(/'/g, "'\\''")}'`;
                        }
                        output.push(`${name}=${value}`);
                    }
                    return { success: true, output: output.join('\n') };
                }
                const firstArg = args.join(" ");
                const assignmentIndex = firstArg.indexOf('=');
                if (assignmentIndex === -1) {
                    const aliasName = args[0];
                    if (AliasManager.hasAlias(aliasName)) {
                        let value = AliasManager.getAliases()[aliasName];
                        if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                            value = `'${value.replace(/'/g, "'\\''")}'`;
                        }
                        return { success: true, output: `alias ${aliasName}=${value}` };
                    } else return { success: false, error: `${commandName}: ${aliasName}: not found` };
                } else {
                    const aliasName = firstArg.substring(0, assignmentIndex).trim();
                    let commandString = firstArg.substring(assignmentIndex + 1).trim();
                    if (!aliasName) return { success: false, error: `${commandName}: invalid alias name.` };
                    if (aliasName.includes(" ")) return { success: false, error: `${commandName}: alias name cannot contain spaces.` };
                    if (commandRegistry.hasOwnProperty(aliasName) && aliasName !== Config.COMMAND_NAMES.ALIAS && aliasName !== Config.COMMAND_NAMES.UNALIAS) {
                        return { success: false, error: `${commandName}: '${aliasName}' is a built-in command. Cannot create alias.` };
                    }
                    if (commandString === "") {
                        if (AliasManager.hasAlias(aliasName)) {
                            AliasManager.removeAlias(aliasName);
                            await AliasManager.save(currentUser);
                            return { success: true, output: `${aliasName}${Config.MESSAGES.ALIAS_UNSET_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                        return { success: true, output: null };
                    }
                    if ((commandString.startsWith("'") && commandString.endsWith("'")) || (commandString.startsWith('"') && commandString.endsWith('"'))) {
                        commandString = commandString.substring(1, commandString.length - 1);
                    }
                    if (aliasName === commandString.split(' ')[0]) {
                        return { success: false, error: `${commandName}: cannot alias '${aliasName}' to itself directly.` };
                    }
                    AliasManager.setAlias(aliasName, commandString);
                    await AliasManager.save(currentUser);
                    return { success: true, output: `Alias '${aliasName}'${Config.MESSAGES.ALIAS_SET_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                }
            }
            async function handleUnaliasCmd(args, cmdOptions) {
                const commandName = Config.COMMAND_NAMES.UNALIAS;
                const currentUser = UserManager.getCurrentUser().name;
                if (args.length !== 1) return { success: false, error: `${commandName}: usage: unalias <name>` };
                const aliasName = args[0];
                if (AliasManager.hasAlias(aliasName)) {
                    AliasManager.removeAlias(aliasName);
                    await AliasManager.save(currentUser);
                    return { success: true, output: `Alias '${aliasName}' removed.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                } else return { success: false, error: `${commandName}: ${aliasName}: not found` };
            }

            const commandRegistry = {
                [Config.COMMAND_NAMES.LS]: handleLs,
                [Config.COMMAND_NAMES.CD]: handleCd,
                [Config.COMMAND_NAMES.MKDIR]: handleMkdir,
                [Config.COMMAND_NAMES.TOUCH]: handleTouch,
                [Config.COMMAND_NAMES.CAT]: handleCat,
                [Config.COMMAND_NAMES.ECHO]: handleEcho,
                [Config.COMMAND_NAMES.MV]: handleMv,
                [Config.COMMAND_NAMES.CP]: handleCp,
                [Config.COMMAND_NAMES.RM]: handleRm,
                [Config.COMMAND_NAMES.PWD]: handlePwd,
                [Config.COMMAND_NAMES.DATE]: handleDate,
                [Config.COMMAND_NAMES.WHOAMI]: handleWhoami,
                [Config.COMMAND_NAMES.RUN]: handleRun,
                [Config.COMMAND_NAMES.GREP]: handleGrep,
                [Config.COMMAND_NAMES.SORT]: handleSort,
                [Config.COMMAND_NAMES.SYSMON]: handleSysmon,
                [Config.COMMAND_NAMES.CLEAR]: handleClear,
                [Config.COMMAND_NAMES.REGISTER]: handleRegisterCmd,
                [Config.COMMAND_NAMES.LOGIN]: handleLoginCmd,
                [Config.COMMAND_NAMES.LOGOUT]: handleLogoutCmd,
                [Config.COMMAND_NAMES.SAVESTATE]: handleSavestate,
                [Config.COMMAND_NAMES.LOADSTATE]: handleLoadstate,
                [Config.COMMAND_NAMES.RESET]: handleReset,
                [Config.COMMAND_NAMES.HELP]: handleHelp,
                [Config.COMMAND_NAMES.MAN]: handleMan,
                [Config.COMMAND_NAMES.EDIT]: handleEditCmd,
                [Config.COMMAND_NAMES.DIAG]: handleDiag,
                [Config.COMMAND_NAMES.TREE]: handleTree,
                [Config.COMMAND_NAMES.FIND]: handleFind,
                [Config.COMMAND_NAMES.DU]: handleDu,
                [Config.COMMAND_NAMES.HEAD]: handleHead,
                [Config.COMMAND_NAMES.TAIL]: handleTail,
                [Config.COMMAND_NAMES.EXPORT]: handleExport,
                [Config.COMMAND_NAMES.BACKUP]: handleBackup,
                [Config.COMMAND_NAMES.IMPORT]: handleImport,
                [Config.COMMAND_NAMES.WC]: handleWc,
                [Config.COMMAND_NAMES.DIFF]: handleDiff,
                [Config.COMMAND_NAMES.HISTORY]: handleHistoryCmd,
                [Config.COMMAND_NAMES.ALIAS]: handleAliasCmd,
                [Config.COMMAND_NAMES.UNALIAS]: handleUnaliasCmd
            };

            function _parseInputAndRedirection(originalInputText, expandedCommandText) {
                let commandToExecute = expandedCommandText;
                let redirectionType = null;
                let redirectionFile = null;
                const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/);
                if (appendMatch) {
                    redirectionType = 'append';
                    redirectionFile = appendMatch[1];
                    commandToExecute = commandToExecute.substring(0, appendMatch.index).trim();
                } else {
                    const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/);
                    if (overwriteMatch) {
                        redirectionType = 'overwrite';
                        redirectionFile = overwriteMatch[1];
                        commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim();
                    }
                }
                const parts = commandToExecute.split(' ').filter(p => p);
                const baseCommand = parts[0] ? parts[0].toLowerCase() : '';
                let args;
                if (baseCommand === Config.COMMAND_NAMES.ALIAS && commandToExecute.includes('=')) {
                    args = [commandToExecute.substring(baseCommand.length).trimStart()];
                } else {
                    args = parts.slice(1);
                }
                return {
                    baseCommand, args,
                    redirection: redirectionType ? { type: redirectionType, file: redirectionFile } : null,
                    originalInput: originalInputText, executedCommand: expandedCommandText
                };
            }
            async function _executeCommandHandler(parsedCommand, cmdOptions = {}) {
                const handler = commandRegistry[parsedCommand.baseCommand];
                if (handler) {
                    try {
                        return await handler(parsedCommand.args, cmdOptions);
                    } catch (e) {
                        console.error(`Critical error in '${parsedCommand.baseCommand}':`, e);
                        return { success: false, error: `Unexpected critical error executing '${parsedCommand.baseCommand}'. Check console for details.`, output: null };
                    }
                } else {
                    return { success: false, error: `Error: Command not found: "${parsedCommand.baseCommand}"`, output: null };
                }
            }
            async function _processCommandOutput(parsedCommand, cmdResult, isInteractive) {
                let overallSuccess = cmdResult.success;
                if (!cmdResult.success && cmdResult.error) {
                    await OutputManager.appendToOutput(cmdResult.error, { isError: true });
                    lastCommandFailed = true;
                }
                if (cmdResult.output !== null && cmdResult.output !== undefined && !cmdResult.awaitingPassword) {
                    if (parsedCommand.redirection) {
                        const redirResult = await _handleRedirection(parsedCommand.baseCommand, cmdResult.output, parsedCommand.redirection);
                        if (!redirResult.success) {
                            await OutputManager.appendToOutput(redirResult.error, { isError: true });
                            lastCommandFailed = true;
                            overallSuccess = false;
                        }
                    } else if (!cmdResult.isHtmlOutput) {
                        await OutputManager.appendToOutput(String(cmdResult.output), {
                            isError: !cmdResult.success,
                            typeClass: cmdResult.messageType
                        });
                    }
                }
                 if (lastCommandFailed && overallSuccess) {
                    overallSuccess = false;
                }
                return { ...cmdResult, success: overallSuccess };
            }
            async function _finalizeInteractiveModeUI() {
                if (!TerminalUI.isPasswordInputActiveState()){
                    TerminalUI.clearInput();
                    TerminalUI.updatePrompt();
                    TerminalUI.focusInput();
                }
                DOM.inputLineContainerDiv.style.visibility = 'visible';
            }
            async function _handleRedirection(commandName, commandOutputContent, redirection) {
                if (!redirection || !redirection.file) {
                    return { success: false, error: `${commandName}: ${Config.INTERNAL_ERRORS.REDIRECTION_FILE_NOT_SPECIFIED}` };
                }
                const validationOptions = {
                    expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE,
                    allowMissing: true,
                    disallowRoot: true,
                    defaultToCurrentIfEmpty: false
                };
                const validation = FileSystemManager.validatePath(commandName, redirection.file, validationOptions);
                if (validation.error) {
                    if (validation.node && validation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { success: false, error: `${commandName}: cannot redirect to '${redirection.file}': It is a directory.` };
                    } else {
                        return { success: false, error: validation.error };
                    }
                }
                const targetAbsPath = validation.resolvedPath;
                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetAbsPath);
                if (parentDirResult.error) {
                    return { success: false, error: `${commandName}: ${parentDirResult.error}` };
                }
                const parentNode = parentDirResult.parentNode;
                if (!parentNode) {
                    return { success: false, error: `${commandName}: error obtaining parent directory for redirection target '${redirection.file}'.` };
                }
                const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const targetNode = parentNode.children[newFileName];
                let contentToWrite = (commandOutputContent !== null && commandOutputContent !== undefined) ? String(commandOutputContent) : "";
                if (redirection.type === 'overwrite' || !targetNode) {
                    parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: contentToWrite };
                } else if (redirection.type === 'append' && targetNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                    const existingContent = targetNode.content || "";
                    const separator = (existingContent && contentToWrite) ? "\n" : "";
                    parentNode.children[newFileName].content = existingContent + separator + contentToWrite;
                } else {
                    return { success: false, error: `${commandName}: cannot write to '${redirection.file}': Unexpected target type or situation.` };
                }
                if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                    return { success: false, error: `${commandName}: failed to save redirected output to '${redirection.file}'.` };
                }
                return { success: true };
            }
            async function processSingleCommand(rawCommandText, isInteractive = true) {
                lastCommandFailed = false;
                let finalResult = { success: true, output: null, error: null, messageType: null, isHtmlOutput: false, awaitingPassword: false };
                if (EditorManager.isActive() && !isDiagActiveState) return finalResult;
                if (ConfirmationManager.isAwaiting()) {
                    await ConfirmationManager.handleConfirmation(rawCommandText);
                     if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }
                let commandToExecute = rawCommandText.trim();
                let executedCommandTextForDisplay = commandToExecute;
                if (TerminalUI.isPasswordInputActiveState()) {
                    const context = TerminalUI.getPasswordContext();
                    const password = rawCommandText.trim();
                    await OutputManager.appendToOutput(Config.MESSAGES.PASSWORD_MASK_CHAR.repeat(password.length), {isInstant: true});
                    commandToExecute = `${context.commandName} ${context.username} ${password}`;
                    executedCommandTextForDisplay = `${context.commandName} ${context.username} ${Config.MESSAGES.PASSWORD_MASK_CHAR.repeat(6)}`;
                    TerminalUI.switchToEditableInput();
                }
                if (isInteractive && !TerminalUI.isPasswordInputActiveState()) {
                    DOM.inputLineContainerDiv.style.visibility = 'hidden';
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                    await OutputManager.appendToOutput(`${promptText}${executedCommandTextForDisplay}`, { isInstant: true });
                }
                if (commandToExecute === '' && !TerminalUI.isPasswordInputActiveState()) {
                    if (isInteractive) await _finalizeInteractiveModeUI();
                    return finalResult;
                }
                if (isInteractive && !TerminalUI.isPasswordInputActiveState()) {
                    HistoryManager.add(rawCommandText.trim());
                }
                if (isInteractive && !TerminalUI.getIsNavigatingHistory() && !TerminalUI.isPasswordInputActiveState()) {
                     HistoryManager.resetIndex();
                }
                const expandedCommandText = await AliasManager.expand(commandToExecute);
                if (commandToExecute !== expandedCommandText && isInteractive && !TerminalUI.isPasswordInputActiveState()) {
                    await OutputManager.appendToOutput(`> ${expandedCommandText}`, { isInstant: true, typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                const parsedCommand = _parseInputAndRedirection(rawCommandText.trim(), expandedCommandText);
                const cmdOptions = {
                    force: (parsedCommand.baseCommand === Config.COMMAND_NAMES.RM && !isInteractive) ||
                           (parsedCommand.args.includes('-f') || parsedCommand.args.includes('--force'))
                };
                const cmdResult = await _executeCommandHandler(parsedCommand, cmdOptions);
                finalResult = await _processCommandOutput(parsedCommand, cmdResult, isInteractive);
                if (isInteractive && !cmdResult.awaitingPassword) {
                    await _finalizeInteractiveModeUI();
                } else if (isInteractive && cmdResult.awaitingPassword) {
                    DOM.inputLineContainerDiv.style.visibility = 'visible';
                    TerminalUI.focusInput();
                }
                return finalResult;
            }
            async function _backupDiagState() {
                return {
                    currentUser: UserManager.getCurrentUser(),
                    fsData: Utils.deepCopyNode(FileSystemManager.getFsData()),
                    currentPath: FileSystemManager.getCurrentPath(),
                    userCredentials: Utils.deepCopyNode(StorageManager.loadJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, "User creds", {})),
                    outputHTML: DOM.outputDiv.innerHTML,
                    commandHistory: HistoryManager.getFullHistory(),
                    aliases: AliasManager.getAliases()
                };
            }
            async function _restoreDiagState(state) {
                UserManager.setCurrentUserObject(state.currentUser);
                StorageManager.saveJSON(Config.STORAGE_KEYS.USER_CREDENTIALS, state.userCredentials, "User creds");
                FileSystemManager.setFsData(state.fsData);
                await FileSystemManager.save(state.currentUser.name);
                FileSystemManager.setCurrentPath(state.currentPath);
                AliasManager.getAliases();
                for (const aliasName in state.aliases) {
                    AliasManager.setAlias(aliasName, state.aliases[aliasName]);
                }
                await AliasManager.save(state.currentUser.name);
                HistoryManager.setHistory(state.commandHistory);
                TerminalUI.updatePrompt();
            }
            async function _setupDiagUserEnvironment(diagPrint) {
                const testUser = Config.DIAGNOSTICS.TEST_USER_NAME;
                const testPass = Config.DIAGNOSTICS.TEST_USER_PASS;
                const testBaseDir = Config.DIAGNOSTICS.TEST_BASE_DIR_PATH_PREFIX + Config.DIAGNOSTICS.TEST_BASE_DIR_NAME;
                let loginResult = await UserManager.login(testUser, testPass);
                if (!loginResult.success || loginResult.error === "Invalid username or password.") {
                    await UserManager.register(testUser, testPass);
                    loginResult = await UserManager.login(testUser, testPass);
                }
                if (!loginResult.success) {
                    await diagPrint(`  ERROR: Failed to login/register diag user '${testUser}'.`);
                    return false;
                }
                await processSingleCommand(`${Config.COMMAND_NAMES.RM} -f ${testBaseDir}`, false);
                const mkdirResult = await processSingleCommand(`${Config.COMMAND_NAMES.MKDIR} ${testBaseDir}`, false);
                if (!mkdirResult.success) {
                    await diagPrint(`  ERROR: Failed to create diag base directory '${testBaseDir}'. ${mkdirResult.error || ''}`);
                    return false;
                }
                const cdResult = await processSingleCommand(`${Config.COMMAND_NAMES.CD} ${testBaseDir}`, false);
                 if (!cdResult.success) {
                    await diagPrint(`  ERROR: Failed to cd into diag base directory '${testBaseDir}'. ${cdResult.error || ''}`);
                    return false;
                }
                return true;
            }
            async function _teardownDiagUserEnvironment(diagPrint) {
                const testBaseDirFullPath = Config.DIAGNOSTICS.TEST_BASE_DIR_PATH_PREFIX + Config.DIAGNOSTICS.TEST_BASE_DIR_NAME;
                await processSingleCommand(`${Config.COMMAND_NAMES.CD} ${Config.FILESYSTEM.ROOT_PATH}`, false);
                const rmResult = await processSingleCommand(`${Config.COMMAND_NAMES.RM} -f ${testBaseDirFullPath}`, false);
                if (!rmResult.success && rmResult.error) {
                    await diagPrint(`  WARN: Failed to cleanup diag base directory '${testBaseDirFullPath}'. ${rmResult.error}`);
                }
            }
            async function _createDiagTestFile(filePath, content, diagPrint) {
                const escapedContent = content.replace(/"/g, '\\"').replace(/\n/g, '\\n');
                const echoCmd = `${Config.COMMAND_NAMES.ECHO} "${escapedContent}" > ${filePath}`;
                const echoResult = await processSingleCommand(echoCmd, false);
                if (!echoResult.success) {
                    await diagPrint(`  WARN: Diag failed to create test file '${filePath}'. Error: ${echoResult.error || 'Unknown error'}`);
                    return false;
                }
                return true;
            }
            async function _runPathResolutionTests(diagPrint, report) {
                await diagPrint("\nSECTION: Filesystem Path & Node Tests", Config.CSS_CLASSES.DIAG_SECTION_TITLE);
                const pathTests = [
                    { name: "Current dir at root", target: '.', base: '/', expected: '/' }, { name: "Parent dir at root", target: '..', base: '/', expected: '/' },
                    { name: "Simple relative from root", target: 'foo', base: '/', expected: '/foo' }, { name: "Absolute target, ignore base", target: '/foo/bar', base: '/baz', expected: '/foo/bar' },
                    { name: "Relative .. from /foo/baz", target: '../bar', base: '/foo/baz', expected: '/foo/bar' }, { name: "Relative ../../ to root", target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar' },
                    { name: "Empty target (current dir)", target: '', base: '/foo', expected: '/foo' }, { name: "Trailing slash", target: 'dir/', base: '/foo', expected: '/foo/dir' },
                    { name: "Multiple slashes", target: '//a//b/', base: '/', expected: '/a/b' }
                ];
                for (const tc of pathTests) {
                    const actual = FileSystemManager.getAbsolutePath(tc.target, tc.base);
                    await report(`PathTest: ${tc.name}`, actual === tc.expected, "", String(tc.expected), String(actual));
                }
            }
            async function _runNodeOperationTests(diagPrint, report) {
                await _createDiagTestFile(Config.DIAGNOSTICS.DEFAULT_TEST_FILENAME, Config.DIAGNOSTICS.DEFAULT_TEST_FILE_CONTENT, diagPrint);
                let node = FileSystemManager.getNodeByPath(Config.DIAGNOSTICS.DEFAULT_TEST_FILENAME);
                await report("NodeTest: getNodeByPath existing file", node && node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.content === Config.DIAGNOSTICS.DEFAULT_TEST_FILE_CONTENT);
                node = FileSystemManager.getNodeByPath("nonexistent_file_for_diag.txt");
                await report("NodeTest: getNodeByPath non-existent", node === null);
                let validation = FileSystemManager.validatePath("testcmd", Config.DIAGNOSTICS.DEFAULT_TEST_FILENAME, {expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE});
                await report("NodeTest: validatePath existing file as file", validation.error === null && validation.node !== null);
                validation = FileSystemManager.validatePath("testcmd", Config.DIAGNOSTICS.DEFAULT_TEST_FILENAME, {expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE});
                await report("NodeTest: validatePath existing file as dir", validation.error !== null);
                validation = FileSystemManager.validatePath("testcmd", "new_diag_dir", {allowMissing: true});
                await report("NodeTest: validatePath non-existent allowMissing", validation.error === null && validation.node === null);
            }
            async function _runAliasTests(diagPrint, report) {
                await diagPrint("\nSECTION: Alias Tests", Config.CSS_CLASSES.DIAG_SECTION_TITLE);
                const testAliasName = "mylsdiag";
                const testAliasValue = "ls -l";
                await processSingleCommand(`${Config.COMMAND_NAMES.ALIAS} ${testAliasName}='${testAliasValue}'`, false);
                await report("AliasTest: Creation", AliasManager.hasAlias(testAliasName) && AliasManager.getAliases()[testAliasName] === testAliasValue, "", testAliasValue, AliasManager.getAliases()[testAliasName]);
                let expanded = await AliasManager.expand(`${testAliasName} /some/path`);
                await report("AliasTest: Expansion", expanded === `${testAliasValue} /some/path`, "", `${testAliasValue} /some/path`, expanded);
                await processSingleCommand(`${Config.COMMAND_NAMES.UNALIAS} ${testAliasName}`, false);
                await report("AliasTest: Deletion", !AliasManager.hasAlias(testAliasName));
            }
            async function _runRedirectionTests(diagPrint, report) {
                await diagPrint("\nSECTION: Redirection Tests", Config.CSS_CLASSES.DIAG_SECTION_TITLE);
                const redirFile = Config.DIAGNOSTICS.REDIRECT_TEST_FILENAME;
                const contentOverwrite = Config.DIAGNOSTICS.REDIRECT_TEST_CONTENT_OVERWRITE;
                const contentAppend = Config.DIAGNOSTICS.REDIRECT_TEST_CONTENT_APPEND;
                await processSingleCommand(`${Config.COMMAND_NAMES.ECHO} '${contentOverwrite}' > ${redirFile}`, false);
                let node = FileSystemManager.getNodeByPath(redirFile);
                await report("RedirTest: Overwrite (>)", node && node.content === contentOverwrite, "", contentOverwrite, node ? node.content : "null");
                await processSingleCommand(`${Config.COMMAND_NAMES.ECHO} '${contentAppend}' >> ${redirFile}`, false);
                node = FileSystemManager.getNodeByPath(redirFile);
                const expectedAppendContent = `${contentOverwrite}\n${contentAppend}`;
                await report("RedirTest: Append (>>)", node && node.content === expectedAppendContent, "", expectedAppendContent, node ? node.content : "null");
            }
            async function _runFileContentCommandTests(diagPrint, report) {
                await diagPrint("\nSECTION: File Content Commands (wc, head, tail, diff)", Config.CSS_CLASSES.DIAG_SECTION_TITLE);
                const wcFile = Config.DIAGNOSTICS.WC_TEST_FILENAME;
                const wcContent = Config.DIAGNOSTICS.WC_TEST_CONTENT;
                await _createDiagTestFile(wcFile, wcContent, diagPrint);
                const expectedWcCountsDefault = _calculateWcCounts(wcContent, true, true);
                const expectedWcCountsL = _calculateWcCounts(wcContent, true, false);
                let wcRes = await processSingleCommand(`${Config.COMMAND_NAMES.WC} ${wcFile}`, false);
                const expectedWcDefaultStr = _formatWcLine(expectedWcCountsDefault, wcFile, true, true, true, true);
                await report("WcTest: default", wcRes.success && wcRes.output && wcRes.output.trim() === expectedWcDefaultStr, "", expectedWcDefaultStr, wcRes.output ? wcRes.output.trim() : 'null');
                wcRes = await processSingleCommand(`${Config.COMMAND_NAMES.WC} -l ${wcFile}`, false);
                const expectedWcLStr = _formatWcLine({lines: expectedWcCountsL.lines, words:0, bytes:0} , wcFile, true, false, false, false);
                await report("WcTest: -l", wcRes.success && wcRes.output && wcRes.output.trim() === expectedWcLStr, "", expectedWcLStr, wcRes.output ? wcRes.output.trim() : 'null');
                const htFile = Config.DIAGNOSTICS.HT_TEST_FILENAME;
                const htContent = Config.DIAGNOSTICS.HT_TEST_CONTENT;
                await _createDiagTestFile(htFile, htContent, diagPrint);
                await _createDiagTestFile(Config.DIAGNOSTICS.EMPTY_TEST_FILENAME, "", diagPrint);
                let htRes = await processSingleCommand(`${Config.COMMAND_NAMES.HEAD} ${htFile}`, false);
                await report("HeadTest: default (10 lines)", htRes.success && htRes.output === htContent.split('\n').slice(0,10).join('\n'));
                htRes = await processSingleCommand(`${Config.COMMAND_NAMES.HEAD} -n 3 ${htFile}`, false);
                await report("HeadTest: -n 3", htRes.success && htRes.output === "Line 1\nLine 2\nLine 3");
                htRes = await processSingleCommand(`${Config.COMMAND_NAMES.TAIL} ${htFile}`, false);
                await report("TailTest: default (10 lines)", htRes.success && htRes.output === htContent.split('\n').slice(2).join('\n'));
                htRes = await processSingleCommand(`${Config.COMMAND_NAMES.TAIL} -n 3 ${htFile}`, false);
                await report("TailTest: -n 3", htRes.success && htRes.output === "Line 10\nLine 11\nLine 12");
                await _createDiagTestFile(Config.DIAGNOSTICS.DIFF_FILE1_NAME, Config.DIAGNOSTICS.DIFF_FILE1_CONTENT, diagPrint);
                await _createDiagTestFile(Config.DIAGNOSTICS.DIFF_FILE2_NAME, Config.DIAGNOSTICS.DIFF_FILE2_CONTENT, diagPrint);
                await _createDiagTestFile(Config.DIAGNOSTICS.DIFF_FILE3_NAME, Config.DIAGNOSTICS.DIFF_FILE3_CONTENT, diagPrint);
                await _createDiagTestFile(Config.DIAGNOSTICS.DIFF_FILE4_NAME, Config.DIAGNOSTICS.DIFF_FILE4_CONTENT, diagPrint);
                await _createDiagTestFile(Config.DIAGNOSTICS.DIFF_FILE5_NAME, Config.DIAGNOSTICS.DIFF_FILE5_CONTENT, diagPrint);
                let diffRes = await processSingleCommand(`${Config.COMMAND_NAMES.DIFF} ${Config.DIAGNOSTICS.DIFF_FILE1_NAME} ${Config.DIAGNOSTICS.DIFF_FILE2_NAME}`, false);
                await report("DiffTest: identical", diffRes.success && diffRes.output === "");
                diffRes = await processSingleCommand(`${Config.COMMAND_NAMES.DIFF} ${Config.DIAGNOSTICS.DIFF_FILE1_NAME} ${Config.DIAGNOSTICS.DIFF_FILE3_NAME}`, false);
                await report("DiffTest: addition in file2", diffRes.success && diffRes.output === "> date", "", "> date", diffRes.output);
                diffRes = await processSingleCommand(`${Config.COMMAND_NAMES.DIFF} ${Config.DIAGNOSTICS.DIFF_FILE1_NAME} ${Config.DIAGNOSTICS.DIFF_FILE4_NAME}`, false);
                await report("DiffTest: deletion in file2 (seen as removed from file1)", diffRes.success && diffRes.output === "< banana", "", "< banana", diffRes.output);
                diffRes = await processSingleCommand(`${Config.COMMAND_NAMES.DIFF} ${Config.DIAGNOSTICS.DIFF_FILE1_NAME} ${Config.DIAGNOSTICS.DIFF_FILE5_NAME}`, false);
                await report("DiffTest: changed line", diffRes.success && diffRes.output === "< banana\n> blueberry", "", "< banana\n> blueberry", diffRes.output);
            }
            return {
                processSingleCommand,
                isDiagActive: () => isDiagActiveState,
                getLastCommandFailed: () => lastCommandFailed
            };
        })();

        function initializeTerminalEventListeners() {
            DOM.terminalDiv.addEventListener('click', e => {
                if (EditorManager.isActive()) { return; }
                if (!e.target.closest('button, a') || e.target.closest('.input-line-container')) {
                    TerminalUI.focusInput();
                }
            });
            const getCurrentInputTarget = () => {
                const passwordField = document.getElementById('password-input-field');
                return (passwordField && passwordField.style.display !== 'none') ? passwordField : DOM.editableInputDiv;
            };
            document.addEventListener('keydown', async e => {
                if (EditorManager.isActive()) return;
                const activeInputTarget = getCurrentInputTarget();
                if (document.activeElement !== activeInputTarget) return;
                TerminalUI.setIsNavigatingHistory(false);
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const commandText = TerminalUI.getCurrentInputValue();
                    await CommandExecutor.processSingleCommand(commandText, true);
                } else if (e.key === 'ArrowUp') {
                    if (!TerminalUI.isPasswordInputActiveState()) {
                        e.preventDefault();
                        const prevCommand = HistoryManager.getPrevious();
                        if (prevCommand !== null) {
                            TerminalUI.setIsNavigatingHistory(true);
                            TerminalUI.setCurrentInputValue(prevCommand, true);
                        }
                    }
                } else if (e.key === 'ArrowDown') {
                     if (!TerminalUI.isPasswordInputActiveState()) {
                        e.preventDefault();
                        const nextCommand = HistoryManager.getNext();
                        if (nextCommand !== null) {
                            TerminalUI.setIsNavigatingHistory(true);
                            TerminalUI.setCurrentInputValue(nextCommand, true);
                        }
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    if (DOM.editableInputDiv && document.activeElement === DOM.editableInputDiv) {
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        const range = selection.getRangeAt(0);
                        const tabNode = document.createTextNode(Config.EDITOR.TAB_REPLACEMENT);
                        range.deleteContents();
                        range.insertNode(tabNode);
                        range.setStartAfter(tabNode);
                        range.setEndAfter(tabNode);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            });
            if (DOM.editableInputDiv) {
                DOM.editableInputDiv.addEventListener('paste', e => {
                    if (TerminalUI.isPasswordInputActiveState()) {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' '));
                });
            }
        }

        window.diagInitializedForOutput = false;
        window.onload = async () => {
            await OutputManager.appendToOutput("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.", { isInstant: true, typeClass: Config.CSS_CLASSES.WARNING_MSG });
            try {
                await IndexedDBManager.init();
                const guestUser = { name: UserManager.getDefaultUser(), credentials: {} };
                UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.load(UserManager.getDefaultUser());
                await AliasManager.load(UserManager.getDefaultUser());
                SessionManager.loadAutomaticState(UserManager.getDefaultUser());
                initializeTerminalEventListeners();
                TerminalUI.focusInput();
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                await OutputManager.appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details and browser storage settings.", { isInstant: true, isError: true });
            }
        };
    </script>
</body>
</html>
