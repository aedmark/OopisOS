<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOS Version 1.0.5.3</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap; /* Preserves whitespace, wraps at spaces and newlines */
            /* word-break: break-all; -- Removed to prevent arbitrary word splitting */
            overflow-wrap: break-word; /* Allows breaking long words if they would overflow, but respects spaces first */
            overflow-x: hidden;
            min-height: 1.2em;
            line-height: 1.2em;
        }

        .input-line-container {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }
        .prompt-container {
            display: flex;
            align-items: center;
            line-height: 1.2em;
            flex-shrink: 0;
            white-space: nowrap;
            padding-top: 0.1em;
        }
        .prompt-user { margin-right: 2px; color: #7fdbff;}
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #editable-input-container {
            flex-grow: 1;
            min-width: 0;
        }

        #editable-input {
            min-height: 1.2em;
            line-height: 1.2em;
            white-space: pre-wrap; /* Preserves whitespace, wraps at spaces and newlines */
            /* word-break: break-all; -- Removed to prevent arbitrary word splitting */
            overflow-wrap: break-word; /* Allows breaking long words if they would overflow, but respects spaces first */
            outline: none;
            caret-color: #00ff00;
            color: #00ff00;
            width: 100%;
        }

        .error-message { color: #ff4136; }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .console-log-message { color: #aaaaaa; }
        .editor-message { color: #7fdbff; }
        
        .directory-item { color: #7fdbff; }
        .file-item { color: #00ff00; }

        #editor-container { flex-grow: 1; display: flex; flex-direction: column; width: 100%; height: 100%; }
        #editor-controls { padding: 5px 0; text-align: center; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; margin-bottom: 5px; }
        #editor-controls button { background-color: #333; color: #00ff00; border: 1px solid #555; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-family: 'VT323', monospace; margin-left: 5px;} 
        #editor-controls button:hover { background-color: #444; }
        #editor-filename-display { color: #aaa; font-size: 0.9em; }
        #editor-main-area { flex-grow: 1; display: flex; width: 100%; overflow: hidden; position: relative; }
        .editor-pane { flex: 1; overflow-y: auto; padding: 10px; box-sizing: border-box; height: 100%; }
        
        #editor-line-gutter {
            width: 40px; 
            padding: 10px 5px 10px 0;
            text-align: right;
            color: #555; 
            background-color: #0c0c0c; 
            overflow-y: hidden; 
            flex-shrink: 0;
            font-size: 1em; 
            line-height: 1.2em; 
            white-space: pre; 
            user-select: none; 
            box-sizing: border-box;
        }

        #editor-textarea-wrapper { border-right: 1px solid #333; padding-left:0; }
        #editor-textarea { 
            width: 100%; height: 100%; 
            background-color: #0c0c0c; color: #00dd00; 
            border: none; font-family: 'VT323', monospace; 
            font-size: 1em; line-height: 1.2em; 
            resize: none; outline: none; padding: 0 10px 0 0; 
            box-sizing: border-box;
        }
        #editor-textarea.no-wrap {
            white-space: pre;
            overflow-x: auto; 
        }


        #editor-preview-wrapper { background-color: #111; color: #ccc; }
        #editor-preview-wrapper iframe { width: 100%; height: 100%; border: none; background-color: #fff; }
        
        .markdown-preview h1, .markdown-preview h2, .markdown-preview h3 { color: #7fdbff; border-bottom: 1px solid #555; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 0.5em; line-height: 1.4; }
        .markdown-preview code { background-color: #222; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
        .markdown-preview pre { background-color: #222; padding: 10px; overflow-x: auto; border-radius: 3px;} 
        .markdown-preview pre > code { display: block; padding: 0; }
        .markdown-preview ul, .markdown-preview ol { margin-left: 20px; margin-bottom: 0.5em;}
        .markdown-preview blockquote { border-left: 3px solid #555; padding-left: 10px; margin-left: 0; color: #aaa; }
        .markdown-preview a { color: #39cccc; text-decoration: underline; }

        .markdown-preview.word-wrap-enabled pre {
            white-space: pre-wrap;
            word-break: break-all; 
        }
        
        #editor-status-bar {
            padding: 3px 10px;
            font-size: 0.85em;
            color: #888;
            border-top: 1px solid #333;
            background-color: #111; 
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
        }
        #editor-status-bar span { margin-right: 15px; }


        #editor-instructions-footer { padding: 8px 0 2px 0; font-size: 0.9em; text-align: center; color: #aaa; flex-shrink: 0; border-top: 1px solid #333; margin-top: 5px; }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line-container">
                <div class="prompt-container">
                    <span id="prompt-user" class="prompt-user"></span>
                    <span class="prompt-separator">@</span>
                    <span id="prompt-host" class="prompt-host">OopisOs</span>
                    <span class="prompt-separator">:</span>
                    <span id="prompt-path" class="prompt-path"></span>
                    <span class="prompt-char">&gt;</span>
                </div>
                <div id="editable-input-container">
                    <div id="editable-input" contenteditable="true" spellcheck="false" autocapitalize="none" autocorrect="off"></div>
                </div>
            </div>
            </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const Config = (() => {
            'use strict';
            return {
                DATABASE: {
                    NAME: "OopisOsDB",
                    VERSION: 1,
                    FS_STORE_NAME: "FileSystemsStore"
                },
                OS: {
                    NAME: "OopisOs",
                    VERSION: "1.0.5.3", // Updated version
                    DEFAULT_HOST_NAME: "OopisOs"
                },
                USER: {
                    DEFAULT_NAME: "Guest",
                    RESERVED_USERNAMES: ["guest", "root", "admin", "system"], 
                    MIN_USERNAME_LENGTH: 3,
                    MAX_USERNAME_LENGTH: 20
                },
                TERMINAL: {
                    MAX_HISTORY_SIZE: 50,
                    PROMPT_CHAR: ">",
                    PROMPT_SEPARATOR: ":",
                    PROMPT_AT: "@"
                },
                STORAGE_KEYS: {
                    USER_CREDENTIALS: 'oopisOsUserCredentials',
                    USER_TERMINAL_STATE_PREFIX: 'oopisOsUserTerminalState_',
                    MANUAL_TERMINAL_STATE_PREFIX: 'oopisOsManualUserTerminalState_',
                    EDITOR_WORD_WRAP_ENABLED: 'oopisOsEditorWordWrapEnabled'
                },
                CSS_CLASSES: { 
                    ERROR_MSG: 'error-message',
                    SUCCESS_MSG: 'success-message',
                    CONSOLE_LOG_MSG: 'console-log-message',
                    WARNING_MSG: 'warning-message',
                    EDITOR_MSG: 'editor-message',
                    DIR_ITEM: 'directory-item', 
                    FILE_ITEM: 'file-item', 
                    OUTPUT_LINE: 'output-line'
                },
                EDITOR: {
                    DEBOUNCE_DELAY_MS: 250,
                    TAB_REPLACEMENT: "\t", 
                    CTRL_S_ACTION: 'save_exit',
                    CTRL_O_ACTION: 'exit_no_save',
                    CTRL_P_ACTION: 'toggle_preview',
                    DEFAULT_MODE: 'text',
                    MODES: {
                        TEXT: 'text',
                        MARKDOWN: 'markdown',
                        HTML: 'html'
                    },
                    EXTENSIONS_MAP: {
                        'md': 'markdown',
                        'html': 'html',
                        'htm': 'html',
                        'sh': 'text' 
                    },
                    VIEW_MODES: {
                        SPLIT: 'split',
                        EDIT_ONLY: 'edit',
                        PREVIEW_ONLY: 'preview'
                    },
                    WORD_WRAP_DEFAULT_ENABLED: true 
                },
                FILESYSTEM: {
                    ROOT_PATH: '/',
                    CURRENT_DIR_SYMBOL: '.',
                    PARENT_DIR_SYMBOL: '..',
                    DEFAULT_DIRECTORY_TYPE: 'directory',
                    DEFAULT_FILE_TYPE: 'file',
                    PATH_SEPARATOR: '/'
                },
                MESSAGES: { 
                    CONFIRMATION_PROMPT: "Type 'YES' (all caps) to confirm, or any other input to cancel.",
                    OPERATION_CANCELLED: "Operation cancelled.",
                    ALREADY_LOGGED_IN_AS_PREFIX: "Already logged in as '",
                    ALREADY_LOGGED_IN_AS_SUFFIX: "'.",
                    NO_ACTION_TAKEN: "No action taken.",
                    ALREADY_IN_DIRECTORY_PREFIX: "Already in '",
                    ALREADY_IN_DIRECTORY_SUFFIX: "'.",
                    DIRECTORY_EMPTY: "Directory is empty.",
                    TIMESTAMP_UPDATED_PREFIX: "Timestamp of '",
                    TIMESTAMP_UPDATED_SUFFIX: "' updated.",
                    FILE_CREATED_SUFFIX: "' created.",
                    // Config.MESSAGES.DIRECTORY_CREATED_SUFFIX removed
                    ITEM_REMOVED_SUFFIX: "' removed.",
                    FORCIBLY_REMOVED_PREFIX: "Forcibly removed '",
                    FORCIBLY_REMOVED_SUFFIX: "'.",
                    REMOVAL_CANCELLED_PREFIX: "Removal of '",
                    REMOVAL_CANCELLED_SUFFIX: "' cancelled.",
                    MOVED_PREFIX: "Moved '",
                    MOVED_TO: "' to '",
                    MOVED_SUFFIX: "'.",
                    COPIED_PREFIX: "Copied '",
                    COPIED_TO: "' to '",
                    COPIED_SUFFIX: "'.",
                    SESSION_SAVED_FOR_PREFIX: "Session manually saved for ",
                    SESSION_LOADED_MSG: "Session loaded from manual save.",
                    LOAD_STATE_CANCELLED: "Load state cancelled.",
                    NO_MANUAL_SAVE_FOUND_PREFIX: "No manually saved state found for ",
                    WELCOME_PREFIX: "Welcome, ",
                    WELCOME_SUFFIX: "! Type 'help' for commands.",
                    EXPORTING_PREFIX: "Exporting '",
                    EXPORTING_SUFFIX: "'... Check your browser downloads.",
                    BACKUP_CREATING_PREFIX: "Creating backup '",
                    BACKUP_CREATING_SUFFIX: "'... Check your browser downloads.",
                    RESTORE_CANCELLED_NO_FILE: "Restore cancelled: No file selected.",
                    RESTORE_SUCCESS_PREFIX: "Session for user '",
                    RESTORE_SUCCESS_MIDDLE: "' successfully restored from '",
                    RESTORE_SUCCESS_SUFFIX: "'.",
                    UPLOAD_NO_FILE: "Upload cancelled: No file selected.",
                    UPLOAD_INVALID_TYPE_PREFIX: "Error: Invalid file type '",
                    UPLOAD_INVALID_TYPE_SUFFIX: "'. Only .txt, .md, .html, .sh files are allowed.", 
                    UPLOAD_SUCCESS_PREFIX: "File '",
                    UPLOAD_SUCCESS_MIDDLE: "' uploaded successfully to '",
                    UPLOAD_SUCCESS_SUFFIX: "'.",
                    UPLOAD_READ_ERROR_PREFIX: "Error reading file '",
                    UPLOAD_READ_ERROR_SUFFIX: "'.",
                    NO_COMMANDS_IN_HISTORY: "No commands in history.",
                    EDITOR_DISCARD_CONFIRM: "You have unsaved changes. Discard them and exit?",
                    BACKGROUND_PROCESS_STARTED_PREFIX: "[", 
                    BACKGROUND_PROCESS_STARTED_SUFFIX: "] Backgrounded.", 
                    BACKGROUND_PROCESS_OUTPUT_SUPPRESSED: "[Output suppressed for background process]", 
                    PIPELINE_ERROR_PREFIX: "Pipeline error in command: " 
                },
                INTERNAL_ERRORS: { 
                    DB_NOT_INITIALIZED_FS_SAVE: "DB not initialized for FS save",
                    DB_NOT_INITIALIZED_FS_LOAD: "DB not initialized for FS load",
                    DB_NOT_INITIALIZED_FS_DELETE: "DB not initialized for FS delete",
                    DB_NOT_INITIALIZED_FS_CLEAR: "DB not initialized for clearing all FS",
                    CORRUPTED_FS_DATA_PRE_SAVE: "Corrupted FS data before saving.",
                    // Config.INTERNAL_ERRORS.REDIRECTION_FILE_NOT_SPECIFIED removed
                    SOURCE_NOT_FOUND_IN_PARENT_PREFIX: "internal error: source '", 
                    SOURCE_NOT_FOUND_IN_PARENT_MIDDLE: "' not found in parent '",
                    SOURCE_NOT_FOUND_IN_PARENT_SUFFIX: "'"
                }
            };
        })();

        // --- DOM ELEMENTS CACHE ---
        let DOM = {}; 

        // --- UTILITY FUNCTIONS ---
        const Utils = (() => {
            'use strict';
            function formatConsoleArgs(args) {
                return Array.from(args)
                    .map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg))
                    .join(' ');
            }
            function deepCopyNode(node) { 
                return node ? JSON.parse(JSON.stringify(node)) : null;
            }
            function formatBytes(bytes, decimals = 2) { 
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            function getFileExtension(filePath) { 
                if (!filePath || typeof filePath !== 'string') return '';
                const name = filePath.substring(filePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                const lastDot = name.lastIndexOf('.');
                if (lastDot === -1 || lastDot === 0 || lastDot === name.length - 1) { 
                    return '';
                }
                return name.substring(lastDot + 1).toLowerCase();
            }

            function createElement(tag, attributes = {}, children = []) { 
                const element = document.createElement(tag);
                for (const key in attributes) {
                    if (attributes.hasOwnProperty(key)) {
                        if (key === 'textContent') {
                            element.textContent = attributes[key];
                        } else if (key === 'innerHTML') {
                            element.innerHTML = attributes[key];
                        } else if (key === 'classList' && Array.isArray(attributes[key])) {
                            attributes[key].forEach(cls => element.classList.add(cls));
                        } else if (key === 'style' && typeof attributes[key] === 'object') {
                            for (const styleProp in attributes[key]) {
                                if (attributes[key].hasOwnProperty(styleProp)) {
                                    element.style[styleProp] = attributes[key][styleProp];
                                }
                            }
                        } else if (key === 'eventListeners' && typeof attributes[key] === 'object') {
                            for (const eventType in attributes[key]) {
                                if (attributes[key].hasOwnProperty(eventType) && typeof attributes[key][eventType] === 'function') {
                                    element.addEventListener(eventType, attributes[key][eventType]);
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, attributes[key]);
                        }
                    }
                }
                children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else if (child instanceof HTMLElement) {
                        element.appendChild(child);
                    }
                });
                return element;
            }

            function validateArguments(argsArray, config = {}) { 
                const argCount = argsArray.length;

                if (typeof config.exact === 'number') {
                    if (argCount !== config.exact) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected exactly ${config.exact} argument${config.exact === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                } else {
                    if (typeof config.min === 'number' && argCount < config.min) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected at least ${config.min} argument${config.min === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                    if (typeof config.max === 'number' && argCount > config.max) {
                        return { 
                            isValid: false, 
                            errorDetail: `expected at most ${config.max} argument${config.max === 1 ? '' : 's'}, but got ${argCount}` 
                        };
                    }
                }
                return { isValid: true };
            }
            
            function parseNumericArg(argString, options = {}) { 
                const { allowFloat = false, allowNegative = false, min, max } = options;
                const num = allowFloat ? parseFloat(argString) : parseInt(argString, 10);

                if (isNaN(num)) {
                    return { value: null, error: "is not a valid number" };
                }
                if (!allowNegative && num < 0) {
                    return { value: null, error: "must be a non-negative number" };
                }
                if (min !== undefined && num < min) {
                    return { value: null, error: `must be at least ${min}` };
                }
                if (max !== undefined && num > max) {
                    return { value: null, error: `must be at most ${max}` };
                }
                return { value: num, error: null };
            }

            function validateUsernameFormat(username) { 
                if (!username || typeof username !== 'string' || username.trim() === "") {
                    return { isValid: false, error: "Username cannot be empty." };
                }
                if (username.includes(" ")) {
                    return { isValid: false, error: "Username cannot contain spaces." };
                }
                if (Config.USER.RESERVED_USERNAMES.includes(username.toLowerCase())) {
                    return { isValid: false, error: `Cannot use '${username}'. This username is reserved.` };
                }
                if (username.length < Config.USER.MIN_USERNAME_LENGTH) {
                    return { isValid: false, error: `Username must be at least ${Config.USER.MIN_USERNAME_LENGTH} characters long.` };
                }
                if (username.length > Config.USER.MAX_USERNAME_LENGTH) {
                    return { isValid: false, error: `Username cannot exceed ${Config.USER.MAX_USERNAME_LENGTH} characters.` };
                }
                return { isValid: true, error: null };
            }

            function parseFlags(argsArray, flagDefinitions) { 
                const flags = {};
                const remainingArgs = [];
                const definedFlags = new Set();
                const flagsWithValues = {}; 

                flagDefinitions.forEach(def => {
                    flags[def.name] = def.takesValue ? null : false; 
                    if(def.short) definedFlags.add(def.short);
                    if(def.long) definedFlags.add(def.long);
                    if(def.takesValue) {
                        if(def.short) flagsWithValues[def.short] = def.name;
                        if(def.long) flagsWithValues[def.long] = def.name;
                    }
                });

                for (let i = 0; i < argsArray.length; i++) {
                    const arg = argsArray[i];
                    let isFlag = false;
                    for (const def of flagDefinitions) {
                        if (arg === def.short || arg === def.long) {
                            if (def.takesValue) {
                                if (i + 1 < argsArray.length) {
                                    flags[def.name] = argsArray[i+1];
                                    i++; 
                                } else {
                                    console.warn(`Flag ${arg} expects a value, but none was provided.`);
                                    flags[def.name] = null; 
                                }
                            } else {
                                flags[def.name] = true;
                            }
                            isFlag = true;
                            break;
                        }
                    }
                    if (!isFlag) {
                        remainingArgs.push(arg);
                    }
                }
                return { flags, remainingArgs };
            }


            return {
                formatConsoleArgs,
                deepCopyNode,
                formatBytes,
                getFileExtension,
                createElement,
                validateArguments,
                parseNumericArg,
                validateUsernameFormat,
                parseFlags 
            };
        })();

        // --- OUTPUT MANAGER ---
        const OutputManager = (() => {
            'use strict';
            let isEditorActive = false;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;

            function setEditorActive(status) {
                isEditorActive = status;
            }

            async function appendToOutput(text, options = {}) { 
                if (isEditorActive && options.typeClass !== Config.CSS_CLASSES.EDITOR_MSG && !options.isCompletionSuggestion) { 
                    return; 
                }
                if (!DOM.outputDiv) { 
                    originalConsoleError("OutputManager.appendToOutput: DOM.outputDiv is not defined. Message:", text);
                    return;
                }

                const { typeClass = null, isBackground = false } = options; 
                if (isBackground && DOM.inputLineContainerDiv.style.visibility !== 'hidden') {
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                    const currentInputVal = TerminalUI.getCurrentInputValue();
                    DOM.outputDiv.innerHTML += `<div class="${Config.CSS_CLASSES.OUTPUT_LINE}">${promptText}${currentInputVal}</div>`;
                }


                const lines = String(text).split('\n');
                const fragment = document.createDocumentFragment(); 

                for (const line of lines) {
                    const lineAttributes = {
                        classList: [Config.CSS_CLASSES.OUTPUT_LINE],
                        textContent: line
                    };
                    if (typeClass) {
                        lineAttributes.classList.push(typeClass);
                    } else if (options.isError) { 
                        lineAttributes.classList.push(Config.CSS_CLASSES.ERROR_MSG);
                    }
                    const newLineElement = Utils.createElement('div', lineAttributes);
                    fragment.appendChild(newLineElement);
                }
                DOM.outputDiv.appendChild(fragment); 
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }
            
            function clearOutput() { 
                if (!isEditorActive && DOM.outputDiv) {
                    DOM.outputDiv.innerHTML = '';
                }
            }

            function _consoleLogOverride(...args) { 
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') { 
                    appendToOutput(`LOG: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                originalConsoleLog.apply(console, args);
            }
            function _consoleWarnOverride(...args) { 
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') {
                    appendToOutput(`WARN: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                }
                originalConsoleWarn.apply(console, args);
            }
            function _consoleErrorOverride(...args) { 
                if (DOM.outputDiv && typeof Utils !== 'undefined' && typeof Utils.formatConsoleArgs === 'function') {
                    appendToOutput(`ERROR: ${Utils.formatConsoleArgs(args)}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                }
                originalConsoleError.apply(console, args);
            }

            function initializeConsoleOverrides() { 
                if (typeof Utils === 'undefined' || typeof Utils.formatConsoleArgs !== 'function') {
                    originalConsoleError("OutputManager: Cannot initialize console overrides, Utils or Utils.formatConsoleArgs is not defined.");
                    return; 
                }
                console.log = _consoleLogOverride;
                console.warn = _consoleWarnOverride;
                console.error = _consoleErrorOverride;
            }

            return {
                setEditorActive,
                appendToOutput,
                clearOutput,
                initializeConsoleOverrides 
            };
        })();

        // --- LOCAL STORAGE MANAGER ---
        const StorageManager = (() => { 
            'use strict';
            function loadItem(key, itemName, defaultValue = null) { 
                try {
                    const storedValue = localStorage.getItem(key);
                    if (storedValue !== null) { 
                        if (key === Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED) { 
                            return storedValue === 'true';
                        }
                        try {
                            return JSON.parse(storedValue);
                        } catch (e) {
                            return storedValue; 
                        }
                    }
                } catch (e) {
                     if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') { 
                        OutputManager.appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                     } else {
                        console.warn(`StorageManager: OutputManager not available. ${itemName} for '${key}' corrupted.`);
                     }
                }
                return defaultValue;
            }
            function saveItem(key, data, itemName) { 
                try {
                    const valueToStore = (typeof data === 'object' && data !== null) ? JSON.stringify(data) : String(data);
                    localStorage.setItem(key, valueToStore);
                    return true;
                } catch (e) {
                    if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                        OutputManager.appendToOutput(`Error saving ${itemName} for '${key}'. Data may be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else {
                        console.error(`StorageManager: OutputManager not available. Error saving ${itemName} for '${key}'.`);
                    }
                }
                return false;
            }
            function removeItem(key) { localStorage.removeItem(key); }
            function getAllLocalStorageKeys() { 
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    keys.push(localStorage.key(i));
                }
                return keys;
            }
            return { loadItem, saveItem, removeItem, getAllLocalStorageKeys }; 
        })();
        
        // --- INDEXEDDB MANAGER ---
        const IndexedDBManager = (() => { 
            'use strict';
            let dbInstance = null;
            let hasLoggedNormalInitialization = false;

            function init() { 
                return new Promise((resolve, reject) => {
                    if (dbInstance) {
                        resolve(dbInstance);
                        return;
                    }
                    const request = indexedDB.open(Config.DATABASE.NAME, Config.DATABASE.VERSION);
                    request.onupgradeneeded = (event) => {
                        const tempDb = event.target.result;
                        if (!tempDb.objectStoreNames.contains(Config.DATABASE.FS_STORE_NAME)) {
                            tempDb.createObjectStore(Config.DATABASE.FS_STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        dbInstance = event.target.result;
                        if (!hasLoggedNormalInitialization) {
                            if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') { 
                                 OutputManager.appendToOutput("FileSystem DB initialized.", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                            } else {
                                console.log("FileSystem DB initialized (OutputManager not ready for terminal log).");
                            }
                            hasLoggedNormalInitialization = true;
                        }
                        resolve(dbInstance);
                    };
                    request.onerror = (event) => {
                        const errorMsg = "Error: OopisOs could not access its file system storage. This might be due to browser settings (e.g., private Browse mode, disabled storage, or full storage). Please check your browser settings and try again. Some features may be unavailable.";
                        if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                            OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        } else {
                            console.error(errorMsg); 
                        }
                        console.error("Database error details: ", event.target.error); 
                        reject(event.target.error);
                    };
                });
            }
            function getDbInstance() { 
                if (!dbInstance) {
                    const errorMsg = "Error: OopisOs file system storage is not available. Please ensure browser storage is enabled and the page is reloaded.";
                     if (typeof OutputManager !== 'undefined' && typeof OutputManager.appendToOutput === 'function') {
                        OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    } else {
                        console.error(errorMsg); 
                    }
                    throw new Error("IndexedDB not initialized.");
                }
                return dbInstance;
            }
            return { init, getDbInstance };
        })();

        // --- FILE SYSTEM MANAGER ---
        const FileSystemManager = (() => { 
            'use strict';
            let fsData = {}; 
            let currentPath = Config.FILESYSTEM.ROOT_PATH;

            function _getFileSystemKey(user) { return `fs_${user}`; }
            
            async function initialize(user) {
                fsData = {
                    [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} }
                };
            }
            async function save(user) {
                const db = IndexedDBManager.getDbInstance(); 
                if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for saving. Changes may not be persisted.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_SAVE);
                }
                return new Promise((resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const dataToSave = Utils.deepCopyNode(fsData); 
                        if (!dataToSave || typeof dataToSave !== 'object' || !dataToSave[Config.FILESYSTEM.ROOT_PATH] || dataToSave[Config.FILESYSTEM.ROOT_PATH].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            console.error("Attempted to save invalid fsData structure for user:", user, dataToSave);
                            OutputManager.appendToOutput(`Error: Corrupted file system data for ${user} before saving. Save aborted.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            return reject(new Error(Config.INTERNAL_ERRORS.CORRUPTED_FS_DATA_PRE_SAVE));
                        }
                        const request = store.put({ id: _getFileSystemKey(user), data: dataToSave });
                        request.onsuccess = () => resolve(true);
                        request.onerror = (event) => {
                            console.error(`Error saving FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}'. This could be due to a storage issue. Please try again later or consider backing up your data if possible.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            reject(event.target.error);
                        };
                    } catch (e) { 
                        console.error(`Error initiating save transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Error: OopisOs failed to save your file system data for user '${user}' (transaction error). Please try again later.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(e);
                    }
                });
            }
            async function load(user) {
                const db = IndexedDBManager.getDbInstance(); 
                 if (!db) { 
                    OutputManager.appendToOutput("Error: File system storage not available for loading. Using temporary session.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    await initialize(user); 
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_LOAD);
                }
                return new Promise(async (resolve, reject) => {
                    try {
                        const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readonly');
                        const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                        const request = store.get(_getFileSystemKey(user));
                        request.onsuccess = async (event) => {
                            const result = event.target.result;
                            if (result && result.data && result.data[Config.FILESYSTEM.ROOT_PATH]?.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                fsData = result.data;
                            } else {
                                const message = result ? `Warning: File system for '${user}' appears invalid or corrupted. Reinitializing.` : `No file system found for '${user}'. Initializing new one.`;
                                const messageType = result ? Config.CSS_CLASSES.WARNING_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG;
                                OutputManager.appendToOutput(message, { typeClass: messageType });
                                await initialize(user);
                                await save(user); 
                            }
                            resolve();
                        };
                        request.onerror = async (event) => {
                            console.error(`Error loading FS for ${user}:`, event.target.error);
                            OutputManager.appendToOutput(`Warning: Could not load file system for '${user}'. Initializing a new one. This might be due to a storage issue.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            await initialize(user);
                            await save(user); 
                            reject(event.target.error);
                        };
                    } catch (e) {
                        console.error(`Error initiating load transaction for ${user}:`, e);
                        OutputManager.appendToOutput(`Warning: Could not load file system for '${user}' (transaction error). Initializing a new one.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                        await initialize(user);
                        await save(user);
                        reject(e);
                    }
                });
            }
            async function deleteUserFS(user) { 
                const db = IndexedDBManager.getDbInstance();
                if (!db) return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_DELETE);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.delete(_getFileSystemKey(user));
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error deleting FS for ${user}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            async function clearAllFS() { 
                const db = IndexedDBManager.getDbInstance();
                if (!db) {
                     OutputManager.appendToOutput("Error: File system storage not available for clearing all data.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    return Promise.reject(Config.INTERNAL_ERRORS.DB_NOT_INITIALIZED_FS_CLEAR);
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([Config.DATABASE.FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(Config.DATABASE.FS_STORE_NAME);
                    const request = store.clear(); 
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error("Error clearing FileSystemsStore:", event.target.error);
                        OutputManager.appendToOutput("Error: OopisOs could not clear all user file systems. Your data might still be present. Please try the operation again.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        reject(event.target.error);
                    };
                });
            }

            function getCurrentPath() { return currentPath; }
            function setCurrentPath(path) { currentPath = path; }
            function getFsData() { return fsData; }
            function setFsData(newData) { fsData = newData; }
            
            function getAbsolutePath(targetPath, basePath) {
                if (!targetPath) targetPath = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                let effectiveBasePath = basePath; 
                if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR)) {
                    effectiveBasePath = Config.FILESYSTEM.ROOT_PATH;
                }
                const baseSegments = effectiveBasePath === Config.FILESYSTEM.ROOT_PATH ? [] : effectiveBasePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s && s !== Config.FILESYSTEM.CURRENT_DIR_SYMBOL);
                let resolvedSegments = [...baseSegments];
                const targetSegments = targetPath.split(Config.FILESYSTEM.PATH_SEPARATOR);
                for (const segment of targetSegments) {
                    if (segment === '' || segment === Config.FILESYSTEM.CURRENT_DIR_SYMBOL) {
                        if (targetPath.startsWith(Config.FILESYSTEM.PATH_SEPARATOR) && resolvedSegments.length === 0 && segment === '') {}
                        continue;
                    }
                    if (segment === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                        if (resolvedSegments.length > 0) resolvedSegments.pop(); 
                    } else {
                        resolvedSegments.push(segment); 
                    }
                }
                if (resolvedSegments.length === 0) return Config.FILESYSTEM.ROOT_PATH;
                return Config.FILESYSTEM.PATH_SEPARATOR + resolvedSegments.join(Config.FILESYSTEM.PATH_SEPARATOR);
            }
            function getNodeByPath(path) {
                const absolutePath = getAbsolutePath(path, currentPath);
                if (absolutePath === Config.FILESYSTEM.ROOT_PATH) return fsData[Config.FILESYSTEM.ROOT_PATH];
                const segments = absolutePath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                for (const segment of segments) {
                    if (currentNode && currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && currentNode.children && currentNode.children[segment]) {
                        currentNode = currentNode.children[segment];
                    } else { return null; }
                }
                return currentNode;
            }
            function createParentDirectoriesIfNeeded(fullPath) {
                if (fullPath === Config.FILESYSTEM.ROOT_PATH) return { parentNode: null, error: "Cannot create directory structure for root." };

                const lastSlashIndex = fullPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                const parentPath = (lastSlashIndex === 0) ? Config.FILESYSTEM.ROOT_PATH : fullPath.substring(0, lastSlashIndex);
                const newDirName = fullPath.substring(lastSlashIndex + 1);

                if (!newDirName || newDirName === Config.FILESYSTEM.CURRENT_DIR_SYMBOL || newDirName === Config.FILESYSTEM.PARENT_DIR_SYMBOL) {
                    return { parentNode: null, error: `Invalid name component '${newDirName}' in path '${fullPath}'` };
                }

                if (parentPath === Config.FILESYSTEM.ROOT_PATH) {
                    return { parentNode: fsData[Config.FILESYSTEM.ROOT_PATH], error: null };
                }
                
                const parentPathSegments = parentPath.substring(1).split(Config.FILESYSTEM.PATH_SEPARATOR).filter(s => s);
                let currentDirNode = fsData[Config.FILESYSTEM.ROOT_PATH];
                let currentBuiltParentPath = "";

                for (const segment of parentPathSegments) {
                    currentBuiltParentPath += Config.FILESYSTEM.PATH_SEPARATOR + segment;
                    if (!currentDirNode.children[segment]) {
                        currentDirNode.children[segment] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                    } else if (currentDirNode.children[segment].type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                    }
                    currentDirNode = currentDirNode.children[segment];
                }
                return { parentNode: currentDirNode, error: null };
            }
            function calculateNodeSize(node) { 
                if (!node) return 0;
                if (node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) return (node.content || "").length; 
                if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                    let totalSize = 0;
                    for (const childName in node.children) totalSize += calculateNodeSize(node.children[childName]); 
                    return totalSize;
                }
                return 0; 
            }
            function validatePath(commandName, pathArg, options = {}) { 
                const { expectedType = 'any', allowMissing = false, disallowRoot = false, defaultToCurrentIfEmpty = true } = options;
                let effectivePathArg = pathArg;
                if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) effectivePathArg = Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                if (effectivePathArg === undefined || effectivePathArg === null) return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
                const resolvedPath = getAbsolutePath(String(effectivePathArg), getCurrentPath());
                const node = getNodeByPath(resolvedPath);
                if (disallowRoot && resolvedPath === Config.FILESYSTEM.ROOT_PATH) return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '${Config.FILESYSTEM.ROOT_PATH}'` };
                if (node) { 
                    if (expectedType === Config.FILESYSTEM.DEFAULT_FILE_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_FILE_TYPE) return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                    if (expectedType === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                    return { node: node, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                } else { 
                    if (allowMissing) return { node: null, resolvedPath: resolvedPath, error: null, optionsUsed: options };
                    else return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory`, optionsUsed: options };
                }
            }

            return {
                initialize, save, load, deleteUserFS, clearAllFS, getCurrentPath, setCurrentPath,
                getFsData, setFsData, getAbsolutePath, getNodeByPath, createParentDirectoriesIfNeeded,
                calculateNodeSize, validatePath
            };
        })();

        // --- COMMAND HISTORY MANAGER ---
        const HistoryManager = (() => { 
            'use strict';
            let commandHistory = [];
            let historyIndex = 0; 
            function add(command) {
                const trimmedCommand = command.trim();
                if (trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                    commandHistory.push(trimmedCommand);
                    if (commandHistory.length > Config.TERMINAL.MAX_HISTORY_SIZE) {
                        commandHistory.shift(); 
                    }
                }
                historyIndex = commandHistory.length; 
            }
            function getPrevious() {
                if (commandHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    return commandHistory[historyIndex];
                }
                return null; 
            }
            function getNext() {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    return commandHistory[historyIndex];
                } else if (historyIndex >= commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    return ""; 
                }
                return null; 
            }
            function resetIndex() { historyIndex = commandHistory.length; }
            function getFullHistory() { return [...commandHistory]; }
            function clearHistory() { commandHistory = []; historyIndex = 0;}
            function setHistory(newHistory) { commandHistory = Array.isArray(newHistory) ? [...newHistory] : []; historyIndex = commandHistory.length; }
            return { add, getPrevious, getNext, resetIndex, getFullHistory, clearHistory, setHistory };
        })();

        // --- CONFIRMATION MANAGER ---
        const ConfirmationManager = (() => { 
            'use strict';
            let awaitingConfirmation = false;
            let confirmationContext = null; 
            function request(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
                awaitingConfirmation = true;
                confirmationContext = {
                    promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                    data: dataForAction,
                    onConfirm: onConfirmCallback,
                    onCancel: onCancelCallback
                };
                confirmationContext.promptMessageLines.forEach(line => OutputManager.appendToOutput(line, { typeClass: Config.CSS_CLASSES.WARNING_MSG }));
                OutputManager.appendToOutput(Config.MESSAGES.CONFIRMATION_PROMPT, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                TerminalUI.clearInput(); 
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput();
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
            }
            async function handleConfirmation(input) {
                if (!awaitingConfirmation || !confirmationContext) return false; 
                let processed = false;
                if (input.trim() === 'YES' && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                    processed = true;
                } else {
                    if (typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        OutputManager.appendToOutput(Config.MESSAGES.OPERATION_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    }
                    processed = true;
                }
                awaitingConfirmation = false;
                confirmationContext = null;
                return processed; 
            }
            function isAwaiting() { return awaitingConfirmation; }
            return { request, handleConfirmation, isAwaiting };
        })();

        // --- EDITOR MANAGER ---
        const EditorManager = (() => { 
            'use strict';
            let isActiveState = false;
            let currentFilePath = null;
            let currentFileMode = Config.EDITOR.DEFAULT_MODE; 
            let currentViewMode = Config.EDITOR.VIEW_MODES.SPLIT; 
            let isWordWrapActive = Config.EDITOR.WORD_WRAP_DEFAULT_ENABLED; 
            let debounceTimer = null; 
            
            let editorContainerDiv = null, editorControlsDiv = null, editorFilenameDisplay = null;
            let viewToggleButton = null, exportPreviewButton = null, wordWrapToggleButton = null; 
            let editorMainAreaDiv = null, editorLineGutter = null, editorTextareaWrapper = null, editorTextareaElement = null;
            let editorPreviewWrapper = null, editorPreviewPaneDiv = null;
            let editorStatusBar = null, statusBarLineCount = null, statusBarWordCount = null, statusBarCharCount = null, statusBarCursorPos = null;
            let editorInstructionsFooter = null;

            let originalContent = ""; 
            let isDirty = false;      

            function _determineMode(filePath) { const extension = Utils.getFileExtension(filePath); return Config.EDITOR.EXTENSIONS_MAP[extension] || Config.EDITOR.DEFAULT_MODE; }
            
            function _updateFilenameDisplay() {
                if (editorFilenameDisplay) {
                    editorFilenameDisplay.textContent = `File: ${currentFilePath || "Untitled"}${isDirty ? "*" : ""}`;
                }
            }

            function _updateStatusBar() {
                if (!editorTextareaElement || !editorStatusBar) return;

                const text = editorTextareaElement.value;
                const lines = text.split('\n');
                const lineCount = lines.length;
                const charCount = text.length;
                const wordCount = text.trim() === '' ? 0 : text.trim().split(/\s+/).filter(Boolean).length;

                const cursorPos = editorTextareaElement.selectionStart;
                let currentLineNum = 0; 
                let currentColNum = 0; 
                let charCounter = 0;
                for (let i = 0; i < lines.length; i++) {
                    const lineLengthWithNewline = lines[i].length + 1; 
                    if (cursorPos >= charCounter && cursorPos < charCounter + lineLengthWithNewline) {
                        currentLineNum = i;
                        currentColNum = cursorPos - charCounter;
                        break;
                    }
                    charCounter += lineLengthWithNewline;
                }
                if (cursorPos === text.length && !text.endsWith('\n')) {
                     currentLineNum = lines.length -1;
                     currentColNum = lines[lines.length-1].length;
                } else if (cursorPos === text.length && text.endsWith('\n')){
                     currentLineNum = lines.length -1; 
                     currentColNum = 0; 
                }


                if(statusBarLineCount) statusBarLineCount.textContent = `Lines: ${lineCount}`;
                if(statusBarWordCount) statusBarWordCount.textContent = `Words: ${wordCount}`;
                if(statusBarCharCount) statusBarCharCount.textContent = `Chars: ${charCount}`;
                if(statusBarCursorPos) statusBarCursorPos.textContent = `Ln: ${currentLineNum + 1}, Col: ${currentColNum + 1}`;
            }

            function _updateLineNumbers() {
                if (!editorTextareaElement || !editorLineGutter) return;
                const lines = editorTextareaElement.value.split('\n').length;
                const numbersArray = [];
                for(let i=1; i <= lines; i++) {
                    numbersArray.push(i);
                }
                editorLineGutter.textContent = numbersArray.join('\n');
                editorLineGutter.scrollTop = editorTextareaElement.scrollTop;
            }

            function _loadWordWrapSetting() {
                const savedSetting = StorageManager.loadItem(Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED, "Editor word wrap setting");
                isWordWrapActive = (savedSetting !== null) ? savedSetting : Config.EDITOR.WORD_WRAP_DEFAULT_ENABLED;
            }

            function _saveWordWrapSetting() {
                StorageManager.saveItem(Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED, isWordWrapActive, "Editor word wrap setting");
            }

            function _applyWordWrapToTextarea() {
                if (!editorTextareaElement) return;
                if (isWordWrapActive) {
                    editorTextareaElement.setAttribute('wrap', 'soft'); 
                    editorTextareaElement.classList.remove('no-wrap');
                } else {
                    editorTextareaElement.setAttribute('wrap', 'off');
                    editorTextareaElement.classList.add('no-wrap');
                }
            }

            function _applyWordWrapToMarkdownPreview() {
                if (!editorPreviewPaneDiv || currentFileMode !== Config.EDITOR.MODES.MARKDOWN) return;
                if (isWordWrapActive) {
                    editorPreviewPaneDiv.classList.add('word-wrap-enabled');
                } else {
                    editorPreviewPaneDiv.classList.remove('word-wrap-enabled');
                }
            }
            
            function _applyWordWrapToHtmlPreview() {
                if (currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview(); 
                }
            }

            function _updateWordWrapToggleButtonText() {
                if (wordWrapToggleButton) {
                    wordWrapToggleButton.textContent = isWordWrapActive ? "Wrap: On" : "Wrap: Off";
                }
            }

            function _toggleWordWrap() {
                isWordWrapActive = !isWordWrapActive;
                _saveWordWrapSetting();
                _applyWordWrapToTextarea();
                _applyWordWrapToMarkdownPreview();
                _applyWordWrapToHtmlPreview(); 
                _updateWordWrapToggleButtonText();
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") editorTextareaElement.focus();
            }


            function _updatePreview() {
                if (!editorTextareaElement || !editorPreviewPaneDiv) return;
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                const content = editorTextareaElement.value;
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                        if (typeof marked !== 'undefined') editorPreviewPaneDiv.innerHTML = marked.parse(content);
                        else editorPreviewPaneDiv.textContent = "Markdown preview library (marked.js) not loaded.";
                        _applyWordWrapToMarkdownPreview(); 
                    } else if (currentFileMode === Config.EDITOR.MODES.HTML) {
                        let iframe = editorPreviewPaneDiv.querySelector('iframe');
                        if (!iframe) { 
                            iframe = Utils.createElement('iframe'); 
                            editorPreviewPaneDiv.innerHTML = ''; 
                            editorPreviewPaneDiv.appendChild(iframe); 
                        }
                        let injectedStyles = "";
                        if (isWordWrapActive) {
                            injectedStyles = `<style> pre { white-space: pre-wrap !important; word-break: break-all !important; overflow-wrap: break-word !important; } </style>`;
                        }
                        iframe.srcdoc = `${injectedStyles}<style>${_getPreviewStylingCSS(true)}</style>${content}`; 
                    }
                }, Config.EDITOR.DEBOUNCE_DELAY_MS);
            }

            function _handleEditorInput() {
                const currentContent = editorTextareaElement.value;
                isDirty = (currentContent !== originalContent);
                _updateFilenameDisplay();
                _updateLineNumbers();
                _updateStatusBar();
                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                    _updatePreview();
                }
            }
            
            function _handleEditorScroll() {
                 if(editorLineGutter && editorTextareaElement) {
                    editorLineGutter.scrollTop = editorTextareaElement.scrollTop;
                 }
            }
            
            function _handleEditorSelectionChange() { 
                _updateStatusBar();
            }
            
            async function exportPreviewAsHtml() {
                if (!isActiveState) return;
                let contentToExport = "";
                let baseFilename = "preview";
                if (currentFilePath) {
                    baseFilename = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    const dotIndex = baseFilename.lastIndexOf('.');
                    if (dotIndex > 0) baseFilename = baseFilename.substring(0, dotIndex);
                }
                const downloadFilename = `${baseFilename}_preview.html`;

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN && editorPreviewPaneDiv) {
                    contentToExport = editorPreviewPaneDiv.innerHTML; 
                } else if (currentFileMode === Config.EDITOR.MODES.HTML && editorTextareaElement) {
                    contentToExport = editorTextareaElement.value; 
                } else if (editorTextareaElement){ 
                     contentToExport = `<pre>${editorTextareaElement.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
                }
                
                const styles = _getPreviewStylingCSS(currentFileMode === Config.EDITOR.MODES.HTML);
                let injectedWordWrapStyles = "";
                if (isWordWrapActive && currentFileMode === Config.EDITOR.MODES.HTML) { 
                     injectedWordWrapStyles = `pre { white-space: pre-wrap !important; word-break: break-all !important; overflow-wrap: break-word !important; }`;
                }


                const htmlDoc = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OopisOS Editor Preview - ${currentFilePath || 'Untitled'}</title>
    <style>
${styles}
${injectedWordWrapStyles} 
    </style>
</head>
<body>
    <div class="${currentFileMode === Config.EDITOR.MODES.MARKDOWN ? 'markdown-preview' : ''}">
${contentToExport}
    </div>
</body>
</html>`;
                try {
                    const blob = new Blob([htmlDoc], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = Utils.createElement('a', { href: url, download: downloadFilename });
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    OutputManager.appendToOutput(`Preview exported as '${downloadFilename}'`, { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                } catch (error) {
                    console.error("Error exporting preview:", error);
                    OutputManager.appendToOutput(`Error exporting preview: ${error.message}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                }
            }


            function _setupEditorLayout() {
                editorFilenameDisplay = Utils.createElement('span', { 
                    id: 'editor-filename-display', 
                    textContent: `File: ${currentFilePath || "Untitled"}${isDirty ? "*" : ""}` 
                });
                viewToggleButton = Utils.createElement('button', { 
                    id: 'editor-view-toggle', 
                    textContent: 'Toggle View', 
                    eventListeners: { click: _toggleViewMode } 
                });
                 exportPreviewButton = Utils.createElement('button', {
                    id: 'editor-export-preview',
                    textContent: 'Export HTML',
                    eventListeners: { click: exportPreviewAsHtml }
                });
                wordWrapToggleButton = Utils.createElement('button', { 
                    id: 'editor-word-wrap-toggle',
                    textContent: isWordWrapActive ? "Wrap: On" : "Wrap: Off",
                    eventListeners: { click: _toggleWordWrap }
                });

                const controlsRightGroup = Utils.createElement('div', {}, [wordWrapToggleButton, viewToggleButton, exportPreviewButton]); 
                editorControlsDiv = Utils.createElement('div', { id: 'editor-controls' }, [editorFilenameDisplay, controlsRightGroup]);


                editorLineGutter = Utils.createElement('div', { id: 'editor-line-gutter' });
                editorTextareaElement = Utils.createElement('textarea', { 
                    id: 'editor-textarea',
                    spellcheck: 'false', 
                    eventListeners: {
                        input: _handleEditorInput,
                        scroll: _handleEditorScroll,
                        click: _handleEditorSelectionChange, 
                        keyup: _handleEditorSelectionChange  
                    }
                });
                editorTextareaWrapper = Utils.createElement('div', { 
                    id: 'editor-textarea-wrapper', 
                    classList: ['editor-pane'] 
                }, [editorTextareaElement]);
                
                const mainAreaChildren = [editorLineGutter, editorTextareaWrapper];

                editorPreviewPaneDiv = Utils.createElement('div', { id: 'editor-preview-content' });
                editorPreviewWrapper = Utils.createElement('div', { 
                    id: 'editor-preview-wrapper', 
                    classList: ['editor-pane'] 
                }, [editorPreviewPaneDiv]);
                mainAreaChildren.push(editorPreviewWrapper);
                
                editorMainAreaDiv = Utils.createElement('div', { id: 'editor-main-area', style: { display: 'flex'} }, mainAreaChildren);
                _setViewModeUI(currentViewMode); 

                statusBarLineCount = Utils.createElement('span', { id: 'status-lines', textContent: 'Lines: 0'});
                statusBarWordCount = Utils.createElement('span', { id: 'status-words', textContent: 'Words: 0'});
                statusBarCharCount = Utils.createElement('span', { id: 'status-chars', textContent: 'Chars: 0'});
                statusBarCursorPos = Utils.createElement('span', { id: 'status-cursor', textContent: 'Ln: 1, Col: 1'});
                const statusBarLeft = Utils.createElement('div', {}, [statusBarCursorPos, statusBarLineCount]);
                const statusBarRight = Utils.createElement('div', {}, [statusBarWordCount, statusBarCharCount]);

                editorStatusBar = Utils.createElement('div', {id: 'editor-status-bar'}, [statusBarLeft, statusBarRight] );


                editorInstructionsFooter = Utils.createElement('div', { 
                    id: 'editor-instructions-footer',
                    textContent: `Ctrl+S: Save & Exit | Ctrl+O: Exit (confirm if unsaved) | Ctrl+P: Preview`
                });

                editorContainerDiv = Utils.createElement('div', { id: 'editor-container' }, [
                    editorControlsDiv,
                    editorMainAreaDiv,
                    editorStatusBar,
                    editorInstructionsFooter
                ]);
                
                DOM.terminalDiv.insertBefore(editorContainerDiv, DOM.inputLineContainerDiv);
            }

             function _setViewModeUI(mode) { 
                currentViewMode = mode;
                const isPreviewable = currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML;

                if (!editorLineGutter || !editorTextareaWrapper || !editorPreviewWrapper || !viewToggleButton) return;

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN) {
                    editorPreviewPaneDiv.classList.add('markdown-preview'); 
                    _applyWordWrapToMarkdownPreview(); 
                } else {
                    editorPreviewPaneDiv.classList.remove('markdown-preview');
                }
                if (currentFileMode === Config.EDITOR.MODES.HTML) {
                     _applyWordWrapToHtmlPreview(); 
                }


                if (!isPreviewable) { 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "none";
                    editorPreviewWrapper.style.flex = "0";
                    viewToggleButton.style.display = 'none';
                    editorTextareaWrapper.style.borderRight = 'none';
                    return;
                }
                
                viewToggleButton.style.display = 'block'; 

                if (mode === Config.EDITOR.VIEW_MODES.SPLIT) { 
                    viewToggleButton.textContent = "Edit Only"; 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "block";  
                    editorPreviewWrapper.style.flex = "1"; 
                    editorTextareaWrapper.style.borderRight = '1px solid #333'; 
                } else if (mode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) { 
                    viewToggleButton.textContent = "Preview Only"; 
                    editorLineGutter.style.display = "block";
                    editorTextareaWrapper.style.display = "block"; 
                    editorTextareaWrapper.style.flex = "1"; 
                    editorPreviewWrapper.style.display = "none"; 
                    editorPreviewWrapper.style.flex = "0";
                    editorTextareaWrapper.style.borderRight = 'none'; 
                } else if (mode === Config.EDITOR.VIEW_MODES.PREVIEW_ONLY) { 
                    viewToggleButton.textContent = "Split View"; 
                    editorLineGutter.style.display = "none";
                    editorTextareaWrapper.style.display = "none";
                    editorTextareaWrapper.style.flex = "0"; 
                    editorPreviewWrapper.style.display = "block";  
                    editorPreviewWrapper.style.flex = "1"; 
                    editorTextareaWrapper.style.borderRight = 'none';
                }
            }
            function _toggleViewMode() {
                if (currentFileMode !== Config.EDITOR.MODES.MARKDOWN && currentFileMode !== Config.EDITOR.MODES.HTML) return;
                if (currentViewMode === Config.EDITOR.VIEW_MODES.SPLIT) _setViewModeUI(Config.EDITOR.VIEW_MODES.EDIT_ONLY);
                else if (currentViewMode === Config.EDITOR.VIEW_MODES.EDIT_ONLY) _setViewModeUI(Config.EDITOR.VIEW_MODES.PREVIEW_ONLY);
                else _setViewModeUI(Config.EDITOR.VIEW_MODES.SPLIT);
                if (editorTextareaElement && editorTextareaWrapper.style.display !== "none") editorTextareaElement.focus();
            }
            function enter(filePath, content) {
                if (isActiveState) { OutputManager.appendToOutput("Editor already active.", { typeClass: Config.CSS_CLASSES.EDITOR_MSG }); return; }
                
                _loadWordWrapSetting(); 

                isActiveState = true; 
                OutputManager.setEditorActive(true); 
                currentFilePath = filePath; 
                currentFileMode = _determineMode(filePath);
                originalContent = content; 
                isDirty = false;      

                currentViewMode = (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) ? Config.EDITOR.VIEW_MODES.SPLIT : Config.EDITOR.VIEW_MODES.EDIT_ONLY;
                DOM.outputDiv.style.display = 'none'; 
                DOM.inputLineContainerDiv.style.display = 'none'; 
                
                _setupEditorLayout(); 
                
                editorTextareaElement.value = content;
                
                _applyWordWrapToTextarea(); 
                _updateWordWrapToggleButtonText(); 

                _updateFilenameDisplay(); 
                _updateLineNumbers();
                _updateStatusBar();

                if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) { 
                    _updatePreview(); 
                }
                editorTextareaElement.focus(); 
                editorTextareaElement.setSelectionRange(0,0); 
                editorTextareaElement.addEventListener('keydown', handleKeyDown); 
            }
            async function _performExitActions() {
                if (editorContainerDiv && editorContainerDiv.parentNode === DOM.terminalDiv) DOM.terminalDiv.removeChild(editorContainerDiv);
                if (editorTextareaElement) { 
                    editorTextareaElement.removeEventListener('keydown', handleKeyDown); 
                    editorTextareaElement.removeEventListener('input', _handleEditorInput);
                    editorTextareaElement.removeEventListener('scroll', _handleEditorScroll);
                    editorTextareaElement.removeEventListener('click', _handleEditorSelectionChange);
                    editorTextareaElement.removeEventListener('keyup', _handleEditorSelectionChange);
                }
                editorContainerDiv = editorControlsDiv = editorFilenameDisplay = viewToggleButton = exportPreviewButton = wordWrapToggleButton = null;
                editorMainAreaDiv = editorLineGutter = editorTextareaWrapper = editorTextareaElement = null;
                editorPreviewWrapper = editorPreviewPaneDiv = null;
                editorStatusBar = statusBarLineCount = statusBarWordCount = statusBarCharCount = statusBarCursorPos = null;
                editorInstructionsFooter = null;

                if (debounceTimer) clearTimeout(debounceTimer); debounceTimer = null;
                isActiveState = false; 
                OutputManager.setEditorActive(false); 
                currentFilePath = null; 
                currentFileMode = Config.EDITOR.DEFAULT_MODE;
                isDirty = false;
                originalContent = "";

                DOM.outputDiv.style.display = ''; 
                DOM.inputLineContainerDiv.style.display = '';
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                TerminalUI.focusInput(); 
                TerminalUI.updatePrompt(); 
            }

            async function exit(saveChanges = false) {
                let proceedToExit = true; 

                if (!saveChanges && isDirty) {
                    const userConfirmedDiscard = await new Promise((resolveConfirmation) => {
                        ConfirmationManager.request(
                            [Config.MESSAGES.EDITOR_DISCARD_CONFIRM],
                            null,
                            () => resolveConfirmation(true), 
                            () => resolveConfirmation(false) 
                        );
                    });

                    if (userConfirmedDiscard) {
                        OutputManager.appendToOutput(`Exited editor for '${currentFilePath || 'Untitled'}' without saving. Discarded changes.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    } else {
                        OutputManager.appendToOutput("Exit cancelled. Continue editing.", { typeClass: Config.CSS_CLASSES.EDITOR_MSG });
                        if(editorTextareaElement) editorTextareaElement.focus();
                        proceedToExit = false; 
                    }
                }

                if (!proceedToExit) {
                    return false; 
                }
                
                let saveSuccess = true;
                if (saveChanges && editorTextareaElement && currentFilePath) {
                    const newContent = editorTextareaElement.value;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentFilePath);
                    if (parentDirResult.error) { 
                        OutputManager.appendToOutput(`edit: ${parentDirResult.error}`, { typeClass: Config.CSS_CLASSES.EDITOR_MSG }); 
                        saveSuccess = false; 
                    } else {
                        const parentNode = parentDirResult.parentNode;
                        if (parentNode) {
                            const fileName = currentFilePath.substring(currentFilePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: newContent };
                            const currentUser = UserManager.getCurrentUser();
                            if (currentUser) {
                                if (await FileSystemManager.save(currentUser.name)) {
                                    OutputManager.appendToOutput(`File '${currentFilePath}' saved.`, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                                    originalContent = newContent; 
                                    isDirty = false;
                                    _updateFilenameDisplay();
                                } else { 
                                    OutputManager.appendToOutput(`Error saving file '${currentFilePath}'. Changes might be lost.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                    saveSuccess = false; 
                                }
                            } else { 
                                OutputManager.appendToOutput(`Error saving file: No current user context.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                saveSuccess = false; 
                            }
                        } else { 
                            OutputManager.appendToOutput(`Failed to save '${currentFilePath}'. Could not obtain parent directory.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                            saveSuccess = false; 
                        }
                    }
                } else if (!saveChanges && !isDirty) { 
                     OutputManager.appendToOutput(`Exited editor for '${currentFilePath || 'Untitled'}' without saving. No changes made.`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                }
                
                await _performExitActions();
                return saveSuccess; 
            }

            async function handleKeyDown(event) {
                if (event.key === 'Tab') {
                    event.preventDefault(); 
                    const start = editorTextareaElement.selectionStart;
                    const end = editorTextareaElement.selectionEnd;
                    editorTextareaElement.value = editorTextareaElement.value.substring(0, start) + Config.EDITOR.TAB_REPLACEMENT + editorTextareaElement.value.substring(end);
                    editorTextareaElement.selectionStart = editorTextareaElement.selectionEnd = start + Config.EDITOR.TAB_REPLACEMENT.length;
                    _handleEditorInput(); 
                    return;
                }
                if (event.ctrlKey) {
                    switch (event.key.toLowerCase()) {
                        case 's': event.preventDefault(); await exit(true); break;
                        case 'o': event.preventDefault(); await exit(false); break;
                        case 'p': 
                            event.preventDefault(); 
                            if (currentFileMode === Config.EDITOR.MODES.MARKDOWN || currentFileMode === Config.EDITOR.MODES.HTML) {
                                _toggleViewMode();
                            }
                            break;
                    }
                }
                setTimeout(_handleEditorSelectionChange, 0); 
            }
            return { isActive: () => isActiveState, enter, exit, exportPreviewAsHtml }; 
        })();

        // --- USER MANAGER ---
        const UserManager = (() => { 
            'use strict';
            let currentUser = { name: Config.USER.DEFAULT_NAME }; 
            function getCurrentUser() { return currentUser; }
            async function register(username) {
                const formatValidation = Utils.validateUsernameFormat(username);
                if (!formatValidation.isValid) {
                    return { success: false, error: formatValidation.error };
                }

                const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (users[username]) {
                    return { success: false, error: `User '${username}' already exists.` };
                }
                
                users[username] = {}; 
                if (StorageManager.saveItem(Config.STORAGE_KEYS.USER_CREDENTIALS, users, "User list")) {
                    await FileSystemManager.initialize(username); await FileSystemManager.save(username);
                    return { success: true, message: `User '${username}' registered. You can now login.` };
                } else {
                    return { success: false, error: "Failed to save new user credentials." };
                }
            }
            async function login(username) {
                if (currentUser.name === username) return { success: true, message: `${Config.MESSAGES.ALREADY_LOGGED_IN_AS_PREFIX}${username}${Config.MESSAGES.ALREADY_LOGGED_IN_AS_SUFFIX}`, noAction: true };
                const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                if (!users.hasOwnProperty(username)) return { success: false, error: "Invalid username." };
                if (currentUser.name !== Config.USER.DEFAULT_NAME && currentUser.name !== username) SessionManager.saveAutomaticState(currentUser.name);
                currentUser = { name: username }; 
                HistoryManager.clearHistory(); 
                await FileSystemManager.load(username); 
                SessionManager.loadAutomaticState(username); 
                TerminalUI.updatePrompt(); 
                return { success: true, message: `Logged in as ${username}.` };
            }
            async function logout() {
                if (currentUser.name === Config.USER.DEFAULT_NAME) return { success: true, message: `Already logged in as Guest. ${Config.MESSAGES.NO_ACTION_TAKEN}`, noAction: true };
                SessionManager.saveAutomaticState(currentUser.name); 
                const prevUserName = currentUser.name;
                currentUser = { name: Config.USER.DEFAULT_NAME }; 
                HistoryManager.clearHistory();
                await FileSystemManager.load(Config.USER.DEFAULT_NAME); 
                SessionManager.loadAutomaticState(Config.USER.DEFAULT_NAME); 
                TerminalUI.updatePrompt();
                return { success: true, message: `User ${prevUserName} logged out. Now logged in as ${Config.USER.DEFAULT_NAME}.` };
            }
            function setCurrentUserObject(userObject) { currentUser = userObject; }
            function getDefaultUser() { return Config.USER.DEFAULT_NAME; }
            return { getCurrentUser, register, login, logout, setCurrentUserObject, getDefaultUser };
        })();

        // --- SESSION MANAGER ---
        const SessionManager = (() => { 
            'use strict';
            function _getAutomaticSessionStateKey(user) { return `${Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX}${user}`; }
            function _getManualUserTerminalStateKey(user) { const userName = typeof user === 'object' && user !== null && user.name ? user.name : String(user); return `${Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX}${userName}`; }

            function saveAutomaticState(username) {
                const currentInput = TerminalUI.getCurrentInputValue();
                const autoState = { currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, commandHistory: HistoryManager.getFullHistory() };
                StorageManager.saveItem(_getAutomaticSessionStateKey(username), autoState, `Auto session for ${username}`);
            }
            function loadAutomaticState(username) {
                const autoState = StorageManager.loadItem(_getAutomaticSessionStateKey(username), `Auto session for ${username}`);
                if (autoState) {
                    FileSystemManager.setCurrentPath(autoState.currentPath || Config.FILESYSTEM.ROOT_PATH);
                    if (autoState.hasOwnProperty('outputHTML')) DOM.outputDiv.innerHTML = autoState.outputHTML || '';
                    else DOM.outputDiv.innerHTML = '';
                    TerminalUI.setCurrentInputValue(autoState.currentInput || '');
                    HistoryManager.setHistory(autoState.commandHistory || []);
                } else {
                    DOM.outputDiv.innerHTML = ''; TerminalUI.setCurrentInputValue('');
                    FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH);
                    HistoryManager.clearHistory();
                    OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`);
                }
                TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                return !!autoState;
            }
            async function saveManualState() {
                const currentUser = UserManager.getCurrentUser(); const currentInput = TerminalUI.getCurrentInputValue();
                const manualStateData = { user: currentUser.name, osVersion: Config.OS.VERSION, timestamp: new Date().toISOString(), currentPath: FileSystemManager.getCurrentPath(), outputHTML: DOM.outputDiv.innerHTML, currentInput: currentInput, fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()), commandHistory: HistoryManager.getFullHistory() };
                if (StorageManager.saveItem(_getManualUserTerminalStateKey(currentUser), manualStateData, `Manual save for ${currentUser.name}`)) return { success: true, message: `${Config.MESSAGES.SESSION_SAVED_FOR_PREFIX}${currentUser.name}.` };
                else return { success: false, error: "Failed to save session manually." };
            }
            async function loadManualState() {
                const currentUser = UserManager.getCurrentUser();
                const manualStateData = StorageManager.loadItem(_getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser.name}`);
                if (manualStateData) {
                    if (manualStateData.user && manualStateData.user !== currentUser.name) OutputManager.appendToOutput(`Warning: Saved state is for user '${manualStateData.user}', but current user is '${currentUser.name}'. Loading anyway.`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                    ConfirmationManager.request(
                        [`Load manually saved state for '${currentUser.name}'? This overwrites current session & filesystem.`],
                        { pendingData: manualStateData, userNameToRestoreTo: currentUser.name },
                        async (data) => {
                            FileSystemManager.setFsData(Utils.deepCopyNode(data.pendingData.fsDataSnapshot) || { [Config.FILESYSTEM.ROOT_PATH]: { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} } });
                            FileSystemManager.setCurrentPath(data.pendingData.currentPath || Config.FILESYSTEM.ROOT_PATH);
                            DOM.outputDiv.innerHTML = data.pendingData.outputHTML || '';
                            TerminalUI.setCurrentInputValue(data.pendingData.currentInput || '');
                            HistoryManager.setHistory(data.pendingData.commandHistory || []);
                            await FileSystemManager.save(data.userNameToRestoreTo);
                            OutputManager.appendToOutput(Config.MESSAGES.SESSION_LOADED_MSG, { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                            TerminalUI.updatePrompt(); DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        },
                        () => { OutputManager.appendToOutput(Config.MESSAGES.LOAD_STATE_CANCELLED, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG }); }
                    );
                    return { success: true, message: "Confirmation requested for loading state." };
                } else return { success: false, message: `${Config.MESSAGES.NO_MANUAL_SAVE_FOUND_PREFIX}${currentUser.name}.` };
            }

            function clearUserSessionStates(username) { 
                if (!username || typeof username !== 'string') {
                    console.warn("SessionManager.clearUserSessionStates: Invalid username provided.");
                    return false;
                }
                try {
                    StorageManager.removeItem(_getAutomaticSessionStateKey(username));
                    StorageManager.removeItem(_getManualUserTerminalStateKey(username));
                    return true;
                } catch (e) {
                    console.error(`Error clearing session states for user '${username}':`, e);
                    return false;
                }
            }

            async function performFullReset() { 
                OutputManager.clearOutput(); TerminalUI.clearInput();
                const keysToRemove = []; const allKeys = StorageManager.getAllLocalStorageKeys();
                allKeys.forEach(key => { if (key.startsWith(Config.STORAGE_KEYS.USER_TERMINAL_STATE_PREFIX) || key.startsWith(Config.STORAGE_KEYS.MANUAL_TERMINAL_STATE_PREFIX) || key === Config.STORAGE_KEYS.USER_CREDENTIALS || key === Config.STORAGE_KEYS.EDITOR_WORD_WRAP_ENABLED) keysToRemove.push(key); });
                keysToRemove.forEach(key => StorageManager.removeItem(key));
                await OutputManager.appendToOutput("All session states, credentials, and editor settings cleared from local storage.");
                try { await FileSystemManager.clearAllFS(); await OutputManager.appendToOutput("All user filesystems cleared from DB."); } catch (error) {}
                HistoryManager.clearHistory();
                const guestUser = { name: Config.USER.DEFAULT_NAME }; UserManager.setCurrentUserObject(guestUser);
                await FileSystemManager.initialize(Config.USER.DEFAULT_NAME); await FileSystemManager.save(Config.USER.DEFAULT_NAME);
                loadAutomaticState(Config.USER.DEFAULT_NAME);
                await OutputManager.appendToOutput("Terminal fully reset. All user data and states cleared.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
                TerminalUI.updatePrompt();
            }
            return {
                saveAutomaticState,
                loadAutomaticState,
                saveManualState,
                loadManualState,
                clearUserSessionStates, 
                performFullReset
            };
        })();

        // --- TERMINAL UI MANAGER ---
        const TerminalUI = (() => { 
            'use strict';
            let isNavigatingHistory = false; 
            function updatePrompt() {
                const user = (typeof UserManager !== 'undefined') ? UserManager.getCurrentUser() : { name: Config.USER.DEFAULT_NAME }; 
                DOM.promptUserSpan.textContent = user ? user.name : Config.USER.DEFAULT_NAME;
                DOM.promptHostSpan.textContent = Config.OS.DEFAULT_HOST_NAME;
                const currentPathDisplay = (typeof FileSystemManager !== 'undefined') ? FileSystemManager.getCurrentPath() : Config.FILESYSTEM.ROOT_PATH; 
                DOM.promptPathSpan.textContent = (currentPathDisplay === Config.FILESYSTEM.ROOT_PATH && currentPathDisplay.length > 1) ? Config.FILESYSTEM.ROOT_PATH : currentPathDisplay;
            }
            function focusInput() { if (DOM.editableInputDiv) { DOM.editableInputDiv.focus(); if (DOM.editableInputDiv.textContent.length === 0) setCaretToEnd(DOM.editableInputDiv); }}
            function clearInput() { if (DOM.editableInputDiv) DOM.editableInputDiv.textContent = ''; }
            function getCurrentInputValue() { return DOM.editableInputDiv ? DOM.editableInputDiv.textContent : ''; }
            function setCurrentInputValue(value, setAtEnd = true) { 
                if (DOM.editableInputDiv) { 
                    DOM.editableInputDiv.textContent = value; 
                    if (setAtEnd) setCaretToEnd(DOM.editableInputDiv); 
                }
            }
            function setCaretToEnd(element) { 
                if (!element) return; 
                const range = document.createRange();
                const sel = window.getSelection(); 
                range.selectNodeContents(element); 
                range.collapse(false); 
                sel.removeAllRanges(); 
                sel.addRange(range); 
                element.focus(); 
            }
            function setCaretPosition(element, position) {
                if (!element || typeof position !== 'number') return;
                const range = document.createRange();
                const sel = window.getSelection();
                let charCount = 0;
                let foundNode = false;

                function findTextNodeAndSet(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const nextCharCount = charCount + node.length;
                        if (!foundNode && position >= charCount && position <= nextCharCount) {
                            range.setStart(node, position - charCount);
                            range.collapse(true);
                            foundNode = true;
                        }
                        charCount = nextCharCount;
                    } else {
                        for (let i = 0; i < node.childNodes.length; i++) {
                            if (findTextNodeAndSet(node.childNodes[i])) {
                                return true; 
                            }
                            if (foundNode) break; 
                        }
                    }
                    return foundNode;
                }

                if (element.childNodes.length === 0 && position === 0) { 
                     range.setStart(element, 0);
                     range.collapse(true);
                     foundNode = true;
                } else {
                    findTextNodeAndSet(element);
                }
                

                if (foundNode) {
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else { 
                    range.selectNodeContents(element);
                    range.collapse(false); 
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                element.focus(); 
            }
            
            function setInputState(isEditable) {
                if (DOM.editableInputDiv) {
                    DOM.editableInputDiv.contentEditable = isEditable ? 'true' : 'false';
                    DOM.editableInputDiv.style.opacity = isEditable ? '1' : '0.5';
                    if (isEditable) {
                        focusInput(); 
                    } else {
                        DOM.editableInputDiv.blur(); 
                    }
                }
            }

            function setIsNavigatingHistory(status) { isNavigatingHistory = status; } 
            function getIsNavigatingHistory() { return isNavigatingHistory; }
            
            return { 
                updatePrompt, focusInput, clearInput, setCurrentInputValue, getCurrentInputValue, 
                setCaretToEnd, setIsNavigatingHistory, getIsNavigatingHistory,
                setCaretPosition,
                setInputState 
            };
        })();

        // --- TAB COMPLETION MANAGER ---
        const TabCompletionManager = (() => { 
            'use strict';
            const PATH_COMMANDS = ['ls', 'cd', 'cat', 'edit', 'run', 'mv', 'cp', 'rm', 'mkdir', 'touch', 'export', 'find', 'tree']; 
            function findLongestCommonPrefix(strs) {
                if (!strs || strs.length === 0) return "";
                if (strs.length === 1) return strs[0];
                let prefix = strs[0];
                for (let i = 1; i < strs.length; i++) {
                    while (strs[i].indexOf(prefix) !== 0) {
                        prefix = prefix.substring(0, prefix.length - 1);
                        if (prefix === "") return "";
                    }
                }
                return prefix;
            }
            function getSuggestions(fullInput, cursorPos) {
                const textBeforeCursor = fullInput.substring(0, cursorPos);
                const tokens = textBeforeCursor.trimStart().split(/\s+/); 
                let currentWordPrefix = ""; 
                let isCompletingCommandName = false;
                let baseCommandForPath = "";
                const lastCharIsSpace = /\s$/.test(textBeforeCursor) || textBeforeCursor.length === 0;

                if (tokens.length === 0 || (tokens.length === 1 && !lastCharIsSpace && tokens[0] !== "")) {
                    isCompletingCommandName = true;
                    currentWordPrefix = tokens.length > 0 ? tokens[0] : "";
                } else {
                    baseCommandForPath = tokens[0].toLowerCase();
                    if (lastCharIsSpace) { 
                        currentWordPrefix = "";
                    } else { 
                        currentWordPrefix = tokens[tokens.length - 1];
                    }
                }
                
                let suggestions = [];
                if (isCompletingCommandName) {
                    const allCommands = CommandExecutor.getCommands(); 
                    if (allCommands) {
                         suggestions = Object.keys(allCommands)
                            .filter(cmdName => cmdName.startsWith(currentWordPrefix))
                            .sort();
                    }
                } else if (PATH_COMMANDS.includes(baseCommandForPath)) {
                    let effectiveBasePath = FileSystemManager.getCurrentPath();
                    let segmentToMatch = currentWordPrefix;
                    const lastSlashIndex = currentWordPrefix.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR);
                    let pathPrefixTyped = ""; 

                    if (lastSlashIndex !== -1) {
                        pathPrefixTyped = currentWordPrefix.substring(0, lastSlashIndex + 1);
                        segmentToMatch = currentWordPrefix.substring(lastSlashIndex + 1);
                        effectiveBasePath = FileSystemManager.getAbsolutePath(pathPrefixTyped, FileSystemManager.getCurrentPath());
                    }
                    const baseNode = FileSystemManager.getNodeByPath(effectiveBasePath);
                    if (baseNode && baseNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                        suggestions = Object.keys(baseNode.children)
                            .filter(name => name.startsWith(segmentToMatch))
                            .map(name => {
                                const childNode = baseNode.children[name];
                                let fullSuggestion = pathPrefixTyped + name; 
                                if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    return fullSuggestion + Config.FILESYSTEM.PATH_SEPARATOR;
                                }
                                return fullSuggestion;
                            })
                            .sort();
                    }
                }

                if (suggestions.length === 0) {
                    return { textToInsert: null, newCursorPos: cursorPos };
                }

                if (suggestions.length === 1) {
                    const completedSegment = suggestions[0];
                    let startOfWordIndex = textBeforeCursor.length - currentWordPrefix.length;
                    if (startOfWordIndex < 0) startOfWordIndex = 0; 
                    const newFullInput = textBeforeCursor.substring(0, startOfWordIndex) + completedSegment + fullInput.substring(cursorPos);
                    const newCursor = startOfWordIndex + completedSegment.length;
                    return { textToInsert: newFullInput, newCursorPos: newCursor };
                } else { 
                    const lcp = findLongestCommonPrefix(suggestions);
                    if (lcp.length > currentWordPrefix.length) {
                        let startOfWordIndex = textBeforeCursor.length - currentWordPrefix.length;
                         if (startOfWordIndex < 0) startOfWordIndex = 0;
                        const newFullInput = textBeforeCursor.substring(0, startOfWordIndex) + lcp + fullInput.substring(cursorPos);
                        const newCursor = startOfWordIndex + lcp.length;
                        return { textToInsert: newFullInput, newCursorPos: newCursor };
                    } else {
                        const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `;
                        OutputManager.appendToOutput(suggestions.join('    '), { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG, isCompletionSuggestion: true });
                        OutputManager.appendToOutput(`${promptText}${fullInput}`, {isCompletionSuggestion: true}); 
                        DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight;
                        return { textToInsert: null, newCursorPos: cursorPos }; 
                    }
                }
            }
            return { getSuggestions };
        })();

        // --- COMMAND EXECUTOR ---
        const CommandExecutor = (() => { 
            'use strict';
            let scriptExecutionInProgress = false; 
            let backgroundProcessIdCounter = 0; 
            
            const TokenType = { 
                WORD: 'WORD', 
                STRING_DQ: 'STRING_DQ', 
                STRING_SQ: 'STRING_SQ', 
                OPERATOR_GT: 'OPERATOR_GT',       
                OPERATOR_GTGT: 'OPERATOR_GTGT',   
                OPERATOR_PIPE: 'OPERATOR_PIPE',   
                OPERATOR_BG: 'OPERATOR_BG',       
                EOF: 'EOF' 
            };

            class Token { constructor(type, value, position) { this.type = type; this.value = value; this.position = position; } }
            
            class Lexer { 
                constructor(input) { this.input = input; this.position = 0; this.tokens = []; }
                tokenize() {
                    while (this.position < this.input.length) {
                        const char = this.input[this.position];
                        if (/\s/.test(char)) { this.position++; continue; }
                        if (char === '"') { this.tokens.push(this._tokenizeString('"')); continue; }
                        if (char === "'") { this.tokens.push(this._tokenizeString("'")); continue; }
                        if (char === '>') {
                            if (this.input[this.position + 1] === '>') { this.tokens.push(new Token(TokenType.OPERATOR_GTGT, '>>', this.position)); this.position += 2; }
                            else { this.tokens.push(new Token(TokenType.OPERATOR_GT, '>', this.position)); this.position++; }
                            continue;
                        }
                        if (char === '|') { this.tokens.push(new Token(TokenType.OPERATOR_PIPE, '|', this.position)); this.position++; continue; }
                        if (char === '&') { this.tokens.push(new Token(TokenType.OPERATOR_BG, '&', this.position)); this.position++; continue; }
                        
                        let value = ''; const startPos = this.position;
                        while (this.position < this.input.length && !/\s/.test(this.input[this.position]) && !['"', "'", '>', '|', '&'].includes(this.input[this.position])) { 
                            value += this.input[this.position]; this.position++; 
                        }
                        if (value) this.tokens.push(new Token(TokenType.WORD, value, startPos));
                        else if (this.position < this.input.length && !['"', "'", '>', '|', '&'].includes(this.input[this.position]) && !/\s/.test(this.input[this.position])) {
                             throw new Error(`Lexer Error: Unhandled character '${this.input[this.position]}' at position ${this.position}.`);
                        } else if (this.position >= this.input.length && !value && this.tokens.length > 0 && this.tokens[this.tokens.length-1].type !== TokenType.EOF) {
                        } else if (this.position < this.input.length && !value) {
                        }
                    }
                    this.tokens.push(new Token(TokenType.EOF, null, this.position)); return this.tokens;
                }
                _tokenizeString(quoteChar) {
                    const startPos = this.position; let value = ''; this.position++; 
                    while (this.position < this.input.length && this.input[this.position] !== quoteChar) { value += this.input[this.position]; this.position++; }
                    if (this.position >= this.input.length || this.input[this.position] !== quoteChar) throw new Error(`Lexer Error: Unclosed string literal starting at position ${startPos}. Expected closing ${quoteChar}.`);
                    this.position++; return new Token(quoteChar === '"' ? TokenType.STRING_DQ : TokenType.STRING_SQ, value, startPos);
                }
            }

            class ParsedCommandSegment {
                constructor(command, args) {
                    this.command = command; 
                    this.args = args;       
                }
            }

            class ParsedPipeline {
                constructor() {
                    this.segments = []; 
                    this.redirection = null; 
                    this.isBackground = false;
                }
            }
            
            class Parser { 
                constructor(tokens) { this.tokens = tokens; this.position = 0; this.pipeline = new ParsedPipeline(); }
                _currentToken() { return this.tokens[this.position]; }
                _nextToken() { if (this.position < this.tokens.length -1) this.position++; return this._currentToken(); }
                _expectAndConsume(tokenType, optional = false) { 
                    const c = this._currentToken(); 
                    if (c.type === tokenType) { this._nextToken(); return c; } 
                    if (optional) return null;
                    throw new Error(`Parser Error: Expected token ${tokenType} but got ${c.type} ('${c.value}') at input position ${c.position}.`); 
                }

                _parseSingleCommandSegment() {
                    if (this._currentToken().type === TokenType.EOF || 
                        this._currentToken().type === TokenType.OPERATOR_PIPE ||
                        this._currentToken().type === TokenType.OPERATOR_BG) {
                        return null; 
                    }
                    const cmdToken = this._expectAndConsume(TokenType.WORD);
                    if (!cmdToken) throw new Error("Parser Error: Expected command name (WORD).");
                    const command = cmdToken.value;
                    const args = [];
                    while (this._currentToken().type !== TokenType.EOF &&
                           this._currentToken().type !== TokenType.OPERATOR_PIPE &&
                           this._currentToken().type !== TokenType.OPERATOR_GT &&
                           this._currentToken().type !== TokenType.OPERATOR_GTGT &&
                           this._currentToken().type !== TokenType.OPERATOR_BG) {
                        const argToken = this._currentToken();
                        if (argToken.type === TokenType.WORD || argToken.type === TokenType.STRING_DQ || argToken.type === TokenType.STRING_SQ) {
                            args.push(argToken.value);
                            this._nextToken();
                        } else {
                            throw new Error(`Parser Error: Unexpected token ${argToken.type} ('${argToken.value}') in arguments at position ${argToken.position}.`);
                        }
                    }
                    return new ParsedCommandSegment(command, args);
                }

                parse() {
                    let currentSegment = this._parseSingleCommandSegment();
                    if (currentSegment) {
                        this.pipeline.segments.push(currentSegment);
                    } else if (this._currentToken().type !== TokenType.EOF && this._currentToken().type !== TokenType.OPERATOR_BG) {
                         throw new Error(`Parser Error: Expected command at start of input or after pipe.`);
                    }


                    while (this._currentToken().type === TokenType.OPERATOR_PIPE) {
                        this._nextToken(); 
                        currentSegment = this._parseSingleCommandSegment();
                        if (!currentSegment) throw new Error("Parser Error: Expected command after pipe operator '|'.");
                        this.pipeline.segments.push(currentSegment);
                    }

                    if (this._currentToken().type === TokenType.OPERATOR_GT || this._currentToken().type === TokenType.OPERATOR_GTGT) {
                        const opToken = this._currentToken();
                        this._nextToken(); 
                        const fileToken = this._expectAndConsume(TokenType.WORD, true) || this._expectAndConsume(TokenType.STRING_DQ, true) || this._expectAndConsume(TokenType.STRING_SQ, true);
                        if (!fileToken) throw new Error(`Parser Error: Expected filename after redirection operator '${opToken.value}'.`);
                        this.pipeline.redirection = { type: opToken.type === TokenType.OPERATOR_GTGT ? 'append' : 'overwrite', file: fileToken.value };
                    }

                    if (this._currentToken().type === TokenType.OPERATOR_BG) {
                        if (this.tokens[this.position + 1].type !== TokenType.EOF) {
                             throw new Error("Parser Error: Background operator '&' must be the last character on the command line (or before EOF).");
                        }
                        this.pipeline.isBackground = true;
                        this._nextToken(); 
                    }
                    
                    this._expectAndConsume(TokenType.EOF); 
                    if(this.pipeline.segments.length === 0 && !this.pipeline.isBackground && !this.pipeline.redirection) {
                        return new ParsedPipeline(); 
                    }
                    return this.pipeline;
                }
            }

            const commands = {
                'help': {
                    handler: async (args, options) => {
                        let output = "OopisOS Help:\n\n";
                        if (args.length === 0) {
                            output += "Available commands:\n";
                            Object.keys(commands).sort().forEach(cmd => {
                                output += `  ${cmd.padEnd(15)} ${commands[cmd].description || ''}\n`;
                            });
                            output += "\nType 'help [command]' for more information on a specific command.";
                        } else {
                            const cmdName = args[0].toLowerCase();
                            if (commands[cmdName] && commands[cmdName].helpText) {
                                output = commands[cmdName].helpText;
                            } else if (commands[cmdName]) {
                                output = `No detailed help available for '${cmdName}'.\nDescription: ${commands[cmdName].description || 'N/A'}`;
                            } else {
                                return { success: false, error: `help: '${args[0]}' is not a known command.` };
                            }
                        }
                        return { success: true, output: output };
                    },
                    description: "Displays this help message or help for a specific command.",
                    helpText: "Usage: help [command]\n\nDisplays a list of available commands or detailed help for a specific [command]."
                },
                'echo': {
                    handler: async (args, options) => {
                        return { success: true, output: args.join(' ') };
                    },
                    description: "Displays a line of text.",
                    helpText: "Usage: echo [text...]\n\nPrints the specified [text] to the terminal. Useful for displaying messages or variable content in scripts."
                },
                'clear': {
                    handler: async (args, options) => {
                        if (options.isInteractive) OutputManager.clearOutput();
                        return { success: true, output: "" }; 
                    },
                    description: "Clears the terminal screen.",
                    helpText: "Usage: clear\n\nClears all previous output from the terminal screen."
                },
                'date': {
                    handler: async (args, options) => {
                        return { success: true, output: new Date().toString() };
                    },
                    description: "Displays the current date and time.",
                    helpText: "Usage: date\n\nShows the current system date and time."
                },
                'pwd': {
                    handler: async (args, options) => {
                        return { success: true, output: FileSystemManager.getCurrentPath() };
                    },
                    description: "Prints the current working directory.",
                    helpText: "Usage: pwd\n\nDisplays the full path of the current directory."
                },
                               'ls': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [
                            { name: 'long', short: '-l', long: '--long' },
                            { name: 'all', short: '-a', long: '--all' } 
                        ]);

                        const validationResult = Utils.validateArguments(remainingArgs, { max: 1 });
                        if (!validationResult.isValid) return { success: false, error: `ls: ${validationResult.errorDetail}` };
                        
                        const pathArg = remainingArgs.length > 0 ? remainingArgs[0] : Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                        const pathValidation = FileSystemManager.validatePath('ls', pathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };

                        const dirNode = pathValidation.node;
                        if (!dirNode || dirNode.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                             return { success: false, error: `ls: '${pathArg}': Not a directory` }; 
                        }

                        // Get all children names initially
                        const allChildrenNames = Object.keys(dirNode.children).sort();
                        let effectiveChildrenNames;

                        // Filter out dotfiles if -a or --all is NOT specified
                        if (flags.all) {
                            effectiveChildrenNames = allChildrenNames;
                        } else {
                            effectiveChildrenNames = allChildrenNames.filter(name => !name.startsWith('.'));
                        }

                        // Check if the directory (after filtering) is empty
                        if (effectiveChildrenNames.length === 0) {
                            return { success: true, output: Config.MESSAGES.DIRECTORY_EMPTY };
                        }
                        
                        let outputLines = [];
                        if (flags.long) {
                            // Display total count based on effective (filtered or all) children
                            outputLines.push(`Total ${effectiveChildrenNames.length} items`);
                            effectiveChildrenNames.forEach(name => {
                                const childNode = dirNode.children[name];
                                const typeChar = childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? 'd' : '-';
                                const size = Utils.formatBytes(FileSystemManager.calculateNodeSize(childNode));
                                const perms = 'rwxr-xr-x'; // Placeholder permissions
                                const owner = UserManager.getCurrentUser().name; // Placeholder owner
                                const modified = new Date().toLocaleDateString(); // Placeholder modified date
                                outputLines.push(`${typeChar}${perms}  1 ${owner.padEnd(8)} ${owner.padEnd(8)} ${String(size).padStart(6)} ${modified} ${name}${childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? Config.FILESYSTEM.PATH_SEPARATOR : ''}`);
                            });
                        } else {
                            effectiveChildrenNames.forEach(name => {
                                const childNode = dirNode.children[name];
                                const suffix = childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE ? Config.FILESYSTEM.PATH_SEPARATOR : '';
                                outputLines.push(`${name}${suffix}`);
                            });
                        }
                        return { success: true, output: outputLines.join('\n') };
                    },
                    description: "Lists directory contents.",
                    helpText: "Usage: ls [-l] [-a] [path]\n\nLists files and directories in the specified [path] (or current directory if none given).\n  -l, --long    Use a long listing format.\n  -a, --all     Do not ignore entries starting with ."
                },
                'cd': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) return { success: false, error: `cd: ${validationResult.errorDetail}` };
                        
                        const targetPath = args[0];
                        const pathValidation = FileSystemManager.validatePath('cd', targetPath, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };

                        if (FileSystemManager.getCurrentPath() === pathValidation.resolvedPath) {
                            return { success: true, output: `${Config.MESSAGES.ALREADY_IN_DIRECTORY_PREFIX}${pathValidation.resolvedPath}${Config.MESSAGES.ALREADY_IN_DIRECTORY_SUFFIX} ${Config.MESSAGES.NO_ACTION_TAKEN}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                        }
                        FileSystemManager.setCurrentPath(pathValidation.resolvedPath);
                        if (options.isInteractive) TerminalUI.updatePrompt();
                        return { success: true, output: "" }; 
                    },
                    description: "Changes the current directory.",
                    helpText: "Usage: cd <directory_path>\n\nChanges the current working directory to the specified <directory_path>."
                },
                'mkdir': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [
                            { name: 'parents', short: '-p', long: '--parents' }
                        ]);

                        const validationResult = Utils.validateArguments(remainingArgs, { min: 1 });
                        if (!validationResult.isValid) return { success: false, error: `mkdir: ${validationResult.errorDetail}` };
                        
                        let allSuccess = true;
                        const messages = [];
                        let changesMade = false;

                        for (const pathArg of remainingArgs) {
                            const resolvedPath = FileSystemManager.getAbsolutePath(pathArg, FileSystemManager.getCurrentPath());
                            if (resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                                messages.push(`mkdir: cannot create directory '${pathArg}': Operation not permitted on root`);
                                allSuccess = false; continue;
                            }

                            const existingNode = FileSystemManager.getNodeByPath(resolvedPath);
                            if (existingNode) {
                                if (existingNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                     messages.push(`mkdir: cannot create directory '${pathArg}': File exists`);
                                     allSuccess = false; 
                                } else if (flags.parents) { 
                                } else { 
                                     messages.push(`mkdir: cannot create directory '${pathArg}': Directory already exists`);
                                     allSuccess = false; 
                                }
                                continue; 
                            }
                            
                            let parentNodeToCreateIn;
                            const dirName = resolvedPath.substring(resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);

                            if (flags.parents) {
                                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(resolvedPath);
                                if (parentDirResult.error) {
                                    messages.push(`mkdir: ${parentDirResult.error}`);
                                    allSuccess = false; continue;
                                }
                                parentNodeToCreateIn = parentDirResult.parentNode;
                            } else {
                                const parentPath = resolvedPath.substring(0, resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                                parentNodeToCreateIn = FileSystemManager.getNodeByPath(parentPath);
                                if (!parentNodeToCreateIn) {
                                    messages.push(`mkdir: cannot create directory '${pathArg}': Parent directory '${parentPath}' does not exist`);
                                    allSuccess = false; continue;
                                }
                                if (parentNodeToCreateIn.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    messages.push(`mkdir: cannot create directory '${pathArg}': Parent '${parentPath}' is not a directory`);
                                    allSuccess = false; continue;
                                }
                            }
                            
                            if (parentNodeToCreateIn.children[dirName]) {
                                if (parentNodeToCreateIn.children[dirName].type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                     messages.push(`mkdir: cannot create directory '${pathArg}': A file with the same name exists in the parent path`);
                                     allSuccess = false; 
                                } else if (!flags.parents) { 
                                     messages.push(`mkdir: cannot create directory '${pathArg}': Directory already exists`);
                                     allSuccess = false; 
                                }
                                continue;
                            } else {
                                parentNodeToCreateIn.children[dirName] = { type: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE, children: {} };
                                if (!messages.some(m => m.includes(`'${pathArg}'`) && (m.includes("File exists") || m.includes("Directory already exists")))) {
                                    messages.push(`mkdir: created directory '${pathArg}' (resolved as '${resolvedPath}')`);
                                }
                                changesMade = true;
                            }
                        }
                        
                        if (changesMade) { 
                            if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                return { success: false, error: "mkdir: Failed to save file system changes after creating directories.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.ERROR_MSG };
                            }
                        }
                        
                        if (!allSuccess) {
                            const errorMessages = messages.filter(m => !m.startsWith("mkdir: created directory") || m.includes("error") || m.includes("cannot create"));
                             return { success: false, error: "mkdir: Not all directories were created successfully. See output for details.", output: errorMessages.length > 0 ? errorMessages.join('\n') : "One or more paths already existed or could not be created.", messageType: Config.CSS_CLASSES.ERROR_MSG };
                        }
                        return { success: true, output: messages.join('\n'), messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    },
                    description: "Creates new directories.",
                    helpText: "Usage: mkdir [-p] <directory_name>...\n\nCreates one or more new directories with the specified names.\n  -p, --parents   No error if existing, make parent directories as needed."
                },
                'tree': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [
                            { name: 'level', short: '-L', long: '--level', takesValue: true },
                            { name: 'dirsOnly', short: '-d', long: '--dirs-only' }
                        ]);

                        const pathArg = remainingArgs.length > 0 ? remainingArgs[0] : Config.FILESYSTEM.CURRENT_DIR_SYMBOL;
                        const maxDepth = flags.level ? Utils.parseNumericArg(flags.level, {min: 0}) : { value: Infinity };

                        if (flags.level && (maxDepth.error || maxDepth.value === null)) {
                            return { success: false, error: `tree: invalid level value for -L: '${flags.level}' ${maxDepth.error || 'is not a valid non-negative integer.'}` };
                        }

                        const pathValidation = FileSystemManager.validatePath('tree', pathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };

                        const startNode = pathValidation.node;
                        const absStartPath = pathValidation.resolvedPath;

                        const outputLines = [absStartPath];
                        let dirCount = 0;
                        let fileCount = 0;

                        function buildTreeRecursive(currentDirPath, currentDepth, indentPrefix) {
                            if (currentDepth > maxDepth.value) return;

                            const node = FileSystemManager.getNodeByPath(currentDirPath);
                            if (!node || node.type !== Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) return;

                            const childrenNames = Object.keys(node.children).sort();
                            childrenNames.forEach((childName, index) => {
                                const childNode = node.children[childName];
                                const isLast = index === childrenNames.length - 1;
                                const connector = isLast ? "└── " : "├── ";
                                const childAbsPath = FileSystemManager.getAbsolutePath(childName, currentDirPath);

                                if (childNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    dirCount++;
                                    outputLines.push(indentPrefix + connector + childName + Config.FILESYSTEM.PATH_SEPARATOR);
                                    if (currentDepth < maxDepth.value) { 
                                       buildTreeRecursive(childAbsPath, currentDepth + 1, indentPrefix + (isLast ? "    " : "│   "));
                                    }
                                } else if (!flags.dirsOnly) {
                                    fileCount++;
                                    outputLines.push(indentPrefix + connector + childName);
                                }
                            });
                        }

                        buildTreeRecursive(absStartPath, 1, "");
                        
                        outputLines.push("");
                        let report = `${dirCount} director${dirCount === 1 ? 'y' : 'ies'}`;
                        if (!flags.dirsOnly) {
                            report += `, ${fileCount} file${fileCount === 1 ? '' : 's'}`;
                        }
                        outputLines.push(report);

                        return { success: true, output: outputLines.join('\n') };
                    },
                    description: "Lists contents of directories in a tree-like format.",
                    helpText: "Usage: tree [-L level] [-d] [path]\n\n" +
                              "Displays the directory structure starting from [path] (or current directory).\n" +
                              "  -L <level>  Descend only <level> directories deep.\n" +
                              "  -d          List directories only."
                },
                'touch': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { min: 1 });
                        if (!validationResult.isValid) return { success: false, error: `touch: ${validationResult.errorDetail}` };
                        
                        let allSuccess = true;
                        const messages = [];
                        let changesMade = false; 

                        for (const pathArg of args) {
                            const pathValidation = FileSystemManager.validatePath('touch', pathArg, { allowMissing: true, disallowRoot: true });
                            const resolvedPath = pathValidation.resolvedPath; 

                            if (pathValidation.error && pathValidation.node && pathValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                messages.push(`touch: cannot touch '${pathArg}': Is a directory`);
                                allSuccess = false;
                                continue; 
                            } else if (pathValidation.error && pathValidation.resolvedPath === Config.FILESYSTEM.ROOT_PATH) {
                                messages.push(`touch: cannot touch '${pathArg}': Operation not permitted on root`);
                                allSuccess = false;
                                continue;
                            } else if (pathValidation.error && !pathValidation.node) { 
                                messages.push(pathValidation.error); 
                                allSuccess = false;
                                continue;
                            }


                            if (pathValidation.node) { 
                                if (pathValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                    messages.push(`${Config.MESSAGES.TIMESTAMP_UPDATED_PREFIX}${pathArg}${Config.MESSAGES.TIMESTAMP_UPDATED_SUFFIX}`);
                                    changesMade = true; 
                                } else if (pathValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    messages.push(`touch: cannot touch '${pathArg}': Is a directory`);
                                    allSuccess = false;
                                } else {
                                    messages.push(`touch: '${pathArg}' has an unknown or unsupported type ('${pathValidation.node.type || 'undefined'}') and cannot be touched.`);
                                    allSuccess = false;
                                }
                            } else { 
                                const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(resolvedPath);
                                if (parentDirResult.error) {
                                    messages.push(`touch: ${parentDirResult.error}`); 
                                    allSuccess = false;
                                    continue;
                                }
                                const parentNode = parentDirResult.parentNode;
                                const fileName = resolvedPath.substring(resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                                
                                if (fileName === "" && resolvedPath !== Config.FILESYSTEM.ROOT_PATH) { 
                                     messages.push(`touch: cannot create file with empty name at '${resolvedPath}'. Path might be intended as a directory.`);
                                     allSuccess = false; 
                                } else if (parentNode) { 
                                    parentNode.children[fileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: "" };
                                    messages.push(`'${pathArg}'${Config.MESSAGES.FILE_CREATED_SUFFIX}`);
                                    changesMade = true; 
                                } else {
                                    messages.push(`touch: could not create '${pathArg}', parent directory could not be determined or created.`);
                                    allSuccess = false;
                                }
                            }
                        } 

                        if (changesMade) { 
                           if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                return { success: false, error: "touch: Failed to save file system changes.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.ERROR_MSG };
                            }
                        }

                        if (!allSuccess) {
                            return { success: false, error: "touch: Not all files were touched/created successfully. See output for details.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.ERROR_MSG };
                        }
                        return { success: true, output: messages.join('\n'), messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    },
                    description: "Changes file timestamps or creates empty files.",
                    helpText: "Usage: touch <file_name>...\n\nUpdates the access and modification times of each specified file to the current time. If a file does not exist, it is created empty."
                },
                'cat': {
                    handler: async (args, options) => {
                        if (args.length === 0 && (options.stdinContent === null || options.stdinContent === undefined)) {
                            return { success: true, output: "" }; 
                        }
                        if (args.length > 0) { 
                            const validationResult = Utils.validateArguments(args, { min: 1 }); 
                            if (!validationResult.isValid) return { success: false, error: `cat: ${validationResult.errorDetail}` };
                        }
                        
                        let outputContent = "";
                        let firstFile = true;

                        if (options.stdinContent !== null && options.stdinContent !== undefined) {
                            outputContent += options.stdinContent;
                            firstFile = false; 
                        }
                        
                        for (const pathArg of args) {
                            const pathValidation = FileSystemManager.validatePath('cat', pathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE });
                            if (pathValidation.error) return { success: false, error: pathValidation.error }; 
                            
                            if (!firstFile && outputContent && !outputContent.endsWith('\n')) outputContent += "\n"; 
                            outputContent += pathValidation.node.content || "";
                            firstFile = false;
                        }
                        return { success: true, output: outputContent };
                    },
                    description: "Concatenates and displays files.",
                    helpText: "Usage: cat [file...]\n\nConcatenates files and prints their content to standard output. If no files are given, it reads from standard input (piped content)."
                },
                'rm': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [
                            { name: 'recursive', short: '-r', long: '--recursive' },
                            { name: 'recursiveAlias', short: '-R' }, 
                            { name: 'force', short: '-f', long: '--force' },
                            { name: 'interactive', short: '-i', long: '--interactive' } 
                        ]);

                        const validationResult = Utils.validateArguments(remainingArgs, { min: 1 });
                        if (!validationResult.isValid) return { success: false, error: `rm: ${validationResult.errorDetail}` };

                        const isRecursiveOpt = flags.recursive || flags.recursiveAlias;
                        const isForceOpt = flags.force;
                        const isInteractiveOpt = flags.interactive; 

                        let allSuccess = true;
                        const messages = [];
                        const currentUser = UserManager.getCurrentUser().name;
                        let changesMade = false;

                        async function removeItemRecursively(itemResolvedPath, itemNode, pathArgForMessages, isTopLevelCall = true) {
                            if (itemNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                let doPrompt = false;
                                if (isInteractiveOpt) { 
                                    doPrompt = true;
                                } else if (options.isInteractive && isTopLevelCall) { 
                                    doPrompt = true;
                                }
                                if (isForceOpt) {
                                    doPrompt = false;
                                }

                                let confirmed = true; 
                                if (doPrompt) {
                                    confirmed = await new Promise(resolve => {
                                        ConfirmationManager.request(
                                            [`Remove file '${pathArgForMessages}'?`], null, () => resolve(true), () => resolve(false)
                                        );
                                    });
                                }

                                if (confirmed) {
                                    const parentPath = itemResolvedPath.substring(0, itemResolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                                    const itemName = itemResolvedPath.substring(itemResolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                                    const parentNode = FileSystemManager.getNodeByPath(parentPath);
                                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                                        delete parentNode.children[itemName];
                                        messages.push(`${isForceOpt ? Config.MESSAGES.FORCIBLY_REMOVED_PREFIX : ''}'${pathArgForMessages}'${Config.MESSAGES.ITEM_REMOVED_SUFFIX}${isForceOpt ? Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX : ''}`);
                                        changesMade = true;
                                        return true;
                                    } else {
                                        if (!isForceOpt) { messages.push(`rm: Failed to remove '${pathArgForMessages}': Item not found in parent (internal error).`); }
                                        return false;
                                    }
                                } else {
                                    messages.push(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${pathArgForMessages}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`);
                                    return false;
                                }
                            } else if (itemNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                if (!isRecursiveOpt) {
                                    if (!isForceOpt) { messages.push(`rm: cannot remove '${pathArgForMessages}': Is a directory (specify -r, -R, or --recursive).`); }
                                    return false;
                                }

                                let doPromptForDir = false;
                                if (isInteractiveOpt) { 
                                    doPromptForDir = true;
                                } else if (options.isInteractive && isTopLevelCall) { 
                                    doPromptForDir = true;
                                }
                                if (isForceOpt) {
                                    doPromptForDir = false;
                                }

                                let confirmedDir = true; 
                                if (doPromptForDir) {
                                    const promptMsg = isTopLevelCall ?
                                        `Recursively remove directory '${pathArgForMessages}' and all its contents?` :
                                        `Remove directory '${pathArgForMessages}' (within recursive operation)?`;
                                    confirmedDir = await new Promise(resolve => {
                                        ConfirmationManager.request(
                                            [promptMsg], null, () => resolve(true), () => resolve(false)
                                        );
                                    });
                                }

                                if (!confirmedDir) {
                                    messages.push(`${Config.MESSAGES.REMOVAL_CANCELLED_PREFIX}${pathArgForMessages}${Config.MESSAGES.REMOVAL_CANCELLED_SUFFIX}`);
                                    return false;
                                }

                                const childrenNames = Object.keys(itemNode.children);
                                for (const childName of childrenNames) {
                                    if (!itemNode.children[childName]) continue;

                                    const childNode = itemNode.children[childName];
                                    const childResolvedPath = FileSystemManager.getAbsolutePath(childName, itemResolvedPath);

                                    if (!await removeItemRecursively(childResolvedPath, childNode, childResolvedPath, false)) {
                                        if (!isForceOpt) {
                                            return false; 
                                        }
                                    }
                                }

                                const parentPath = itemResolvedPath.substring(0, itemResolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                                const dirName = itemResolvedPath.substring(itemResolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                                const parentNode = FileSystemManager.getNodeByPath(parentPath);

                                if (parentNode && parentNode.children && parentNode.children[dirName]) {
                                    const currentDirNodeCheck = FileSystemManager.getNodeByPath(itemResolvedPath);
                                    if (currentDirNodeCheck && Object.keys(currentDirNodeCheck.children).length > 0 && !isForceOpt) {
                                         messages.push(`rm: cannot remove directory '${pathArgForMessages}': Directory not empty (recursive removal failed for some contents).`);
                                         return false;
                                    }
                                    delete parentNode.children[dirName];
                                    messages.push(`${isForceOpt ? Config.MESSAGES.FORCIBLY_REMOVED_PREFIX : ''}'${pathArgForMessages}' (directory)${Config.MESSAGES.ITEM_REMOVED_SUFFIX}${isForceOpt ? Config.MESSAGES.FORCIBLY_REMOVED_SUFFIX : ''}`);
                                    changesMade = true;
                                    return true;
                                } else {
                                    if (!isForceOpt) { messages.push(`rm: Failed to remove directory '${pathArgForMessages}': Directory not found in parent (internal error).`); }
                                    return false;
                                }
                            }
                            if (!isForceOpt) { messages.push(`rm: cannot remove '${pathArgForMessages}': Unknown item type.`); }
                            return false;
                        } 

                        for (const pathArg of remainingArgs) {
                            const pathValidation = FileSystemManager.validatePath('rm', pathArg, { disallowRoot: true });
                            if (pathValidation.error) {
                                if (!isForceOpt) { messages.push(pathValidation.error); allSuccess = false; }
                                continue; 
                            }
                            const node = pathValidation.node;
                            const resolvedPath = pathValidation.resolvedPath;

                            if (node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && !isRecursiveOpt) {
                                if (!isForceOpt) { messages.push(`rm: cannot remove '${pathArg}': Is a directory (specify -r, -R, or --recursive).`); }
                                allSuccess = false;
                                continue; 
                            }

                            if (!await removeItemRecursively(resolvedPath, node, pathArg, true)) {
                                allSuccess = false;
                            }
                        }

                        if (changesMade) {
                           if (!await FileSystemManager.save(currentUser)) {
                                messages.push("rm: CRITICAL - Failed to save file system changes after removal operations.");
                                return { success: false, error: "rm: Failed to save file system changes after removal.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.ERROR_MSG };
                            }
                        }

                        if (!allSuccess) {
                             return { success: false, error: "rm: Not all items were removed successfully. See output for details.", output: messages.join('\n'), messageType: isForceOpt ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.ERROR_MSG };
                        }
                        return { success: true, output: messages.join('\n'), messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    },
                    description: "Removes files or directories.",
                    helpText: "Usage: rm [-rRf] [-i] <item_path>...\n\nRemoves specified files or directories.\n  -r, -R, --recursive   Remove directories and their contents recursively.\n  -f, --force       Ignore nonexistent files and arguments, never prompt.\n  -i, --interactive Prompt before every removal (if -f is not also specified)."
                },
                'mv': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 2 });
                        if (!validationResult.isValid) return { success: false, error: `mv: ${validationResult.errorDetail}` };
                        
                        const sourcePathArg = args[0];
                        const destPathArg = args[1];

                        const sourceValidation = FileSystemManager.validatePath('mv (source)', sourcePathArg, { disallowRoot: true });
                        if (sourceValidation.error) return { success: false, error: sourceValidation.error };
                        
                        const sourceNode = sourceValidation.node;
                        const absSourcePath = sourceValidation.resolvedPath;

                        const destValidation = FileSystemManager.validatePath('mv (destination)', destPathArg, { allowMissing: true });
                        if (destValidation.error && destValidation.node && destValidation.resolvedPath !== absSourcePath) { 
                             return { success: false, error: destValidation.error };
                        }
                        
                        let absDestPath = destValidation.resolvedPath;
                        let destNode = destValidation.node;
                        const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);

                        if (destNode && destNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            absDestPath = FileSystemManager.getAbsolutePath(sourceName, absDestPath); 
                            destNode = FileSystemManager.getNodeByPath(absDestPath); 
                        }

                        if (absSourcePath === absDestPath) {
                             return { success: true, output: `mv: '${sourcePathArg}' and '${destPathArg}' are the same file. ${Config.MESSAGES.NO_ACTION_TAKEN}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                        }

                        if (destNode) {
                            if (options.explicitForce || options.isInteractive) { 
                                if (destNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && sourceNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                    return { success: false, error: `mv: cannot overwrite directory '${destPathArg}' with non-directory '${sourcePathArg}'` };
                                }
                                if (destNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE && sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                    return { success: false, error: `mv: cannot overwrite non-directory '${destPathArg}' with directory '${sourcePathArg}'` };
                                }
                                if (!options.explicitForce && options.isInteractive) {
                                    const confirmed = await new Promise(resolve => {
                                        ConfirmationManager.request(
                                            [`Overwrite '${destPathArg}'?`], null, () => resolve(true), () => resolve(false)
                                        );
                                    });
                                    if (!confirmed) return { success: true, error: Config.MESSAGES.OPERATION_CANCELLED, output: `${Config.MESSAGES.OPERATION_CANCELLED} No changes made.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                                }
                            } else if (!options.isInteractive && !options.explicitForce) { 
                                return { success: false, error: `mv: '${destPathArg}' already exists. Use -f to overwrite.` };
                            }
                        }
                        
                        if (sourceNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && absDestPath.startsWith(absSourcePath + Config.FILESYSTEM.PATH_SEPARATOR)) {
                            return { success: false, error: `mv: cannot move '${sourcePathArg}' to a subdirectory of itself, '${destPathArg}'` };
                        }

                        const destParentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absDestPath);
                        if (destParentDirResult.error) return { success: false, error: `mv: ${destParentDirResult.error}` };
                        
                        const destParentNode = destParentDirResult.parentNode;
                        const destName = absDestPath.substring(absDestPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        
                        destParentNode.children[destName] = Utils.deepCopyNode(sourceNode);

                        const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR)) || Config.FILESYSTEM.ROOT_PATH;
                        const sourceParentNode = FileSystemManager.getNodeByPath(sourceParentPath);
                        if (sourceParentNode && sourceParentNode.children && sourceParentNode.children[sourceName]) {
                            delete sourceParentNode.children[sourceName];
                        } else {
                            console.error(Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_PREFIX + sourceName + Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_MIDDLE + sourceParentPath + Config.INTERNAL_ERRORS.SOURCE_NOT_FOUND_IN_PARENT_SUFFIX);
                            if(destParentNode.children[destName]) delete destParentNode.children[destName]; 
                            return { success: false, error: `mv: Internal error - source item not found for removal after copy.` };
                        }

                        if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                            return { success: false, error: "mv: Failed to save file system changes." };
                        }
                        return { success: true, output: `${Config.MESSAGES.MOVED_PREFIX}${sourcePathArg}${Config.MESSAGES.MOVED_TO}${destPathArg}${Config.MESSAGES.MOVED_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    },
                    description: "Moves or renames files and directories.",
                    helpText: "Usage: mv [-f] <source_path> <destination_path>\n       mv [-f] <source_path>... <destination_directory>\n\nMoves (renames) <source_path> to <destination_path>, or moves one or more <source_path>(s) to <destination_directory>.\n  -f, --force   Overwrite existing files without prompting."
                },
                'cp': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [
                            { name: 'recursive', short: '-r', long: '--recursive' },
                            { name: 'force', short: '-f', long: '--force' } 
                        ]);
                        const validationResult = Utils.validateArguments(remainingArgs, { min: 2 });
                        if (!validationResult.isValid) return { success: false, error: `cp: ${validationResult.errorDetail}` };

                        const destPathArg = remainingArgs.pop(); 
                        const sourcePathArgs = remainingArgs;   

                        let allSourcesProcessedSuccessfully = true;
                        const sourcesInfo = [];
                        for (const srcArg of sourcePathArgs) {
                            const srcValidation = FileSystemManager.validatePath('cp (source)', srcArg, { disallowRoot: false }); 
                            if (srcValidation.error) {
                                OutputManager.appendToOutput(srcValidation.error, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                                allSourcesProcessedSuccessfully = false; continue; 
                            }
                            if (srcValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && !flags.recursive) {
                                OutputManager.appendToOutput(`cp: -r not specified; omitting directory '${srcArg}'`, { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                                allSourcesProcessedSuccessfully = false; continue; 
                            }
                            sourcesInfo.push({ path: srcValidation.resolvedPath, node: srcValidation.node, originalArg: srcArg });
                        }

                        if (sourcesInfo.length === 0) return { success: false, error: "cp: No valid source arguments to copy." };
                        if (!allSourcesProcessedSuccessfully && !flags.force && sourcePathArgs.length !== sourcesInfo.length) {
                             return { success: false, error: "cp: One or more source paths were invalid or omitted. Operation aborted." };
                        }


                        const destValidation = FileSystemManager.validatePath('cp (destination)', destPathArg, { allowMissing: true });
                        if (destValidation.error && destValidation.node) {
                            if (sourcesInfo.length === 1 && sourcesInfo[0].node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE && destValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            } else if (sourcesInfo.length === 1 && sourcesInfo[0].node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE && destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                return { success: false, error: `cp: cannot overwrite non-directory '${destPathArg}' with directory '${sourcesInfo[0].originalArg}'` };
                            } else if (destValidation.node.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE && sourcesInfo.some(s => s.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE)) {
                                return { success: false, error: `cp: cannot overwrite non-directory '${destPathArg}' with a directory source` };
                            } else {
                                return { success: false, error: destValidation.error };
                            }
                        }
                        
                        let absDestPath = destValidation.resolvedPath;
                        let destNode = destValidation.node;
                        let messages = [];
                        let overallCopySuccess = true; 
                        let changesMade = false;

                        let destIsDir = (destNode && destNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE);
                        if (!destNode && destPathArg.endsWith(Config.FILESYSTEM.PATH_SEPARATOR)) { 
                            destIsDir = true;
                        }
                        if (sourcesInfo.length > 1 && !destIsDir) {
                            return { success: false, error: `cp: target '${destPathArg}' is not a directory` };
                        }

                        for (const src of sourcesInfo) {
                            const sourceName = src.path.substring(src.path.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            let currentAbsDestPathForThisSource = absDestPath;
                            
                            if (destIsDir) {
                                currentAbsDestPathForThisSource = FileSystemManager.getAbsolutePath(sourceName, absDestPath);
                            }
                            
                            const existingDestItemNode = FileSystemManager.getNodeByPath(currentAbsDestPathForThisSource);

                            if (src.path === currentAbsDestPathForThisSource) {
                                 messages.push(`cp: '${src.originalArg}' and '${currentAbsDestPathForThisSource}' are the same file. ${Config.MESSAGES.NO_ACTION_TAKEN}`);
                                 continue; 
                            }

                            if (existingDestItemNode) {
                                if (!flags.force && options.isInteractive) {
                                    const confirmed = await new Promise(resolve => {
                                        ConfirmationManager.request(
                                            [`Overwrite '${currentAbsDestPathForThisSource}'?`], null, () => resolve(true), () => resolve(false)
                                        );
                                    });
                                    if (!confirmed) {
                                        messages.push(`${Config.MESSAGES.OPERATION_CANCELLED} Copy of '${src.originalArg}' to '${currentAbsDestPathForThisSource}' skipped.`);
                                        overallCopySuccess = false; continue;
                                    }
                                } else if (!flags.force && !options.isInteractive) {
                                    messages.push(`cp: '${currentAbsDestPathForThisSource}' already exists. Use -f to overwrite. Skipping copy of '${src.originalArg}'.`);
                                    overallCopySuccess = false; continue;
                                }
                            }
                            
                            const destParentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(currentAbsDestPathForThisSource);
                            if (destParentDirResult.error) {
                                messages.push(`cp: ${destParentDirResult.error} (for source '${src.originalArg}' to '${currentAbsDestPathForThisSource}')`);
                                overallCopySuccess = false; continue;
                            }
                            const destParentNode = destParentDirResult.parentNode;
                            const destName = currentAbsDestPathForThisSource.substring(currentAbsDestPathForThisSource.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            
                            destParentNode.children[destName] = Utils.deepCopyNode(src.node);
                            changesMade = true;
                            messages.push(`${Config.MESSAGES.COPIED_PREFIX}${src.originalArg}${Config.MESSAGES.COPIED_TO}'${currentAbsDestPathForThisSource}'${Config.MESSAGES.COPIED_SUFFIX}`);
                        }
                        
                        if (changesMade) {
                           if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                return { success: false, error: "cp: Failed to save file system changes after copy operations.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.ERROR_MSG };
                            }
                        }

                        if (!overallCopySuccess) {
                            return { success: false, error: "cp: Not all items were copied successfully. See output for details.", output: messages.join('\n'), messageType: Config.CSS_CLASSES.WARNING_MSG };
                        }
                        return { success: true, output: messages.join('\n'), messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                    },
                    description: "Copies files and directories.",
                    helpText: "Usage: cp [-r] [-f] <source_path> <destination_path>\n       cp [-r] [-f] <source_path>... <destination_directory>\n\nCopies <source_path> to <destination_path>, or one or more <source_path>(s) to <destination_directory>.\n  -r, --recursive   Copy directories recursively.\n  -f, --force       Overwrite existing files without prompting."
                },
                'history': {
                    handler: async (args, options) => {
                        const { flags, remainingArgs } = Utils.parseFlags(args, [{ name: 'clear', short: '-c', long: '--clear' }]);
                        if (flags.clear) {
                            HistoryManager.clearHistory();
                            return { success: true, output: "Command history cleared.", messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        }
                        const history = HistoryManager.getFullHistory();
                        if (history.length === 0) return { success: true, output: Config.MESSAGES.NO_COMMANDS_IN_HISTORY };
                        const output = history.map((cmd, i) => `  ${String(i + 1).padStart(3)}  ${cmd}`).join('\n');
                        return { success: true, output: output };
                    },
                    description: "Displays command history.",
                    helpText: "Usage: history [-c]\n\nDisplays the list of previously executed commands.\n  -c, --clear   Clears the command history."
                },
                'edit': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) return { success: false, error: `edit: ${validationResult.errorDetail}` };
                        
                        const filePathArg = args[0];
                        const pathValidation = FileSystemManager.validatePath('edit', filePathArg, { allowMissing: true, disallowRoot: true });

                        if (pathValidation.error && pathValidation.node && pathValidation.node.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                            return { success: false, error: `edit: '${filePathArg}' is a directory. Cannot edit.` };
                        }
                        if (pathValidation.error && !pathValidation.node) { 
                            return { success: false, error: pathValidation.error };
                        }
                        
                        const resolvedPath = pathValidation.resolvedPath;
                        let content = "";
                        if (pathValidation.node) { 
                            content = pathValidation.node.content || "";
                        }
                        
                        if (options.isInteractive) {
                            EditorManager.enter(resolvedPath, content);
                            return { success: true, output: `Opening editor for '${resolvedPath}'...` , messageType: Config.CSS_CLASSES.EDITOR_MSG };
                        } else {
                            return { success: false, error: "edit: Can only be run in interactive mode." };
                        }
                    },
                    description: "Opens a file in the text editor.",
                    helpText: "Usage: edit <file_path>\n\nOpens the specified file in a simple text editor. If the file does not exist, it will be created when you save."
                },
                'useradd': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) return { success: false, error: `useradd: ${validationResult.errorDetail}` };
                        const username = args[0];
                        const result = await UserManager.register(username);
                        return { ...result, messageType: result.success ? Config.CSS_CLASSES.SUCCESS_MSG : Config.CSS_CLASSES.ERROR_MSG };
                    },
                    description: "Creates a new user account.",
                    helpText: "Usage: useradd <username>\n\nRegisters a new user. Usernames must be 3-20 characters, no spaces, and not reserved."
                },
                'login': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) return { success: false, error: `login: ${validationResult.errorDetail}` };
                        const username = args[0];
                        const result = await UserManager.login(username);
                        if (result.success && !result.noAction) {
                             OutputManager.clearOutput(); 
                             OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${username}${Config.MESSAGES.WELCOME_SUFFIX}`);
                        }
                        return { success: result.success, output: result.message, error: result.success ? undefined : (result.error || "Login failed."), messageType: result.success ? Config.CSS_CLASSES.SUCCESS_MSG : Config.CSS_CLASSES.ERROR_MSG };
                    },
                    description: "Logs in as a specified user.",
                    helpText: "Usage: login <username>\n\nSwitches the current session to the specified user. Current session state is saved."
                },
                'logout': {
                    handler: async (args, options) => {
                        const result = await UserManager.logout();
                         if (result.success && !result.noAction) {
                             OutputManager.clearOutput(); 
                             OutputManager.appendToOutput(`${Config.MESSAGES.WELCOME_PREFIX}${UserManager.getCurrentUser().name}${Config.MESSAGES.WELCOME_SUFFIX}`);
                        }
                        return { ...result, output: result.message, messageType: result.success ? Config.CSS_CLASSES.SUCCESS_MSG : Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                    },
                    description: "Logs out the current user.",
                    helpText: "Usage: logout\n\nLogs out the current user and returns to the Guest session. Current session state is saved."
                },
                'whoami': {
                    handler: async (args, options) => {
                        return { success: true, output: UserManager.getCurrentUser().name };
                    },
                    description: "Displays the current username.",
                    helpText: "Usage: whoami\n\nPrints the username of the currently logged-in user."
                },
                'su': { 
                    handler: async (args, options) => {
                        if (args.length === 0) return commands.login.handler([UserManager.getDefaultUser()], options); 
                        return commands.login.handler(args, options);
                    },
                    description: "Switch user (alias for login).",
                    helpText: "Usage: su [username]\n\nSwitches to the specified user, or to Guest if no username is provided. Alias for 'login'."
                },
                'shutdown': {
                    handler: async (args, options) => {
                        if (options.isInteractive) {
                            OutputManager.appendToOutput("OopisOS is shutting down...", { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            setTimeout(() => {
                                OutputManager.clearOutput();
                                TerminalUI.setInputState(false); 
                                DOM.inputLineContainerDiv.style.visibility = 'hidden';
                                OutputManager.appendToOutput("System halted. Please refresh the page to restart.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                            }, 1000);
                        }
                        return { success: true, output: "" }; 
                    },
                    description: "Shuts down the OopisOS session.",
                    helpText: "Usage: shutdown\n\nSimulates shutting down the operating system. The terminal will become unresponsive."
                },
                'reboot': {
                     handler: async (args, options) => {
                        if (options.isInteractive) {
                            await OutputManager.appendToOutput("OopisOS is rebooting...", { typeClass: Config.CSS_CLASSES.WARNING_MSG });
                            setTimeout(() => { window.location.reload(); }, 1000);
                        }
                        return { success: true, output: "" };
                    },
                    description: "Reboots the OopisOS session.",
                    helpText: "Usage: reboot\n\nSimulates rebooting the operating system by reloading the page."
                },
                'export': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) return { success: false, error: `export: ${validationResult.errorDetail}` };
                        
                        const pathArg = args[0];
                        const pathValidation = FileSystemManager.validatePath('export', pathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };

                        const fileNode = pathValidation.node;
                        const fileName = pathValidation.resolvedPath.substring(pathValidation.resolvedPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                        
                        try {
                            const blob = new Blob([fileNode.content || ""], { type: 'text/plain;charset=utf-8' });
                            const url = URL.createObjectURL(blob);
                            const a = Utils.createElement('a', { href: url, download: fileName });
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            return { success: true, output: `${Config.MESSAGES.EXPORTING_PREFIX}${fileName}${Config.MESSAGES.EXPORTING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        } catch (e) {
                            return { success: false, error: `export: Failed to trigger download for '${fileName}': ${e.message}` };
                        }
                    },
                    description: "Exports a file from the virtual FS to the user's computer.",
                    helpText: "Usage: export <file_path>\n\nDownloads the specified file from OopisOS's file system to your actual computer."
                },
                'upload': {
                    handler: async (args, options) => {
                        if (!options.isInteractive) return { success: false, error: "upload: Can only be run in interactive mode." };
                        
                        const validationResult = Utils.validateArguments(args, { max: 1 }); 
                        if (!validationResult.isValid) return { success: false, error: `upload: ${validationResult.errorDetail}` };

                        let targetDirPath = FileSystemManager.getCurrentPath();
                        if (args.length === 1) {
                            const destPathValidation = FileSystemManager.validatePath('upload (destination)', args[0], { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE });
                            if (destPathValidation.error) return { success: false, error: destPathValidation.error };
                            targetDirPath = destPathValidation.resolvedPath;
                        }

                        const input = Utils.createElement('input', { type: 'file' });
                        input.style.display = 'none';
                        document.body.appendChild(input);

                        try {
                            const file = await new Promise((resolve, reject) => {
                                input.onchange = e => {
                                    const file = e.target.files[0];
                                    if (file) resolve(file);
                                    else reject(new Error(Config.MESSAGES.UPLOAD_NO_FILE));
                                };
                                input.click(); 
                            });

                            const allowedExtensions = ['.txt', '.md', '.html', '.sh']; 
                            const fileExt = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
                            if (!allowedExtensions.includes(fileExt)) {
                                throw new Error(`${Config.MESSAGES.UPLOAD_INVALID_TYPE_PREFIX}${fileExt}${Config.MESSAGES.UPLOAD_INVALID_TYPE_SUFFIX}`);
                            }

                            const content = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = e => resolve(e.target.result);
                                reader.onerror = e => reject(new Error(`${Config.MESSAGES.UPLOAD_READ_ERROR_PREFIX}${file.name}${Config.MESSAGES.UPLOAD_READ_ERROR_SUFFIX}`));
                                reader.readAsText(file);
                            });
                            
                            const targetPath = FileSystemManager.getAbsolutePath(file.name, targetDirPath);
                            const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(targetPath);
                            if (parentDirResult.error) throw new Error(parentDirResult.error);
                            
                            const parentNode = parentDirResult.parentNode;
                            const newFileName = targetPath.substring(targetPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                            
                            if (parentNode.children[newFileName]) {
                                if (!options.explicitForce) { 
                                    const confirmed = await new Promise(resolveInner => {
                                        ConfirmationManager.request(
                                            [`File '${newFileName}' already exists in '${targetDirPath}'. Overwrite?`],
                                            null, () => resolveInner(true), () => resolveInner(false)
                                        );
                                    });
                                    if (!confirmed) {
                                        return { success: true, output: `Upload of '${file.name}' cancelled. File not overwritten.`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                                    }
                                }
                            }

                            parentNode.children[newFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: content };
                            if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                                throw new Error("Failed to save uploaded file to FS.");
                            }
                            return { success: true, output: `${Config.MESSAGES.UPLOAD_SUCCESS_PREFIX}${file.name}${Config.MESSAGES.UPLOAD_SUCCESS_MIDDLE}${targetDirPath}${Config.MESSAGES.UPLOAD_SUCCESS_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };

                        } catch (e) {
                            return { success: false, error: `upload: ${e.message}` };
                        } finally {
                             if (input.parentNode) document.body.removeChild(input);
                        }
                    },
                    description: "Uploads a file from the user's computer to the virtual FS.",
                    helpText: "Usage: upload [destination_directory]\n\nPrompts to select a file from your computer and uploads it to OopisOS's current directory, or to the optional [destination_directory]. Allowed file types: .txt, .md, .html, .sh. Will prompt to overwrite if file exists."
                },
                'backup': {
                    handler: async (args, options) => {
                        const currentUser = UserManager.getCurrentUser();
                        const backupData = {
                            user: currentUser.name,
                            osVersion: Config.OS.VERSION,
                            timestamp: new Date().toISOString(),
                            fsDataSnapshot: Utils.deepCopyNode(FileSystemManager.getFsData()),
                        };
                        const fileName = `OopisOS_Backup_${currentUser.name}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                        try {
                            const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = Utils.createElement('a', { href: url, download: fileName });
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            return { success: true, output: `${Config.MESSAGES.BACKUP_CREATING_PREFIX}${fileName}${Config.MESSAGES.BACKUP_CREATING_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        } catch (e) {
                            return { success: false, error: `backup: Failed to generate or download backup: ${e.message}` };
                        }
                    },
                    description: "Creates a JSON backup of the current user's file system.",
                    helpText: "Usage: backup\n\nCreates a downloadable JSON file containing a snapshot of the current user's entire file system."
                },
                'restore': {
                    handler: async (args, options) => {
                        if (!options.isInteractive) return { success: false, error: "restore: Can only be run in interactive mode." };
                        
                        const input = Utils.createElement('input', { type: 'file', accept: '.json' });
                        input.style.display = 'none';
                        document.body.appendChild(input);

                        try {
                            const file = await new Promise((resolve, reject) => {
                                input.onchange = e => {
                                    const file = e.target.files[0];
                                    if (file) resolve(file);
                                    else reject(new Error(Config.MESSAGES.RESTORE_CANCELLED_NO_FILE));
                                };
                                input.click();
                            });

                            const backupData = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = e => {
                                    try { resolve(JSON.parse(e.target.result)); }
                                    catch (parseError) { reject(new Error(`Invalid JSON in backup file '${file.name}'.`)); }
                                };
                                reader.onerror = e => reject(new Error(`Error reading backup file '${file.name}'.`));
                                reader.readAsText(file);
                            });

                            if (!backupData || !backupData.fsDataSnapshot || !backupData.user) {
                                throw new Error(`Backup file '${file.name}' is not a valid OopisOS backup format (missing critical data).`);
                            }
                            
                            const targetUser = backupData.user; 
                            const currentUser = UserManager.getCurrentUser().name;
                            let message = `Restore file system from backup '${file.name}'? This will overwrite the current file system for user '${targetUser}'.`;
                            if (targetUser !== currentUser) {
                                message += `\nWARNING: This backup is for user '${targetUser}', but you are logged in as '${currentUser}'. The restored FS will belong to '${targetUser}'.`;
                            }
                            
                            const confirmed = await new Promise(resolveConf => {
                                ConfirmationManager.request(
                                    [message], null, () => resolveConf(true), () => resolveConf(false)
                                );
                            });

                            if (!confirmed) return { success: true, output: Config.MESSAGES.OPERATION_CANCELLED, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };

                            FileSystemManager.setFsData(Utils.deepCopyNode(backupData.fsDataSnapshot));
                            if (!await FileSystemManager.save(targetUser)) { 
                                throw new Error(`Could not save restored file system for user '${targetUser}'.`);
                            }
                            
                            if (currentUser === targetUser) {
                                await FileSystemManager.load(currentUser); 
                                FileSystemManager.setCurrentPath(Config.FILESYSTEM.ROOT_PATH); 
                                TerminalUI.updatePrompt();
                                OutputManager.clearOutput(); 
                            }
                            
                            return { success: true, output: `${Config.MESSAGES.RESTORE_SUCCESS_PREFIX}${targetUser}${Config.MESSAGES.RESTORE_SUCCESS_MIDDLE}${file.name}${Config.MESSAGES.RESTORE_SUCCESS_SUFFIX}`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };

                        } catch (e) {
                            return { success: false, error: `restore: ${e.message}` };
                        } finally {
                            if (input.parentNode) document.body.removeChild(input);
                        }
                    },
                    description: "Restores the file system from a JSON backup file.",
                    helpText: "Usage: restore\n\nPrompts to select a JSON backup file from your computer and restores the OopisOS file system from it. This will overwrite the existing file system for the user specified in the backup file."
                },
                'savefs': { 
                    handler: async (args, options) => {
                        const currentUser = UserManager.getCurrentUser();
                        if (await FileSystemManager.save(currentUser.name)) {
                            return { success: true, output: `File system for user '${currentUser.name}' saved.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        } else {
                            return { success: false, error: "savefs: Failed to save file system." };
                        }
                    },
                    description: "Manually saves the current user's file system state.",
                    helpText: "Usage: savefs\n\nExplicitly saves the current state of the logged-in user's file system to persistent storage."
                },
                'savestate': {
                    handler: async (args, options) => {
                        const result = await SessionManager.saveManualState();
                        return { ...result, messageType: result.success ? Config.CSS_CLASSES.SUCCESS_MSG : Config.CSS_CLASSES.ERROR_MSG };
                    },
                    description: "Saves the current terminal session (FS, output, history).",
                    helpText: "Usage: savestate\n\nManually saves the entire current terminal session, including file system, output history, and command history, for the current user. This can be restored with 'loadstate'."
                },
                'loadstate': {
                    handler: async (args, options) => {
                        const result = await SessionManager.loadManualState();
                        return { success: result.success, output: result.message, error: result.success ? undefined : (result.message || "Failed to load state."), messageType: result.success ? Config.CSS_CLASSES.CONSOLE_LOG_MSG : Config.CSS_CLASSES.ERROR_MSG };
                    },
                    description: "Loads a previously saved terminal session.",
                    helpText: "Usage: loadstate\n\nAttempts to load a manually saved session for the current user. This will prompt for confirmation as it overwrites the current session and file system."
                },
                'reset': {
                    handler: async (args, options) => {
                        if (!options.isInteractive) return { success: false, error: "reset: Can only be run in interactive mode." };
                        const confirmed = await new Promise(resolve => {
                            ConfirmationManager.request(
                                ["WARNING: This will erase ALL OopisOS data for ALL users, including file systems, saved states, and user accounts. This action cannot be undone. Are you absolutely sure?"],
                                null, () => resolve(true), () => resolve(false)
                            );
                        });
                        if (confirmed) {
                            await SessionManager.performFullReset();
                            return { success: true, output: "OopisOS has been reset to its initial state.", messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        } else {
                            return { success: true, output: `Reset cancelled. ${Config.MESSAGES.NO_ACTION_TAKEN}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                        }
                    },
                    description: "Resets all OopisOS data (users, FS, states) to factory defaults.",
                    helpText: "Usage: reset\n\nWARNING: Irreversibly erases ALL data stored by OopisOS in this browser, including all user accounts, file systems, and saved sessions. Prompts for confirmation."
                },
                'run': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { min: 1 });
                        if (!validationResult.isValid) return { success: false, error: `run: ${validationResult.errorDetail}` };
                        
                        const scriptPathArg = args[0];
                        const scriptArgs = args.slice(1); 

                        const pathValidation = FileSystemManager.validatePath('run', scriptPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };

                        const scriptNode = pathValidation.node;
                        if (!scriptNode.content) return { success: true, output: `run: Script '${scriptPathArg}' is empty.` };

                        let scriptContent = scriptNode.content;
                        if (scriptContent.startsWith("#!")) {
                            const firstLine = scriptContent.split('\n', 1)[0];
                            scriptContent = scriptContent.substring(firstLine.length + 1); 
                        }
                        
                        const rawScriptLines = scriptContent.split('\n');
                        const commandsToRun = [];
                        for (const rawLine of rawScriptLines) {
                            let processedLine = rawLine;
                            let inSingleQuote = false;
                            let inDoubleQuote = false;
                            let commentStartIndex = -1;

                            for (let i = 0; i < processedLine.length; i++) {
                                const char = processedLine[i];
                                if (char === "'" && (i === 0 || processedLine[i-1] !== '\\')) { 
                                    inSingleQuote = !inSingleQuote;
                                } else if (char === '"' && (i === 0 || processedLine[i-1] !== '\\')) { 
                                    inDoubleQuote = !inDoubleQuote;
                                } else if (char === '#' && !inSingleQuote && !inDoubleQuote) {
                                    commentStartIndex = i;
                                    break;
                                }
                            }

                            if (commentStartIndex !== -1) {
                                processedLine = processedLine.substring(0, commentStartIndex);
                            }
                            processedLine = processedLine.trim(); 

                            if (processedLine !== '') { 
                                commandsToRun.push(processedLine);
                            }
                        }

                        if (CommandExecutor.isScriptRunning() && options.isInteractive) { 
                             return { success: false, error: "run: Cannot execute a script while another is already running in interactive mode." };
                        }
                        
                        let overallScriptSuccess = true; 
                        let lastOutput = null; 
                        
                        scriptExecutionInProgress = true; 
                        if (options.isInteractive) TerminalUI.setInputState(false);

                        for (const commandLine of commandsToRun) { 
                            let processedCommandLineWithArgs = commandLine; 
                            for (let i = 0; i < scriptArgs.length; i++) {
                                const regex = new RegExp(`\\$${i + 1}`, 'g'); 
                                processedCommandLineWithArgs = processedCommandLineWithArgs.replace(regex, scriptArgs[i]);
                            }
                            processedCommandLineWithArgs = processedCommandLineWithArgs.replace(/\$@/g, scriptArgs.join(' '));
                            processedCommandLineWithArgs = processedCommandLineWithArgs.replace(/\$#/g, scriptArgs.length.toString());

                            if (processedCommandLineWithArgs.trim() === '') { 
                                continue;
                            }

                            const result = await CommandExecutor.processSingleCommand(processedCommandLineWithArgs, false);
                            if (!result.success) {
                                const scriptErrorMsg = `Script '${scriptPathArg}' error on line: ${commandLine}\nError: ${result.error || 'Unknown error in command.'}`;
                                if (options.isInteractive) { 
                                     await OutputManager.appendToOutput(scriptErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                                }
                                overallScriptSuccess = false;
                                break; 
                            }
                            lastOutput = result.output; 
                        }
                        
                        scriptExecutionInProgress = false;
                        if (options.isInteractive) TerminalUI.setInputState(true);

                        if (overallScriptSuccess) {
                            return { success: true, output: null }; 
                        } else {
                            return { success: false, error: `Script '${scriptPathArg}' failed.` }; 
                        }
                    },
                    description: "Executes a script file containing OopisOS commands.",
                    helpText: "Usage: run <script_path> [arg1 arg2 ...]\n\nExecutes the commands listed in the specified <script_path> file.\nLines starting with '#' are comments. Basic argument passing is supported:\n  $1, $2, ... : Positional arguments passed to the script.\n  $@          : All arguments as a single string.\n  $#          : Number of arguments."
                },
                 'find': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { min: 1 }); 
                        if (!validationResult.isValid) return { success: false, error: `find: ${validationResult.errorDetail}` };

                        const startPathArg = args[0];
                        const remainingArgs = args.slice(1);

                        let namePattern = null;
                        let typeFilter = null; 

                        for (let i = 0; i < remainingArgs.length; i++) {
                            if (remainingArgs[i] === '-name' && i + 1 < remainingArgs.length) {
                                namePattern = remainingArgs[i+1];
                                i++; 
                            } else if (remainingArgs[i] === '-type' && i + 1 < remainingArgs.length) {
                                typeFilter = remainingArgs[i+1].toLowerCase();
                                if (typeFilter !== 'f' && typeFilter !== 'd') {
                                    return { success: false, error: `find: unknown type '${typeFilter}' for -type (use 'f' or 'd')` };
                                }
                                i++; 
                            } else {
                                return { success: false, error: `find: unknown predicate '${remainingArgs[i]}'` };
                            }
                        }

                        const pathValidation = FileSystemManager.validatePath('find', startPathArg, { expectedType: Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE });
                        if (pathValidation.error) return { success: false, error: pathValidation.error };
                        
                        const startNode = pathValidation.node;
                        const basePath = pathValidation.resolvedPath;
                        const results = [];

                        function recurseFind(currentNode, currentPath) {
                            if (currentNode.type === Config.FILESYSTEM.DEFAULT_DIRECTORY_TYPE) {
                                if (!typeFilter || typeFilter === 'd') {
                                    if (!namePattern || currentPath.substring(currentPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1).includes(namePattern)) { 
                                        results.push(currentPath);
                                    }
                                }
                                for (const childName in currentNode.children) {
                                    const childNode = currentNode.children[childName];
                                    const childPath = FileSystemManager.getAbsolutePath(childName, currentPath);
                                    recurseFind(childNode, childPath);
                                }
                            } else if (currentNode.type === Config.FILESYSTEM.DEFAULT_FILE_TYPE) {
                                if (!typeFilter || typeFilter === 'f') {
                                     if (!namePattern || currentPath.substring(currentPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1).includes(namePattern)) {
                                        results.push(currentPath);
                                    }
                                }
                            }
                        }

                        recurseFind(startNode, basePath);
                        
                        if (results.length === 0) {
                            return { success: true, output: "" }; 
                        }
                        return { success: true, output: results.join('\n') };
                    },
                    description: "Searches for files in a directory hierarchy.",
                    helpText: "Usage: find <path> [-name pattern] [-type f|d]\n\nRecursively searches for files and directories starting from <path>.\n  -name <pattern>  Find files/dirs whose name contains <pattern> (case-sensitive substring match).\n  -type <f|d>      Filter by type: 'f' for regular file, 'd' for directory."
                },
                'delay': { 
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) {
                            return { success: false, error: `delay: ${validationResult.errorDetail}` };
                        }
                        const parsedArg = Utils.parseNumericArg(args[0], { allowFloat: false, allowNegative: false, min: 1 });
                        if (parsedArg.error) {
                            return { success: false, error: `delay: Invalid delay time '${args[0]}': ${parsedArg.error}. Must be a positive integer.` };
                        }
                        const ms = parsedArg.value;
                        if (options.isInteractive && !scriptExecutionInProgress) { 
                             OutputManager.appendToOutput(`Delaying for ${ms}ms...`, {typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG});
                        }
                        return new Promise(resolve => {
                            setTimeout(() => {
                                if (options.isInteractive && !scriptExecutionInProgress) {
                                    OutputManager.appendToOutput(`Delay complete.`, {typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG});
                                }
                                resolve({ success: true, output: "" });
                            }, ms);
                        });
                    },
                    description: "Pauses execution for a specified time.",
                    helpText: "Usage: delay <milliseconds>\n\nPauses command execution for the specified number of milliseconds. Useful in scripts."
                },
                'check_fail': {
                    handler: async (args, options) => {
                        if (args.length !== 1) {
                            return { success: false, error: "check_fail: expects exactly one argument (a command string)" };
                        }
                        const commandToTest = args[0];
                        if (typeof commandToTest !== 'string' || commandToTest.trim() === "") {
                            return { success: false, error: "check_fail: command string argument cannot be empty" };
                        }
                        const testResult = await CommandExecutor.processSingleCommand(commandToTest, false);

                        if (testResult.success) {
                            const failureMessage = `CHECK_FAIL: FAILURE - Command <${commandToTest}> unexpectedly SUCCEEDED.`;
                            return { success: false, error: failureMessage };
                        } else {
                            const successMessage = `CHECK_FAIL: SUCCESS - Command <${commandToTest}> failed as expected. (Error: ${testResult.error || 'N/A'})`;
                            return { success: true, output: successMessage };
                        }
                    },
                    description: "Tests if a given command string fails, as expected for negative test cases.",
                    helpText: "Usage: check_fail \"<command_string>\"\n\nExecutes the <command_string>. If <command_string> fails, check_fail succeeds (and the script continues).\nIf <command_string> succeeds, check_fail fails (and the script halts), reporting the unexpected success."
                },
                'register': { 
                    handler: async (args, options) => {
                        if (commands.useradd && typeof commands.useradd.handler === 'function') {
                            return commands.useradd.handler(args, options);
                        } else {
                            return { success: false, error: "register: Critical error - useradd command functionality not found." };
                        }
                    },
                    description: "Alias for useradd. Creates a new user account.",
                    helpText: "Usage: register <username>\n\n(Alias for 'useradd') Registers a new user. Usernames must be 3-20 characters, no spaces, and not reserved (e.g., 'guest', 'root')."
                },
                'removeuser': {
                    handler: async (args, options) => {
                        const validationResult = Utils.validateArguments(args, { exact: 1 });
                        if (!validationResult.isValid) {
                            return { success: false, error: `removeuser: ${validationResult.errorDetail}` };
                        }

                        const usernameToDelete = args[0];
                        const currentUser = UserManager.getCurrentUser();

                        if (currentUser.name === usernameToDelete) {
                            return { success: false, error: `removeuser: Cannot remove the currently logged-in user ('${usernameToDelete}'). Please logout first.` };
                        }

                        if (Config.USER.RESERVED_USERNAMES.includes(usernameToDelete.toLowerCase()) || usernameToDelete === Config.USER.DEFAULT_NAME) {
                            return { success: false, error: `removeuser: Cannot remove reserved user '${usernameToDelete}'.` };
                        }

                        const users = StorageManager.loadItem(Config.STORAGE_KEYS.USER_CREDENTIALS, "User list", {});
                        if (!users[usernameToDelete]) {
                            return { success: false, error: `removeuser: User '${usernameToDelete}' not found.` };
                        }

                        const confirmed = await new Promise(resolve => {
                            ConfirmationManager.request(
                                [`WARNING: This will permanently delete user '${usernameToDelete}' and all their data (files, saved states). This action cannot be undone. Are you absolutely sure?`],
                                null,
                                () => resolve(true), 
                                () => resolve(false) 
                            );
                        });

                        if (!confirmed) {
                            return { success: true, output: `User removal for '${usernameToDelete}' cancelled. ${Config.MESSAGES.NO_ACTION_TAKEN}`, messageType: Config.CSS_CLASSES.CONSOLE_LOG_MSG };
                        }

                        let allDeletionsSuccessful = true;
                        let errorMessages = [];

                        delete users[usernameToDelete];
                        if (!StorageManager.saveItem(Config.STORAGE_KEYS.USER_CREDENTIALS, users, "User list")) {
                            errorMessages.push(`Failed to update user credentials list after removing '${usernameToDelete}'.`);
                            allDeletionsSuccessful = false;
                        }

                        try {
                            await FileSystemManager.deleteUserFS(usernameToDelete);
                        } catch (fsError) {
                            console.error(`Error deleting filesystem for ${usernameToDelete}:`, fsError);
                            errorMessages.push(`Failed to delete file system for '${usernameToDelete}'.`);
                            allDeletionsSuccessful = false;
                        }

                        if (!SessionManager.clearUserSessionStates(usernameToDelete)) {
                            errorMessages.push(`Failed to clear all session states for '${usernameToDelete}'.`);
                            allDeletionsSuccessful = false;
                        }

                        if (allDeletionsSuccessful) {
                            return { success: true, output: `User '${usernameToDelete}' and all associated data successfully removed.`, messageType: Config.CSS_CLASSES.SUCCESS_MSG };
                        } else {
                            return { success: false, error: `removeuser: Failed to completely remove user '${usernameToDelete}'. Errors: ${errorMessages.join('; ')}`, messageType: Config.CSS_CLASSES.ERROR_MSG };
                        }
                    },
                    description: "Removes a user account and all associated data.",
                    helpText: "Usage: removeuser <username>\n\nPermanently deletes the specified user account, their file system, and any saved session states. This action is irreversible and requires confirmation.\nYou cannot remove the currently logged-in user or reserved system users."
                }
            }; 

            async function _executeCommandHandler(segment, executionContextOptions, stdinContent = null) { 
                const commandData = commands[segment.command.toLowerCase()];
                const { isInteractive } = executionContextOptions; 
                
                if (commandData && typeof commandData.handler === 'function') {
                    try {
                        const explicitForce = segment.args.includes('-f') || segment.args.includes('--force');
                        const optionsForHandler = {
                            isInteractive: isInteractive,
                            explicitForce: explicitForce,
                            stdinContent: stdinContent 
                        };
                        return await commandData.handler(segment.args, optionsForHandler);
                    } catch (e) { 
                        console.error(`Error in command handler for '${segment.command}':`, e);
                        return { success: false, error: `Command '${segment.command}' failed: ${e.message || "Unknown error"}` };
                    }
                } else if (segment.command) { 
                    return { success: false, error: `${segment.command}: command not found` };
                } else { 
                    return { success: true, output: "" }; 
                }
            }
            
            async function _executePipeline(pipeline, isInteractive) {
                let currentStdinContent = null;
                let lastCommandResult = { success: true, output: "" }; 

                for (let i = 0; i < pipeline.segments.length; i++) {
                    const segment = pipeline.segments[i];
                    const executionContextOptions = { isInteractive };
                    
                    lastCommandResult = await _executeCommandHandler(segment, executionContextOptions, currentStdinContent);

                    if (!lastCommandResult.success) {
                        const errorMsg = `${Config.MESSAGES.PIPELINE_ERROR_PREFIX}'${segment.command}': ${lastCommandResult.error || "Unknown pipeline error"}`;
                        if (!pipeline.isBackground) { 
                             await OutputManager.appendToOutput(errorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        } else {
                            console.log(`Info: Background process pipeline error: ${errorMsg}`); 
                        }
                        return { success: false, error: errorMsg }; 
                    }
                    currentStdinContent = lastCommandResult.output; 
                }
                
                if (pipeline.redirection && lastCommandResult.success) {
                    const { type: redirType, file: redirFile } = pipeline.redirection;
                    const outputToRedirect = lastCommandResult.output || "";
                    
                    const redirValidation = FileSystemManager.validatePath('redirection', redirFile, { 
                        expectedType: Config.FILESYSTEM.DEFAULT_FILE_TYPE, 
                        allowMissing: true, 
                        disallowRoot: true, 
                        defaultToCurrentIfEmpty: false 
                    });

                    if (redirValidation.error) {
                        const redirErrorMsg = redirValidation.error;
                        if (!pipeline.isBackground) await OutputManager.appendToOutput(redirErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        return { success: false, error: redirErrorMsg };
                    }

                    const absRedirectPath = redirValidation.resolvedPath;
                    const parentDirResult = FileSystemManager.createParentDirectoriesIfNeeded(absRedirectPath);

                    if (parentDirResult.error) {
                        const parentErrorMsg = `Redirection error: ${parentDirResult.error}`;
                        if (!pipeline.isBackground) await OutputManager.appendToOutput(parentErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        return { success: false, error: parentErrorMsg };
                    }
                    
                    const parentNode = parentDirResult.parentNode;
                    const redirectFileName = absRedirectPath.substring(absRedirectPath.lastIndexOf(Config.FILESYSTEM.PATH_SEPARATOR) + 1);
                    let existingContent = "";
                    if (redirType === 'append' && parentNode.children[redirectFileName]) {
                        existingContent = parentNode.children[redirectFileName].content || "";
                        if (existingContent && !existingContent.endsWith('\n') && outputToRedirect.length > 0) existingContent += '\n'; 
                    }
                    parentNode.children[redirectFileName] = { type: Config.FILESYSTEM.DEFAULT_FILE_TYPE, content: existingContent + outputToRedirect };
                    
                    if (!await FileSystemManager.save(UserManager.getCurrentUser().name)) {
                        const saveErrorMsg = `Failed to save redirected output to '${redirFile}'.`;
                        if (!pipeline.isBackground) await OutputManager.appendToOutput(saveErrorMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                        return { success: false, error: saveErrorMsg };
                    }
                    lastCommandResult.output = null; 
                }
                
                if (!pipeline.redirection && lastCommandResult.success && lastCommandResult.output !== null && lastCommandResult.output !== undefined) {
                    if (!pipeline.isBackground) { 
                        if (lastCommandResult.output) await OutputManager.appendToOutput(lastCommandResult.output, { typeClass: lastCommandResult.messageType || null });
                    } else {
                        if (lastCommandResult.output) { 
                             await OutputManager.appendToOutput(`${Config.MESSAGES.BACKGROUND_PROCESS_OUTPUT_SUPPRESSED} (Job ${pipeline.jobId})`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG, isBackground: true });
                        }
                    }
                }
                return lastCommandResult; 
            }


            async function _finalizeInteractiveModeUI(originalCommandText) { 
                TerminalUI.clearInput(); 
                TerminalUI.updatePrompt(); 
                DOM.inputLineContainerDiv.style.visibility = 'visible'; 
                TerminalUI.focusInput(); 
                DOM.outputDiv.scrollTop = DOM.outputDiv.scrollHeight; 
                if (!TerminalUI.getIsNavigatingHistory() && originalCommandText.trim() !== "") {
                    HistoryManager.resetIndex();
                }
                TerminalUI.setIsNavigatingHistory(false); 
            }

            async function processSingleCommand(rawCommandText, isInteractive = true) {
                let finalPipelineResult = { success: true, output: null, error: null };
                
                if (scriptExecutionInProgress && isInteractive) {
                    return { success: false, error: "Script execution in progress. Input suspended."};
                }

                if (EditorManager.isActive()) return finalPipelineResult; 
                if (ConfirmationManager.isAwaiting()) { 
                    await ConfirmationManager.handleConfirmation(rawCommandText); 
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                    return finalPipelineResult; 
                }
                
                const commandToEcho = rawCommandText.trim(); 
                
                if (isInteractive) { 
                    DOM.inputLineContainerDiv.style.visibility = 'hidden'; 
                    const promptText = `${DOM.promptUserSpan.textContent}${Config.TERMINAL.PROMPT_AT}${DOM.promptHostSpan.textContent}${Config.TERMINAL.PROMPT_SEPARATOR}${DOM.promptPathSpan.textContent}${Config.TERMINAL.PROMPT_CHAR} `; 
                    await OutputManager.appendToOutput(`${promptText}${commandToEcho}`); 
                }

                if (commandToEcho === '') { 
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                    return finalPipelineResult; 
                }
                if (isInteractive) HistoryManager.add(rawCommandText.trim());
                if (isInteractive && !TerminalUI.getIsNavigatingHistory()) HistoryManager.resetIndex();
                
                let parsedPipeline;
                try { 
                    const lexer = new Lexer(rawCommandText); 
                    const tokens = lexer.tokenize(); 
                    const parser = new Parser(tokens); 
                    parsedPipeline = parser.parse(); 
                    if (parsedPipeline.segments.length === 0 && !parsedPipeline.isBackground && !parsedPipeline.redirection) {
                        if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText);
                        return { success: true, output: "" }; 
                    }
                } catch (e) { 
                    const errMsg = e.message || "Command parsing error.";
                    await OutputManager.appendToOutput(errMsg, { typeClass: Config.CSS_CLASSES.ERROR_MSG }); 
                    if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                    return { success: false, error: errMsg }; 
                }
                
                const execute = async () => {
                    return await _executePipeline(parsedPipeline, isInteractive);
                };

                if (parsedPipeline.isBackground) {
                    backgroundProcessIdCounter++;
                    parsedPipeline.jobId = backgroundProcessIdCounter; 
                    await OutputManager.appendToOutput(`${Config.MESSAGES.BACKGROUND_PROCESS_STARTED_PREFIX}${parsedPipeline.jobId}${Config.MESSAGES.BACKGROUND_PROCESS_STARTED_SUFFIX}`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });
                    setTimeout(async () => {
                        const bgResult = await execute();
                        if (!bgResult.success) {
                            console.log(`Info: Background job ${parsedPipeline.jobId} (${parsedPipeline.segments.map(s=>s.command).join(' | ')}) completed with error: ${bgResult.error || 'Unknown background error'}`);
                             OutputManager.appendToOutput(`[Job ${parsedPipeline.jobId} finished with error]`, { typeClass: Config.CSS_CLASSES.WARNING_MSG, isBackground: true });
                        } else {
                             OutputManager.appendToOutput(`[Job ${parsedPipeline.jobId} finished]`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG, isBackground: true });
                        }
                    }, 0);
                    finalPipelineResult = { success: true, output: null }; 
                } else {
                    finalPipelineResult = await execute();
                }
                
                if (isInteractive) await _finalizeInteractiveModeUI(rawCommandText); 
                return finalPipelineResult;
            }

            function getCommands() { 
                return commands;
            }

            function isScriptRunning() { 
                return scriptExecutionInProgress;
            }

            return {
                processSingleCommand,
                getCommands,
                isScriptRunning 
            };
        })();

        // --- TERMINAL EVENT LISTENERS INITIALIZATION ---
        function initializeTerminalEventListeners() { 
            DOM.terminalDiv.addEventListener('click', e => { 
                if (EditorManager.isActive()) return; 
                if (CommandExecutor.isScriptRunning()) return; 
                if (!e.target.closest('button, a') && (!DOM.editableInputDiv || !DOM.editableInputDiv.contains(e.target))) {
                    TerminalUI.focusInput();
                }
            });
            
            const getCurrentInputTarget = () => DOM.editableInputDiv;

            document.addEventListener('keydown', async e => {
                if (CommandExecutor.isScriptRunning()) {
                    if (e.key === "Enter" || e.key === "Tab" || e.key.startsWith("Arrow")) {
                        e.preventDefault();
                    }
                    return; 
                }

                if (EditorManager.isActive()) return; 
                const activeInputTarget = getCurrentInputTarget();
                if (!activeInputTarget || (document.activeElement !== activeInputTarget && !activeInputTarget.contains(document.activeElement))) {
                    return;
                }

                TerminalUI.setIsNavigatingHistory(false); 
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    const commandText = TerminalUI.getCurrentInputValue(); 
                    await CommandExecutor.processSingleCommand(commandText, true); 
                } else if (e.key === 'ArrowUp') { 
                    e.preventDefault(); 
                    const prevCommand = HistoryManager.getPrevious(); 
                    if (prevCommand !== null) { 
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(prevCommand, true); 
                    } 
                } else if (e.key === 'ArrowDown') { 
                    e.preventDefault(); 
                    const nextCommand = HistoryManager.getNext(); 
                    if (nextCommand !== null) { 
                        TerminalUI.setIsNavigatingHistory(true); 
                        TerminalUI.setCurrentInputValue(nextCommand, true); 
                    } 
                } else if (e.key === 'Tab') { 
                    e.preventDefault();
                    const currentInput = TerminalUI.getCurrentInputValue();
                    const sel = window.getSelection();
                    let cursorPos = 0;
                    if (sel.rangeCount > 0) {
                        const range = sel.getRangeAt(0);
                        if (DOM.editableInputDiv.contains(range.commonAncestorContainer)) {
                             const preCaretRange = range.cloneRange();
                             preCaretRange.selectNodeContents(DOM.editableInputDiv);
                             preCaretRange.setEnd(range.endContainer, range.endOffset);
                             cursorPos = preCaretRange.toString().length;
                        } else {
                            cursorPos = currentInput.length; 
                        }
                    } else {
                         cursorPos = currentInput.length; 
                    }
                    const result = TabCompletionManager.getSuggestions(currentInput, cursorPos);
                    if (result && result.textToInsert !== null) {
                        TerminalUI.setCurrentInputValue(result.textToInsert, false); 
                        TerminalUI.setCaretPosition(DOM.editableInputDiv, result.newCursorPos); 
                    }
                }
            });
            if (DOM.editableInputDiv) { 
                DOM.editableInputDiv.addEventListener('paste', e => { 
                    e.preventDefault(); 
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain'); 
                    document.execCommand('insertText', false, text.replace(/\r?\n|\r/g, ' ')); 
                }); 
            }
        }
        
        // --- INITIALIZATION ON WINDOW LOAD ---
        window.onload = async () => {
            DOM = {
                terminalDiv: document.getElementById('terminal'),
                outputDiv: document.getElementById('output'),
                inputLineContainerDiv: document.getElementById('terminal').querySelector('.input-line-container'),
                promptContainerDiv: document.getElementById('terminal').querySelector('.prompt-container'),
                editableInputContainerDiv: document.getElementById('editable-input-container'),
                editableInputDiv: document.getElementById('editable-input'),
                promptUserSpan: document.getElementById('prompt-user'),
                promptPathSpan: document.getElementById('prompt-path'),
                promptHostSpan: document.getElementById('prompt-host')
            };

            if (typeof Utils === 'undefined' || typeof OutputManager === 'undefined' || typeof OutputManager.initializeConsoleOverrides !== 'function') {
                const originalConsoleError = window.console.error; 
                originalConsoleError("FATAL: Core modules (Utils or OutputManager) not defined! Cannot proceed.");
                alert("FATAL ERROR: Core modules failed to load. Check console.");
                return; 
            }
            OutputManager.initializeConsoleOverrides();
            
            try {
                await OutputManager.appendToOutput("User accounts are now passwordless."); 
            
                if (typeof IndexedDBManager === 'undefined' || typeof IndexedDBManager.init !== 'function') {
                     await OutputManager.appendToOutput("FATAL: IndexedDBManager not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                     console.error("FATAL: IndexedDBManager or IndexedDBManager.init is not defined!");
                     alert("FATAL ERROR: IndexedDBManager module failed to load. Check console.");
                     return;
                }
                await IndexedDBManager.init(); 
                
                if (typeof UserManager === 'undefined' || typeof UserManager.getDefaultUser !== 'function') {
                    await OutputManager.appendToOutput("FATAL: UserManager not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                    console.error("FATAL: UserManager or UserManager.getDefaultUser is not defined!");
                    alert("FATAL ERROR: UserManager module failed to load. Check console.");
                    return;
                }
                const guestUser = { name: UserManager.getDefaultUser() };
                UserManager.setCurrentUserObject(guestUser);
                
                if (typeof FileSystemManager === 'undefined' || typeof SessionManager === 'undefined' || typeof TabCompletionManager === 'undefined') { 
                     await OutputManager.appendToOutput("FATAL: Core logic module (FileSystem, Session, or TabCompletion) not ready.", { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                     console.error("FATAL: FileSystemManager, SessionManager, or TabCompletionManager is not defined!");
                     alert("FATAL ERROR: Core logic module failed to load. Check console.");
                     return;
                }
                await FileSystemManager.load(UserManager.getDefaultUser()); 
                SessionManager.loadAutomaticState(UserManager.getDefaultUser()); 
                
                initializeTerminalEventListeners(); 
                TerminalUI.focusInput(); 
                
                console.log(`${Config.OS.NAME} v.${Config.OS.VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load (main try-catch):", error, error.stack); 
                if (DOM && DOM.outputDiv && OutputManager && typeof OutputManager.appendToOutput === 'function') { 
                     OutputManager.appendToOutput(`FATAL ERROR (onload): ${error.message}. Check console.`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
                } else {
                    alert(`FATAL ERROR (onload): ${error.message}. DOM.outputDiv is null or OutputManager not ready. Check console.`);
                }
            }
        };
    </script>
</body>
</html>