<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOs v.0.2.5</title> <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
        }

        .input-line { display: flex; align-items: center; width: 100%; }
        .prompt-user { margin-right: 2px; color: #7fdbff; }
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #visual-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        #input-before-cursor, #input-after-cursor {
            white-space: pre;
            display: inline-block;
        }
        .cursor {
            width: 10px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #hidden-input { position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .file-item { }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }

        /* Editor specific styles */
        #editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #editor-textarea {
            flex-grow: 1;
            width: 100%;
            background-color: #0c0c0c;
            color: #00dd00;
            border: 1px solid #222;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            resize: none;
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 4px;
            overflow-y: auto;
        }
        #editor-instructions {
            padding: 5px 0;
            font-size: 0.9em;
            text-align: center;
            color: #aaa;
            flex-shrink: 0;
        }
        .diag-output-block {
        }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line">
                <span id="prompt-user" class="prompt-user"></span>
                <span class="prompt-separator">@</span>
                <span id="prompt-host" class="prompt-host">OopisOs</span>
                <span class="prompt-separator">:</span>
                <span id="prompt-path" class="prompt-path"></span>
                <span class="prompt-char">&gt;</span>
                <div id="visual-input-container">
                    <span id="input-before-cursor"></span>
                    <div class="cursor"></div>
                    <span id="input-after-cursor"></span>
                </div>
            </div>
            <input type="text" id="hidden-input" autofocus autocapitalize="none" autocorrect="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const terminalDiv = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const standardInputLineDiv = terminalDiv.querySelector('.input-line');
        const inputBeforeCursorSpan = document.getElementById('input-before-cursor');
        const inputAfterCursorSpan = document.getElementById('input-after-cursor');
        const hiddenInput = document.getElementById('hidden-input');
        const promptUserSpan = document.getElementById('prompt-user');
        const promptPathSpan = document.getElementById('prompt-path');
        const promptHostSpan = document.getElementById('prompt-host');

        // --- Constants ---
        const USER_CREDENTIALS_KEY = 'oopisOsUserCredentials';
        const USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsUserTerminalState_';
        const MANUAL_USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsManualUserTerminalState_';
        const DEFAULT_USER = "Guest";
        const OS_NAME = "OopisOs";
        const OS_VERSION = "0.2.5.0"; // Version remains same for this refactor
        const MAX_HISTORY_SIZE = 50;

        // IndexedDB Constants
        const DB_NAME = "OopisOsDB";
        const DB_VERSION = 1;
        const FS_STORE_NAME = "FileSystemsStore";
        let db;

        // --- CSS Classes ---
        const CSS_ERROR_MSG = 'error-message';
        const CSS_SUCCESS_MSG = 'success-message';
        const CSS_CONSOLE_LOG_MSG = 'console-log-message';
        const CSS_WARNING_MSG = 'warning-message';
        const CSS_DIR_ITEM = 'directory-item';
        const CSS_FILE_ITEM = 'file-item';
        const CSS_HELP_CMD_NAME = 'help-command-name';
        const CSS_HELP_DESC = 'help-description';
        const CSS_OUTPUT_LINE = 'output-line';
        const CSS_MAN_SECTION_TITLE = 'man-section-title';
        const CSS_MAN_SECTION_CONTENT = 'man-section-content';
        const CSS_MAN_EXAMPLE = 'man-example';
        const CSS_SYSMON_LABEL = 'sysmon-label';

        // --- Application State ---
        let fsData = {};
        let currentPath = '/';
        let currentUser = DEFAULT_USER;
        let awaitingResetConfirmation = false;
        let awaitingLoadstateConfirmation = false;
        let awaitingRmConfirmation = false;
        let itemToRemovePath = null;
        let pendingManualStateToLoad = null;
        let commandHistory = [];
        let historyIndex = 0;
        let lastCommandFailed = false;
        let isPasswordInputActive = false;
        let passwordMaskStartIndex = -1;
        let isEditingFile = false;
        let editingFilePath = null;
        let editorWrapperDiv = null;
        let editorTextareaElement = null;
        let editorInstructionsDiv = null;
        let isRunningDiag = false;
        let isNavigatingHistory = false;
        let awaitingImportConfirmation = false;
        let pendingImportData = null;


        // --- Helper to format console arguments ---
        function formatConsoleArgs(args) {
            return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
        }

        // --- Output Management ---
        function appendToOutput(text, isError = false, typeClass = null) {
            if (isEditingFile && typeClass !== 'editor-message' && typeClass !== 'diag-output') return;
            const newLine = document.createElement('div');
            newLine.classList.add(CSS_OUTPUT_LINE);
            if (typeClass) newLine.classList.add(typeClass);
            if (isError && !typeClass) newLine.classList.add(CSS_ERROR_MSG);
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
            outputDiv.scrollTop = outputDiv.scrollHeight;
            if(isError) lastCommandFailed = true;
        }
        function appendHtmlToOutput(htmlContent) {
             if (isEditingFile) return;
             const blockDiv = document.createElement('div');
             blockDiv.innerHTML = htmlContent;
             outputDiv.appendChild(blockDiv);
             outputDiv.scrollTop = outputDiv.scrollHeight;
        }
        function appendStyledOutput(label, value) {
            if (isEditingFile) return;
            const line = document.createElement('div');
            line.classList.add(CSS_OUTPUT_LINE);
            const labelSpan = document.createElement('span');
            labelSpan.classList.add(CSS_SYSMON_LABEL);
            labelSpan.textContent = label.padEnd(20, ' ');
            const valueSpan = document.createElement('span');
            valueSpan.textContent = value;
            line.appendChild(labelSpan);
            line.appendChild(valueSpan);
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        // --- Console Output Redirection ---
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        console.log = (...args) => { if (!isEditingFile) appendToOutput(`LOG: ${formatConsoleArgs(args)}`, false, CSS_CONSOLE_LOG_MSG); originalConsoleLog.apply(console, args); };
        console.warn = (...args) => { if (!isEditingFile) appendToOutput(`WARN: ${formatConsoleArgs(args)}`, false, CSS_WARNING_MSG); originalConsoleWarn.apply(console, args); };
        console.error = (...args) => { if (!isEditingFile) appendToOutput(`ERROR: ${formatConsoleArgs(args)}`, true, CSS_ERROR_MSG); originalConsoleError.apply(console, args); };

        // --- Unified LocalStorage Helpers (for non-filesystem data) ---
        function loadJSONFromStorage(key, itemName, defaultValue = null) {
            try {
                const storedValue = localStorage.getItem(key);
                if (storedValue) return JSON.parse(storedValue);
            } catch (e) {
                if(!isRunningDiag) appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, false, CSS_WARNING_MSG);
            }
            return defaultValue;
        }
        function saveJSONToStorage(key, data, itemName) {
            try { localStorage.setItem(key, JSON.stringify(data)); return true; }
            catch (e) {
                if(!isRunningDiag) appendToOutput(`Critical Error: Could not save ${itemName} for '${key}'.`, true, CSS_ERROR_MSG);
            }
            return false;
        }

        // --- IndexedDB Initialization ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(FS_STORE_NAME)) {
                        dbInstance.createObjectStore(FS_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    if (!isRunningDiag && !window.diagInitialized) {
                        appendToOutput("FileSystem DB initialized.", false, CSS_CONSOLE_LOG_MSG);
                        window.diagInitialized = true;
                    }
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("Database error: ", event.target.error);
                    appendToOutput("Critical Error: Could not initialize FileSystem DB.", true, CSS_ERROR_MSG);
                    reject(event.target.error);
                };
            });
        }

        // --- Filesystem Management (IndexedDB) ---
        function getFileSystemKey(user) { return `fs_${user}`; }

        async function initializeFileSystem(user = currentUser) {
            fsData = { '/': { type: 'directory', children: {} } };
            await saveFileSystemData(user);
        }

        async function saveFileSystemData(user = currentUser) {
            if (!db) {
                if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for saving.", true, CSS_ERROR_MSG);
                return Promise.reject("DB not initialized");
            }
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.put({ id: getFileSystemKey(user), data: deepCopyNode(fsData) });
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error saving FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user}.`, true, CSS_ERROR_MSG);
                        reject(event.target.error);
                    };
                } catch (e) {
                    console.error(`Error initiating save transaction for ${user}:`, e);
                    if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user} (transaction error).`, true, CSS_ERROR_MSG);
                    reject(e);
                }
            });
        }

        async function loadFileSystemData(user) {
            if (!db) {
                 if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for loading.", true, CSS_ERROR_MSG);
                fsData = { '/': { type: 'directory', children: {} } };
                return Promise.reject("DB not initialized");
            }
            return new Promise(async (resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.get(getFileSystemKey(user));
                    request.onsuccess = async (event) => {
                        const result = event.target.result;
                        if (result && result.data && result.data['/']?.type === 'directory') {
                            fsData = result.data;
                        } else {
                            if (!isRunningDiag) appendToOutput(result ? `Invalid FS for ${user}. Reinitializing.` : `No FS for ${user}. Initializing.`, false, result ? CSS_WARNING_MSG : CSS_CONSOLE_LOG_MSG);
                            await initializeFileSystem(user);
                        }
                        resolve();
                    };
                    request.onerror = async (event) => {
                        console.error(`Error loading FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted or unavailable. Initializing new FS.`, false, CSS_WARNING_MSG);
                        await initializeFileSystem(user);
                        reject(event.target.error);
                    };
                } catch (e) {
                     console.error(`Error initiating load transaction for ${user}:`, e);
                     if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted (transaction error). Initializing new FS.`, false, CSS_WARNING_MSG);
                     await initializeFileSystem(user);
                     reject(e);
                }
            });
        }

        async function deleteFileSystemData(user) {
            if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(FS_STORE_NAME);
                const request = store.delete(getFileSystemKey(user));
                request.onsuccess = () => resolve(true);
                request.onerror = (event) => {
                    console.error(`Error deleting FS for ${user}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // --- Visual Input Update ---
        function updateVisualInput() {
            const inputValue = hiddenInput.value;
            const cursorPos = hiddenInput.selectionStart;
            let visualString = inputValue;
            if (isPasswordInputActive && passwordMaskStartIndex !== -1) {
                if (inputValue.length > passwordMaskStartIndex) {
                    const prefix = inputValue.substring(0, passwordMaskStartIndex);
                    const suffixToMask = inputValue.substring(passwordMaskStartIndex);
                    visualString = prefix + '*'.repeat(suffixToMask.length);
                }
            }
            inputBeforeCursorSpan.textContent = visualString.substring(0, cursorPos);
            inputAfterCursorSpan.textContent = visualString.substring(cursorPos);
        }

        // --- Automatic Session State (UI only - localStorage) ---
        function getAutomaticSessionStateKey(user) { return `${USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }
        function saveAutomaticSessionState() {
             const autoState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value };
            saveJSONToStorage(getAutomaticSessionStateKey(currentUser), autoState, `Auto session for ${currentUser}`);
        }
        function loadAutomaticSessionState(user = currentUser) {
            const autoState = loadJSONFromStorage(getAutomaticSessionStateKey(user), `Auto session for ${user}`);
            if (autoState) {
                currentPath = autoState.currentPath || '/';
                if (!isRunningDiag && autoState.hasOwnProperty('outputHTML')) {
                     outputDiv.innerHTML = autoState.outputHTML || '';
                } else if (!isRunningDiag && !autoState.hasOwnProperty('outputHTML')) {
                }
                hiddenInput.value = autoState.currentInput || '';
            } else {
                if (!isRunningDiag) outputDiv.innerHTML = '';
                hiddenInput.value = ''; currentPath = '/';
                if (!isRunningDiag) {
                    appendToOutput(`Welcome, ${user}! Type 'help' for commands.`, false, CSS_CONSOLE_LOG_MSG);
                }
            }
            updateVisualInput();
            updatePrompt();
            if (!isRunningDiag) outputDiv.scrollTop = outputDiv.scrollHeight;
            return !!autoState;
        }

        // --- Manual Save State (fsDataSnapshot will be from memory) ---
        function getManualUserTerminalStateKey(user) { return `${MANUAL_USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }

        // --- Path and Node Utilities ---
        function getAbsolutePath(targetPath, basePath) {
            if (!targetPath) targetPath = '.';
            if (targetPath.startsWith('/')) basePath = '/';

            const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s && s !== '.');
            let resolvedSegments = [...baseSegments];
            const targetSegments = targetPath.split('/');

            for (const segment of targetSegments) {
                if (segment === '' || segment === '.') {
                    if (targetPath.startsWith('/') && resolvedSegments.length === 0 && segment === '') {}
                    continue;
                }
                if (segment === '..') {
                    if (resolvedSegments.length > 0) {
                        resolvedSegments.pop();
                    }
                } else {
                    resolvedSegments.push(segment);
                }
            }
            if (targetPath.startsWith('/') && resolvedSegments.length === 0) return '/';
            return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/');
        }
        function getNodeByPath(path) {
             if (path === '/') return fsData['/'];
            const segments = path.substring(1).split('/').filter(s => s);
            let currentNode = fsData['/'];
            for (const segment of segments) {
                if (currentNode && currentNode.type === 'directory' && currentNode.children && currentNode.children[segment]) {
                    currentNode = currentNode.children[segment];
                } else return null;
            }
            return currentNode;
        }
        function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }

        // --- User Credentials Management (localStorage) ---
        function getUserCredentials() { return loadJSONFromStorage(USER_CREDENTIALS_KEY, "User creds", {}); }
        function saveUserCredentials(credentials) { return saveJSONToStorage(USER_CREDENTIALS_KEY, credentials, "User creds"); }

        // --- Password Hashing ---
        async function hashPassword(password) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            } catch (error) {
                console.error("Password hashing failed:", error);
                appendToOutput("Critical error: Password hashing service unavailable.", true, CSS_ERROR_MSG);
                throw error;
            }
        }

        // --- Helper to create parent directories ---
        function createParentDirectoriesIfNeeded(fullPath) {
            if (fullPath === '/') return null;
            const lastSlashIndex = fullPath.lastIndexOf('/');
            if (lastSlashIndex === -1) return null;

            const parentPath = lastSlashIndex === 0 ? '/' : fullPath.substring(0, lastSlashIndex);
            const newFileName = fullPath.substring(lastSlashIndex + 1);

            if (!newFileName || newFileName === "." || newFileName === "..") {
                const messageClass = isEditingFile || isRunningDiag ? 'diag-output' : CSS_ERROR_MSG;
                appendToOutput(`Error: Invalid name '${newFileName}' in path '${fullPath}'`, true, messageClass);
                return null;
            }

            if (parentPath === '/') return fsData['/'];

            const parentPathSegments = parentPath.substring(1).split('/').filter(s => s);
            let currentDirNode = fsData['/'];
            let currentBuiltParentPath = "";

            for (const segment of parentPathSegments) {
                currentBuiltParentPath += "/" + segment;
                if (!currentDirNode.children[segment]) {
                    currentDirNode.children[segment] = { type: 'directory', children: {} };
                } else if (currentDirNode.children[segment].type !== 'directory') {
                    const messageClass = isEditingFile || isRunningDiag ? 'diag-output' : CSS_ERROR_MSG;
                    appendToOutput(`Error: Path component '${currentBuiltParentPath}' is not a directory.`, true, messageClass);
                    return null;
                }
                currentDirNode = currentDirNode.children[segment];
            }
            return currentDirNode;
        }

        // --- Byte Formatting Helper ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // NEW: Helper function to parse numeric options like -n N
        function parseNumericOption(args, optionStr, defaultValue) {
            let numericValue = defaultValue;
            const remainingArgs = [...args]; // Work with a copy
            let error = null;
            const optionIndex = remainingArgs.indexOf(optionStr);

            if (optionIndex !== -1) { // Option string (-n) is found
                if (optionIndex + 1 < remainingArgs.length) { // Check if there's an argument after -n
                    const potentialNumber = remainingArgs[optionIndex + 1];
                    const parsedNumber = parseInt(potentialNumber, 10);

                    if (!isNaN(parsedNumber) && parsedNumber > 0) {
                        numericValue = parsedNumber;
                        remainingArgs.splice(optionIndex, 2); // Remove both -n and its valid number
                    } else {
                        // -n was followed by something, but it wasn't a valid positive number
                        error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`;
                        // Remove -n and the invalid value to prevent them being treated as filenames
                        remainingArgs.splice(optionIndex, 2);
                        // numericValue remains defaultValue
                    }
                } else {
                    // -n was found, but nothing followed it
                    error = `option ${optionStr} requires an argument`;
                    remainingArgs.splice(optionIndex, 1); // Remove only -n
                    // numericValue remains defaultValue
                }
            }
            return { value: numericValue, remainingArgs, error };
        }


        // --- Command Help Data ---
        const commandHelpData = {
            'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
            'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
            'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
            'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
            'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
            'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
            'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
            'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
            'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms).', syntax: 'rm ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command requires confirmation before deletion as it cannot be undone. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder']},
            'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
            'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
            'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
            'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
            'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
            'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
            'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
            'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
            'register': { usage: 'register <username> <password>', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME PASSWORD', details: 'Registers a new user with the given USERNAME and PASSWORD. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage and input is masked.', examples: ['register myuser mysecretpass']},
            'login': { usage: 'login <username> <password>', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME PASSWORD', details: 'Logs in as the specified USERNAME using the provided PASSWORD. The entered password will be hashed, compared against the stored hash, and input is masked. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser mysecretpass']},
            'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
            'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
            'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
            'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
            'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
            'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
            'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
            'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
            'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
            'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
            'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
            'head': {
                usage: 'head [-n N] <filename>',
                summary: 'Displays the beginning of a file.',
                syntax: 'head [-n N] FILE',
                details: 'Prints the first N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.',
                examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt']
            },
            'tail': {
                usage: 'tail [-n N] <filename>',
                summary: 'Displays the end of a file.',
                syntax: 'tail [-n N] FILE',
                details: 'Prints the last N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.',
                examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt']
            },
            'export': {
                usage: 'export <path/to/filename>',
                summary: 'Exports a file to your local disk.',
                syntax: 'export FILE_PATH',
                details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.',
                examples: ['export my_document.txt', 'export /logs/today.log']
            },
            'backup': {
                usage: 'backup',
                summary: 'Backs up current user session to a local file.',
                syntax: 'backup',
                details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.',
                examples: ['backup']
            },
            'import': {
                usage: 'import',
                summary: 'Imports a user session from a local backup file.',
                syntax: 'import',
                details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).',
                examples: ['import']
            }
        };

        // --- Command Handlers ---
        async function handleLs(args) {
            const targetPathArg = args[0] || '.';
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') {
                const childrenNames = Object.keys(node.children).sort();
                if (childrenNames.length === 0) return "Directory is empty.";
                let outputLines = [];
                childrenNames.forEach(name => {
                    const childNode = node.children[name];
                    let line = name;
                    if (childNode.type === 'directory') line += '/';
                    outputLines.push(line);
                });
                return outputLines.join('\n');
            } else if (node) {
                appendToOutput(`ls: '${targetPathArg}': Not a directory`, true);
                return null;
            } else {
                appendToOutput(`ls: cannot access '${targetPathArg}': No such file or directory`, true);
                return null;
            }
        }
        async function handleCd(args) {
            if (!args.length) { appendToOutput("cd: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);

            if (resolvedPath === currentPath) {
                return null;
            }

            const node = getNodeByPath(resolvedPath);
            if (node?.type === 'directory') {
                currentPath = resolvedPath;
                updatePrompt();
            } else if (node) {
                appendToOutput(`cd: '${targetPathArg}': Not a directory`, true);
            } else {
                appendToOutput(`cd: '${targetPathArg}': No such file or directory`, true);
            }
            return null;
        }
        async function handleMkdir(args) {
            if (args.length === 0) { appendToOutput("mkdir: missing operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg === '/' || fullPathArg === '.' || fullPathArg === '..') {
                appendToOutput(`mkdir: invalid directory name '${fullPathArg}'`, true); return null;
            }
            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') {
                appendToOutput(`mkdir: cannot create directory '/': It already exists.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const lastSlash = targetAbsPath.lastIndexOf('/');
            const parentDirPath = lastSlash === 0 ? '/' : targetAbsPath.substring(0, lastSlash);
            const dirToCreateName = targetAbsPath.substring(lastSlash + 1);

            if (!dirToCreateName) {
                appendToOutput(`mkdir: invalid directory name in '${fullPathArg}'`, true); return null;
            }

            let parentNode;
            if (parentDirPath === '/') {
                parentNode = fsData['/'];
            } else {
                parentNode = createParentDirectoriesIfNeeded(targetAbsPath);
                if (!parentNode) {
                    return null;
                }
            }

            if (parentNode.children[dirToCreateName]) {
                if (parentNode.children[dirToCreateName].type === 'directory') {
                    appendToOutput(`mkdir: cannot create directory '${fullPathArg}': Directory already exists.`, false, CSS_CONSOLE_LOG_MSG);
                } else {
                    appendToOutput(`mkdir: cannot create directory '${fullPathArg}': A file with the name '${dirToCreateName}' already exists.`, true);
                }
                return null;
            }

            parentNode.children[dirToCreateName] = { type: 'directory', children: {} };
            if (!await saveFileSystemData()) {
                return null;
            }
            return null;
        }
        async function handleTouch(args) {
            if (args.length === 0) { appendToOutput("touch: missing file operand", true); return null; }
            const fullPathArg = args[0];
            if (!fullPathArg || fullPathArg.endsWith('/')) { appendToOutput(`touch: invalid argument '${fullPathArg}' (cannot be a directory path or empty)`, true); return null; }

            const targetAbsPath = getAbsolutePath(fullPathArg, currentPath);
            if (targetAbsPath === '/') { appendToOutput(`touch: cannot create file at root '/'`, true); return null; }

            const parentNode = createParentDirectoriesIfNeeded(targetAbsPath);
            if (!parentNode) return null;

            const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);

            if (parentNode.children[newFileName]?.type === 'directory') {
                appendToOutput(`touch: cannot touch '${fullPathArg}': It is a directory.`, true); return null;
            }

            if (parentNode.children[newFileName]) {
            } else {
                parentNode.children[newFileName] = { type: 'file', content: "" };
                if (!await saveFileSystemData()) return null;
            }
            return null;
        }
        async function handleCat(args) {
            if (args.length === 0) { appendToOutput("cat: missing file operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`cat: ${targetPathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`cat: ${targetPathArg}: Is a directory`, true); return null; }
            return node.content;
        }
        async function handleEcho(args) {
            let outputString = args.join(' ');
            if (outputString.length >= 2) {
                const firstChar = outputString[0];
                const lastChar = outputString[outputString.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    outputString = outputString.substring(1, outputString.length - 1);
                }
            }
            return outputString;
        }
        async function handleMv(args) {
            if (args.length < 2) { appendToOutput("mv: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);

            if (absSourcePath === '/') { appendToOutput("mv: cannot move root '/'", true); return null; }

            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`mv: '${sourcePathArg}': No such file or directory`, true); return null; }

            const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/';
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            const sourceParentNode = getNodeByPath(sourceParentPath);

            if (!sourceParentNode?.children?.[sourceName]) {
                appendToOutput(`mv: internal error: source '${sourceName}' not in parent`, true); return null;
            }

            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);

            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }

            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`mv: invalid destination name '${finalDestName}'`, true); return null; }

            if (absSourcePath === absDestPath) {
                appendToOutput(`mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            if (finalDestParentNode.children[finalDestName]) {
                if (!(destNodeAtFullPath?.type === 'directory' && sourceNode.type !== 'directory')) {
                    appendToOutput(`mv: destination '${finalDestName}' already exists.`, true); return null;
                }
            }

            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`mv: cannot move directory into itself or one of its subdirectories`, true); return null;
            }

            finalDestParentNode.children[finalDestName] = sourceNode;
            delete sourceParentNode.children[sourceName];

            if (await saveFileSystemData()) {
            }
            return null;
        }
        async function handleCp(args) {
            if (args.length < 2) { appendToOutput("cp: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            const absSourcePath = getAbsolutePath(sourcePathArg, currentPath);
            let absDestPath = getAbsolutePath(destPathArg, currentPath);

            const sourceNode = getNodeByPath(absSourcePath);
            if (!sourceNode) { appendToOutput(`cp: '${sourcePathArg}': No such file or directory`, true); return null; }
            if (absSourcePath === '/') { appendToOutput("cp: cannot copy root '/' itself. Copy its contents if needed.", true); return null; }


            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            let finalDestParentNode, finalDestName;
            const destNodeAtFullPath = getNodeByPath(absDestPath);

            if (destNodeAtFullPath?.type === 'directory') {
                finalDestParentNode = destNodeAtFullPath;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                finalDestParentNode = createParentDirectoriesIfNeeded(absDestPath);
                if (!finalDestParentNode) return null;
                finalDestName = absDestPath.substring(lastSlash + 1);
            }

            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`cp: invalid destination name '${finalDestName}'`, true); return null; }

            if (finalDestParentNode.children[finalDestName]) {
                appendToOutput(`cp: destination '${finalDestName}' already exists. Cannot overwrite.`, true); return null;
            }

            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`cp: cannot copy a directory into itself or one of its subdirectories.`, true); return null;
            }

            const copiedNode = deepCopyNode(sourceNode);
            if (!copiedNode) { appendToOutput(`cp: internal error copying '${sourcePathArg}'.`, true); return null; }

            finalDestParentNode.children[finalDestName] = copiedNode;
            if (await saveFileSystemData()) {
            }
            return null;
        }
        async function handleRm(args) {
             if (args.length === 0) { appendToOutput("rm: missing operand", true); return null; }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);

            if (resolvedPath === '/') { appendToOutput("rm: cannot remove root directory '/'", true); return null; }

            const node = getNodeByPath(resolvedPath);
            if (!node) { appendToOutput(`rm: cannot remove '${targetPathArg}': No such file or directory`, true); return null; }

            itemToRemovePath = resolvedPath;
            awaitingRmConfirmation = true;
            const itemType = node.type === 'directory' ? 'directory' : 'file';
            appendToOutput(`Are you sure you want to remove ${itemType} '${targetPathArg}'? This action cannot be undone.`, false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            return null;
        }
        async function handlePwd(args) { return currentPath;}
        async function handleDate(args) { return new Date().toString();}
        async function handleWhoami(args) { return currentUser;}
        async function handleGrep(args) {
            if (args.length < 2) { appendToOutput("grep: usage: grep PATTERN FILE", true); return null; }
            const filePathArg = args[args.length - 1];
            let patternParts = args.slice(0, args.length - 1);
            let pattern = patternParts.join(' ');

            if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                pattern = pattern.substring(1, pattern.length - 1);
            }

            if (!pattern) { appendToOutput("grep: pattern cannot be empty", true); return null; }

            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) { appendToOutput(`grep: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`grep: ${filePathArg}: Is a directory`, true); return null; }

            const fileContent = node.content || "";
            const lines = fileContent.split('\n');
            const matchingLines = [];
            for (const line of lines) { if (line.includes(pattern)) { matchingLines.push(line); } }

            return matchingLines.length > 0 ? matchingLines.join('\n') : "";
        }
        async function handleRun(args) {
            if (args.length === 0) { appendToOutput("run: missing script file operand", true); return null; }
            const scriptPathArg = args[0];
            const resolvedPath = getAbsolutePath(scriptPathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) { appendToOutput(`run: cannot access script '${scriptPathArg}': No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`run: cannot execute '${scriptPathArg}': It is a directory`, true); return null; }

            const scriptContent = node.content || "";
            const scriptLines = scriptContent.split('\n');
            appendToOutput(`Executing script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);

            (async () => {
                for (let i = 0; i < scriptLines.length; i++) {
                    const line = scriptLines[i];
                    const trimmedLine = line.trim();
                    if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;

                    const commandSuccessful = await processCommand(trimmedLine, false);
                    if (!commandSuccessful) {
                        appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, true);
                        return;
                    }
                }
                appendToOutput(`Finished script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            })();
            return null;
        }
        async function handleSysmon(args) {
             const output = [
                "Ooputer 1 - System Monitor", "----------------------------------",
                `OS Name:          ${OS_NAME}`, `OS Version:       ${OS_VERSION}`,
                `Current User:     ${currentUser}`, "", "CPU:", `  Type:           OopisCPU Mark I`,
                `  Architecture:   CISC-ish`, `  Cores:          1 (Conceptual)`,
                `  Clock Speed:    ~1-5 OopoHertz (Variable Burst)`, "", "MEMORY (RAM):",
                `  Type:           DJHAR`, `  Capacity:       ~640 KB (Active Working Memory)`,
                "", "STORAGE (LS-SSD):", `  Type:           IndexedDB Drive`,
                `  Capacity:       Browser Dependent (Often 10s-100s MB+)`,
                "", "DISPLAY (OTDA):",
                `  Type:           GreenScreen Deluxe`, `  Mode:           Text-Mode`,
                "----------------------------------"
            ];
            let styledOutput = "";
            output.forEach(line => {
                const parts = line.split(':');
                if (parts.length > 1) {
                    styledOutput += `<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_SYSMON_LABEL}">${parts[0].padEnd(18, ' ')}:</span><span>${parts.slice(1).join(':').trim()}</span></div>`;
                } else {
                    styledOutput += `<div class="${CSS_OUTPUT_LINE}">${line}</div>`;
                }
            });
            appendHtmlToOutput(styledOutput);
            return null;
        }
        async function handleSort(args) {
            if (args.length === 0) { appendToOutput("sort: missing file operand", true); return null; }
            const filePathArg = args[0];
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) { appendToOutput(`sort: ${filePathArg}: No such file or directory`, true); return null; }
            if (node.type === 'directory') { appendToOutput(`sort: ${filePathArg}: Is a directory`, true); return null; }

            const fileContent = node.content || "";
            if (fileContent.trim() === "") return "";

            const lines = fileContent.split('\n');
            lines.sort();
            return lines.join('\n');
        }
        async function handleClear() { if (!isEditingFile) outputDiv.innerHTML = ''; return null; }
        async function handleManualSaveState() {
            const manualState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value, fsDataSnapshot: deepCopyNode(fsData) };
            if (saveJSONToStorage(getManualUserTerminalStateKey(currentUser), manualState, `Manual save for ${currentUser}`)) {
                appendToOutput(`Session manually saved for ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        async function handleManualLoadState() {
             pendingManualStateToLoad = loadJSONFromStorage(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser}`);
            if (pendingManualStateToLoad) {
                appendToOutput("Load manually saved state? This overwrites current session & filesystem.", false, CSS_WARNING_MSG);
                appendToOutput("Type 'YES' to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
                awaitingLoadstateConfirmation = true;
            } else appendToOutput(`No manually saved state found for ${currentUser}.`, false, CSS_CONSOLE_LOG_MSG);
            return null;
        }
        async function performFullReset() {
            outputDiv.innerHTML = ''; hiddenInput.value = ''; updateVisualInput();

            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(USER_TERMINAL_STATE_KEY_PREFIX) || key.startsWith(MANUAL_USER_TERMINAL_STATE_KEY_PREFIX) || key === USER_CREDENTIALS_KEY) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            appendToOutput("All session states and credentials cleared from local storage.", false, CSS_CONSOLE_LOG_MSG);

            if (db) {
                try {
                    await new Promise((resolve, reject) => {
                        const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(FS_STORE_NAME);
                        const request = store.clear();
                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                    appendToOutput("All user filesystems cleared from DB.", false, CSS_CONSOLE_LOG_MSG);
                } catch (error) {
                    console.error("Error clearing FileSystemsStore during reset:", error);
                    appendToOutput("Error clearing user filesystems from DB.", true);
                }
            }

            commandHistory = []; historyIndex = commandHistory.length; currentUser = DEFAULT_USER;
            await initializeFileSystem(DEFAULT_USER);
            loadAutomaticSessionState(DEFAULT_USER);
            appendToOutput("Terminal fully reset. All user data and states cleared.", false, CSS_SUCCESS_MSG);
        }
        async function handleReset() {
            appendToOutput("Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone.", false, CSS_WARNING_MSG);
            appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
            awaitingResetConfirmation = true; return null;
        }
        async function handleRegister(args) {
            if (args.length < 2) { appendToOutput("Usage: register <username> <password>", true); return null; }
            const [username, password] = args;
            const credentials = getUserCredentials();
            if (credentials[username]) { appendToOutput(`Error: User '${username}' already exists.`, true); return null; }
            if (username.toLowerCase() === DEFAULT_USER.toLowerCase()) { appendToOutput(`Error: Cannot register '${DEFAULT_USER}'. This username is reserved.`, true); return null; }
            if (username.includes(" ") || password.includes(" ")) {
                 appendToOutput("Error: Username and password cannot contain spaces.", true); return null;
            }

            try {
                const hashedPassword = await hashPassword(password);
                credentials[username] = hashedPassword;
                if (saveUserCredentials(credentials)) {
                    await initializeFileSystem(username);
                    if (!isRunningDiag) appendToOutput(`User '${username}' registered. You can now login.`, false, CSS_SUCCESS_MSG);
                }
            } catch (error) {
                 if (!isRunningDiag) appendToOutput(`Registration failed for '${username}' due to a system error.`, true);
                 else throw error;
            }
            return null;
        }
        async function handleLogin(args) {
            if (args.length < 2) { appendToOutput("Usage: login <username> <password>", true); return null; }
            const [username, password] = args;

            if (username === currentUser && !isRunningDiag) {
                appendToOutput(`login: already logged in as '${username}'.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const credentials = getUserCredentials();
            const storedPasswordHash = credentials[username];

            if (!storedPasswordHash) {
                if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                else lastCommandFailed = true;
                return null;
            }

            try {
                const enteredPasswordHash = await hashPassword(password);
                if (storedPasswordHash === enteredPasswordHash) {
                    if (currentUser !== DEFAULT_USER && currentUser !== username && !isRunningDiag) saveAutomaticSessionState();
                    currentUser = username;
                    commandHistory = []; historyIndex = commandHistory.length;
                    await loadFileSystemData(currentUser);
                    if(!isRunningDiag) loadAutomaticSessionState(currentUser);
                    if(!isRunningDiag) appendToOutput(`Logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
                } else {
                    if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                    else lastCommandFailed = true;
                }
            } catch (error) {
                if (!isRunningDiag) appendToOutput("Login failed due to a system error during password verification.", true);
                else { lastCommandFailed = true; throw error; }
            }
            return null;
        }
        async function handleLogout() {
            if (currentUser === DEFAULT_USER) {
                 if (!isRunningDiag) appendToOutput("Already logged in as Guest. No action taken.", false, CSS_CONSOLE_LOG_MSG);
                 return null;
            }
            if (!isRunningDiag) saveAutomaticSessionState();
            const prevUser = currentUser;
            currentUser = DEFAULT_USER;
            commandHistory = []; historyIndex = commandHistory.length;
            await loadFileSystemData(DEFAULT_USER);
            if (!isRunningDiag) {
                loadAutomaticSessionState(DEFAULT_USER);
                appendToOutput(`User ${prevUser} logged out. Now logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        async function handleHelp(args) {
            let outputLines = [];
            if (!args.length) {
                outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                const commandNames = Object.keys(commandRegistry).sort();
                commandNames.forEach(cmdName => {
                    const summary = commandHelpData[cmdName]?.summary || 'No summary available.';
                    outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`);
                });
            } else {
                const commandName = args[0].toLowerCase();
                const helpInfo = commandHelpData[commandName];
                if (helpInfo) {
                    outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                    outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                    outputLines.push(`  For more details, type: man ${commandName}`);
                } else { appendToOutput(`No help available for '${commandName}'. Try 'man ${commandName}'.`, true); return null; }
            }
            return outputLines.join('\n');
        }
        async function handleMan(args) {
            function escapeHtml(unsafe) {
                if (typeof unsafe !== 'string') return '';
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            if (args.length === 0) {
                appendToOutput("What manual page do you want? (e.g., man ls)", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            const commandName = args[0].toLowerCase();
            const manData = commandHelpData[commandName];
            
            if (manData) {
                let manOutputHtmlLines = [];

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">NAME</span></div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`);

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">SYNOPSIS</span></div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    <span class="${CSS_HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`);

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">DESCRIPTION</span></div>`);
                const detailLines = (manData.details || 'No detailed description available.').split('\n');
                detailLines.forEach(line => {
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    <span class="${CSS_MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`);
                });

                if (manData.examples && manData.examples.length > 0) {
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">EXAMPLES</span></div>`);
                    manData.examples.forEach(example => {
                        manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">        <span class="${CSS_MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`);
                    });
                }
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);

                appendHtmlToOutput(manOutputHtmlLines.join(''));
                return null;
            } else {
                appendToOutput(`No manual entry for ${commandName}`, true);
                return null;
            }
        }

        async function handleEdit(args) {
            if (isEditingFile) {
                appendToOutput("Editor already active. Ctrl+S to save, Ctrl+O to quit.", false, 'editor-message');
                return null;
            }
            if (args.length === 0) {
                appendToOutput("edit: missing file operand", true);
                return null;
            }
            const targetPathArg = args[0];
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);

            if (resolvedPath.endsWith('/')) {
                 appendToOutput(`edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.`, true);
                 return null;
            }

            const node = getNodeByPath(resolvedPath);
            if (node && node.type === 'directory') {
                appendToOutput(`edit: '${targetPathArg}' is an existing directory. Cannot edit directories.`, true);
                return null;
            }

            const content = node?.content || "";
            enterEditMode(resolvedPath, content);
            return null;
        }

        function enterEditMode(filePath, content) {
            isEditingFile = true;
            editingFilePath = filePath;

            outputDiv.style.display = 'none';
            standardInputLineDiv.style.display = 'none';
            hiddenInput.blur();

            editorWrapperDiv = document.createElement('div');
            editorWrapperDiv.id = 'editor-wrapper';

            editorTextareaElement = document.createElement('textarea');
            editorTextareaElement.id = 'editor-textarea';
            editorTextareaElement.value = content;

            editorInstructionsDiv = document.createElement('div');
            editorInstructionsDiv.id = 'editor-instructions';
            editorInstructionsDiv.textContent = `Editing: ${filePath} | Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving`;

            editorWrapperDiv.appendChild(editorTextareaElement);
            editorWrapperDiv.appendChild(editorInstructionsDiv);

            terminalDiv.insertBefore(editorWrapperDiv, standardInputLineDiv);

            editorTextareaElement.focus();
            editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
            editorTextareaElement.addEventListener('keydown', handleEditorKeyDown);
        }

        async function exitEditMode(saveChanges = false) {
            let success = true;
            if (saveChanges && editorTextareaElement && editingFilePath) {
                const newContent = editorTextareaElement.value;
                const parentNode = createParentDirectoriesIfNeeded(editingFilePath);
                if (parentNode) {
                    const fileName = editingFilePath.substring(editingFilePath.lastIndexOf('/') + 1);
                    parentNode.children[fileName] = { type: 'file', content: newContent };
                    if (await saveFileSystemData()) {
                        appendToOutput(`File '${editingFilePath}' saved.`, false, CSS_SUCCESS_MSG);
                    } else {
                        appendToOutput(`Error saving file '${editingFilePath}'. Changes might be lost.`, true, CSS_ERROR_MSG);
                        success = false;
                    }
                } else {
                    appendToOutput(`Failed to save '${editingFilePath}'. Parent path issue.`, true, CSS_ERROR_MSG);
                    success = false;
                }
            } else if (editingFilePath) {
                appendToOutput(`Exited editor for '${editingFilePath}' without saving.`, false, CSS_CONSOLE_LOG_MSG);
            }

            if (editorWrapperDiv && editorWrapperDiv.parentNode === terminalDiv) {
                terminalDiv.removeChild(editorWrapperDiv);
            }
            if (editorTextareaElement) {
                editorTextareaElement.removeEventListener('keydown', handleEditorKeyDown);
            }
            editorWrapperDiv = null; editorTextareaElement = null; editorInstructionsDiv = null;

            isEditingFile = false; editingFilePath = null;

            outputDiv.style.display = '';
            standardInputLineDiv.style.display = '';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            hiddenInput.focus();
            updatePrompt();
            return success;
        }

        async function handleEditorKeyDown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
                return;
            }

            if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                await exitEditMode(true);
            } else if (event.ctrlKey && (event.key === 'o' || event.key === 'O')) {
                event.preventDefault();
                await exitEditMode(false);
            }
        }


        async function handleDiag(args) {
            isRunningDiag = true;
            let passCount = 0;
            let failCount = 0;

            const originalCurrentUser = currentUser;
            let originalFsData = deepCopyNode(fsData);
            const originalCurrentPath = currentPath;
            const originalCredentials = deepCopyNode(getUserCredentials());
            const originalOutputHTML = outputDiv.innerHTML;
            const originalCommandHistory = [...commandHistory];
            const originalHistoryIndex = historyIndex;


            const diagPrint = (message) => appendToOutput(message, false, 'diag-output');
            const report = (testName, success, details = "") => {
                if (success) { passCount++; diagPrint(`  PASS: ${testName}`); }
                else { failCount++; diagPrint(`  FAIL: ${testName} ${details ? `- ${details}` : ''}`); }
                return success;
            };

            outputDiv.innerHTML = '';
            diagPrint("Starting OopisOs Diagnostics...");
            diagPrint("-------------------------------");

            diagPrint("SECTION: Filesystem Operations (using IndexedDB)");
            const fsTestUser = "__diag_fs_user__";
            const fsTestDir = "/tmp/__diag_fs_tests__";
            const fsTestFile = `${fsTestDir}/file.txt`;
            const fsTestContent = "Hello from FS Diag!";

            await deleteFileSystemData(fsTestUser).catch(e => {});
            await initializeFileSystem(fsTestUser);
            fsData = { '/': { type: 'directory', children: {} } };
            await loadFileSystemData(fsTestUser);


            lastCommandFailed = false; await processCommand(`mkdir ${fsTestDir}`, false);
            report("FS: Create test directory", getNodeByPath(fsTestDir)?.type === 'directory' && !lastCommandFailed);

            lastCommandFailed = false; await processCommand(`cd ${fsTestDir}`, false);
            report("FS: Change to test directory", currentPath === fsTestDir && !lastCommandFailed);

            lastCommandFailed = false; await processCommand(`touch ${fsTestFile.split('/').pop()}`, false);
            report("FS: Create test file", getNodeByPath(fsTestFile)?.type === 'file' && !lastCommandFailed);

            lastCommandFailed = false; await processCommand(`echo "${fsTestContent}" > ${fsTestFile.split('/').pop()}`, false);
            let fileNodeContentFs = getNodeByPath(fsTestFile);
            report("FS: Write content to file", fileNodeContentFs?.content === fsTestContent && !lastCommandFailed, `Expected "${fsTestContent}", got "${fileNodeContentFs?.content}"`);

            lastCommandFailed = false;
            fileNodeContentFs = getNodeByPath(fsTestFile);
            report("FS: Verify file content (direct check after echo)", fileNodeContentFs?.content === fsTestContent);


            fsData = deepCopyNode(originalFsData);
            await saveFileSystemData(originalCurrentUser);
            currentPath = originalCurrentPath;
            const cleanupNode = getNodeByPath(fsTestDir);
            if (cleanupNode) {
                const parentPath = fsTestDir.substring(0, fsTestDir.lastIndexOf('/')) || '/';
                const dirName = fsTestDir.substring(fsTestDir.lastIndexOf('/') + 1);
                const parent = getNodeByPath(parentPath);
                if (parent && parent.children[dirName]) {
                    delete parent.children[dirName];
                    await saveFileSystemData(originalCurrentUser);
                    diagPrint(`  INFO: Cleaned up ${fsTestDir} from original user's FS if it existed.`);
                }
            }


            diagPrint("SECTION: Path Resolution (getAbsolutePath)");
            const pathTestCases = [
                { target: '.', base: '/', expected: '/' , desc: "Current dir at root"}, { target: '..', base: '/', expected: '/', desc: "Parent dir at root" }, { target: 'foo', base: '/', expected: '/foo', desc: "Simple relative from root" }, { target: '/foo/bar', base: '/baz', expected: '/foo/bar', desc: "Absolute target, ignore base" }, { target: 'bar', base: '/foo', expected: '/foo/bar', desc: "Relative from non-root" }, { target: '../bar', base: '/foo/baz', expected: '/foo/bar', desc: "Relative parent navigation" }, { target: '../../bar', base: '/foo/baz/qux', expected: '/foo/bar', desc: "Multiple parent nav" }, { target: '../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav to higher level" }, { target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav beyond root" },
                { target: 'qux/./corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With current dir token"}, { target: 'qux//corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With double slashes"}, { target: '.', base: '/foo/bar', expected: '/foo/bar', desc: "Current dir in non-root"}, { target: '', base: '/foo/bar', expected: '/foo/bar', desc: "Empty target (like current)"}, { target: 'a/b/../../c', base: '/x/y', expected: '/x/y/c', desc: "Complex relative with backtracking"}, { target: '/a/b/../c', base: '/x', expected: '/a/c', desc: "Absolute with backtracking"}, { target: 'a/../..', base: '/x', expected: '/', desc: "Relative to root"}, { target: 'a/b', base: '/', expected: '/a/b', desc: "Simple relative from root 2"}, { target: '//a//b', base: '/', expected: '/a/b', desc: "Multiple slashes at start and middle"},
            ];
            pathTestCases.forEach(tc => {
                const actual = getAbsolutePath(tc.target, tc.base);
                report(`Path: ${tc.desc} ('${tc.target}', '${tc.base}')`, actual === tc.expected, `Expected '${tc.expected}', got '${actual}'`);
            });

            diagPrint("SECTION: User Management");
            const testUsername = "__diag_user__";
            const testPassword = "diagPassword123!";
            const wrongPassword = "wrongPassword!";

            let tempCredentialsPre = getUserCredentials();
            if (tempCredentialsPre[testUsername]) { delete tempCredentialsPre[testUsername]; saveUserCredentials(tempCredentialsPre); }
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            diagPrint(`  INFO: Pre-cleaned test user '${testUsername}' related data.`);


            diagPrint("  Test UM.1: register new user");
            lastCommandFailed = false;
            await processCommand(`register ${testUsername} ${testPassword}`, false);
            let tempCredentials = getUserCredentials();
            const userRegistered = tempCredentials[testUsername] && tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername].length === 64;
            let testUserFsExistsInDb = false;
            if(db) {
                const storedFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => { console.error("Diag DB read error:", e.target.error); res(null);};
                }).catch(() => null);
                testUserFsExistsInDb = !!(storedFs && storedFs.data && storedFs.data['/']);
            }
            report("Register test user", userRegistered && testUserFsExistsInDb && !lastCommandFailed,
                   `User in creds: ${!!tempCredentials[testUsername]}, Pwd hashed: ${tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername]?.length === 64}, FS in DB: ${testUserFsExistsInDb}`);


            diagPrint("  Test UM.2: login with correct password");
            lastCommandFailed = false;
            const currentUserBeforeLogin = currentUser;
            await processCommand(`login ${testUsername} ${testPassword}`, false);
            report("Login test user (correct pwd)", currentUser === testUsername && !lastCommandFailed);


            if (currentUser === testUsername) {
                diagPrint("  Test UM.3: whoami as test user");
                const whoOutput = await handleWhoami([]);
                report("whoami check", whoOutput === testUsername, `Expected '${testUsername}', got '${whoOutput}'`);
            } else {
                report("whoami check", false, "Skipped due to previous login failure or currentUser mismatch.");
                currentUser = currentUserBeforeLogin;
                await loadFileSystemData(currentUser);
            }


            diagPrint("  Test UM.4: login with incorrect password");
            const currentUserBeforeWrongLogin = currentUser;
            lastCommandFailed = false;
            await processCommand(`login ${testUsername} ${wrongPassword}`, false);
            report("Login test user (incorrect pwd)", currentUser === currentUserBeforeWrongLogin && lastCommandFailed, `currentUser is ${currentUser}, expected ${currentUserBeforeWrongLogin}. lastCommandFailed: ${lastCommandFailed}`);


            diagPrint("  Test UM.5: logout from test user (if logged in)");
            lastCommandFailed = false;
            if (currentUser === testUsername) {
                await processCommand("logout", false);
                report("Logout to Guest", currentUser === DEFAULT_USER && !lastCommandFailed);
            } else {
                report("Logout to Guest", currentUser === DEFAULT_USER, "Skipped logout as not logged in as test user, or already Guest.");
                if (currentUser !== DEFAULT_USER) {
                    currentUser = DEFAULT_USER;
                    await loadFileSystemData(DEFAULT_USER);
                }
            }


            diagPrint("  Cleanup: Removing test user credentials and data");
            tempCredentials = getUserCredentials();
            if (tempCredentials[testUsername]) delete tempCredentials[testUsername];
            saveUserCredentials(tempCredentials);
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            let finalCredCheck = !getUserCredentials()[testUsername];
            let finalFsCheckInDb = true;
             if(db) {
                const finalStoredFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => res(null);
                }).catch(()=>null);
                finalFsCheckInDb = !finalStoredFs;
            }
            report("User data cleanup", finalCredCheck && finalFsCheckInDb);


            diagPrint("-------------------------------");
            diagPrint(`Diagnostics Complete: ${passCount} PASSED, ${failCount} FAILED.`);
            diagPrint("-------------------------------");
            const finalDiagReportHTML = outputDiv.innerHTML;

            currentUser = originalCurrentUser;
            fsData = originalFsData;
            currentPath = originalCurrentPath;
            saveUserCredentials(originalCredentials);
            await saveFileSystemData(currentUser);
            commandHistory = originalCommandHistory;
            historyIndex = originalHistoryIndex;


            outputDiv.innerHTML = originalOutputHTML;
            const diagReportContainer = document.createElement('div');
            diagReportContainer.innerHTML = finalDiagReportHTML;
            outputDiv.appendChild(diagReportContainer);

            updatePrompt();
            updateVisualInput();
            hiddenInput.value = '';
            setTimeout(() => { outputDiv.scrollTop = outputDiv.scrollHeight; }, 50);

            isRunningDiag = false;
            window.diagInitialized = false;
            return "";
        }
        function handleTree(args) {
            const targetPathArg = args[0] || '.';
            const resolvedPath = getAbsolutePath(targetPathArg, currentPath);
            const startNode = getNodeByPath(resolvedPath);

            if (!startNode) { appendToOutput(`tree: cannot access '${targetPathArg}': No such file or directory`, true); return null; }
            if (startNode.type !== 'directory') { appendToOutput(`tree: '${targetPathArg}' is not a directory`, true); return null; }

            const outputLines = [];
            const startingDirName = resolvedPath === '/' ? '/' : resolvedPath.substring(resolvedPath.lastIndexOf('/') + 1) || resolvedPath;
            outputLines.push(startingDirName);

            function generateTreeLinesRecursive(directoryNode, prefix) {
                const childrenNames = Object.keys(directoryNode.children).sort();
                childrenNames.forEach((name, index) => {
                    const childNode = directoryNode.children[name];
                    const isLast = index === childrenNames.length - 1;
                    const connector = isLast ? " " : " ";
                    let line = prefix + connector + name;
                    if (childNode.type === 'directory') { line += "/"; }
                    outputLines.push(line);

                    if (childNode.type === 'directory') {
                        const newPrefix = prefix + (isLast ? "    " : "   ");
                        generateTreeLinesRecursive(childNode, newPrefix);
                    }
                });
            }
            generateTreeLinesRecursive(startNode, "");
            return outputLines.join('\n');
        }
        function matchPattern(name, pattern) {
            let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            try {
                const regex = new RegExp(`^${regexPattern}$`);
                return regex.test(name);
            } catch (e) {
                appendToOutput(`find: invalid pattern regex: ${pattern}`, true);
                return false;
            }
        }
        function findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) {
            if (!currentSearchNode || currentSearchNode.type !== 'directory') { return; }

            const childrenNames = Object.keys(currentSearchNode.children).sort();
            for (const name of childrenNames) {
                const childNode = currentSearchNode.children[name];
                const childFullPath = getAbsolutePath(name, currentSearchPath);

                if (matchPattern(name, pattern)) {
                    foundItems.push(childFullPath + (childNode.type === 'directory' ? '/' : ''));
                }

                if (childNode.type === 'directory') {
                    findRecursive(childNode, childFullPath, pattern, foundItems);
                }
            }
        }
        function handleFind(args) {
            let searchPathArg = '.'; let pattern = null;
            const nameOptionIndex = args.indexOf('-name');

            if (nameOptionIndex === -1) { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }

            if (nameOptionIndex === 0) {
                if (args.length < 2) { appendToOutput("find: missing pattern after -name", true); return null; }
                pattern = args[1];
            } else if (nameOptionIndex === 1) {
                if (args.length < 3) { appendToOutput("find: missing pattern after -name", true); return null; }
                searchPathArg = args[0];
                pattern = args[2];
            } else {
                appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null;
            }

            if (pattern && pattern.length >= 2) {
                const firstChar = pattern[0]; const lastChar = pattern[pattern.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    pattern = pattern.substring(1, pattern.length - 1);
                }
            }
            if (!pattern) { appendToOutput("find: pattern cannot be empty", true); return null; }


            const absoluteSearchPath = getAbsolutePath(searchPathArg, currentPath);
            const startNode = getNodeByPath(absoluteSearchPath);

            if (!startNode) { appendToOutput(`find: '${searchPathArg}': No such file or directory`, true); return null; }

            const foundItems = [];
            if (startNode.type === 'directory') {
                findRecursive(startNode, absoluteSearchPath, pattern, foundItems);
            } else if (startNode.type === 'file') {
                const fileName = absoluteSearchPath.substring(absoluteSearchPath.lastIndexOf('/') + 1);
                if (matchPattern(fileName, pattern)) {
                    foundItems.push(absoluteSearchPath);
                }
            } else {
                 appendToOutput(`find: '${searchPathArg}': Not a searchable item type`, true); return null;
            }


            return foundItems.length > 0 ? foundItems.join('\n') : "";
        }
        function calculateNodeSize(node) {
            if (node.type === 'file') { return node.content ? node.content.length : 0; }
            if (node.type === 'directory') {
                let totalSize = 0;
                for (const childName in node.children) { totalSize += calculateNodeSize(node.children[childName]); }
                return totalSize;
            }
            return 0;
        }
        function handleDu(args) {
            const outputLines = [];
            let pathsToProcessInfo = [];

            if (args.length === 0) {
                pathsToProcessInfo.push({ originalArg: '.', resolvedPath: currentPath });
            } else {
                for (const arg of args) {
                    pathsToProcessInfo.push({ originalArg: arg, resolvedPath: getAbsolutePath(arg, currentPath) });
                }
            }

            for (const item of pathsToProcessInfo) {
                const node = getNodeByPath(item.resolvedPath);
                if (!node) {
                    appendToOutput(`du: cannot access '${item.originalArg}': No such file or directory`, true);
                    continue;
                }
                const rawSize = calculateNodeSize(node);
                const formattedSize = formatBytes(rawSize);
                let displayPath = item.originalArg;
                if (node.type === 'directory' && item.originalArg === '.') { displayPath = './'; }
                else if (node.type === 'directory' && !item.originalArg.endsWith('/')) {
                }
                outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`);
            }
            return outputLines.join('\n');
        }

        async function handleHead(args) {
            const defaultNumLines = 10;
            const commandName = "head"; // For consistent error messages
            const options = parseNumericOption(args, "-n", defaultNumLines);
            let numLines = options.value;

            if (options.error) {
                appendToOutput(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`, false, CSS_WARNING_MSG);
            }

            const filePathArg = options.remainingArgs[0];

            if (!filePathArg) {
                if (options.remainingArgs.length === 0 && args.includes("-n")) {
                    appendToOutput(`${commandName}: missing file operand after -n option`, true);
                } else {
                    appendToOutput(`${commandName}: missing file operand`, true);
                }
                appendToOutput(`Usage: ${commandName} [-n N] <filename>`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            if (options.remainingArgs.length > 1) {
                appendToOutput(`${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'`, true);
                return null;
            }

            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) {
                appendToOutput(`${commandName}: ${filePathArg}: No such file or directory`, true);
                return null;
            }
            if (node.type === 'directory') {
                appendToOutput(`${commandName}: error reading '${filePathArg}': Is a directory`, true);
                return null;
            }

            const fileContent = node.content || "";
            const lines = fileContent.split('\n');
            const outputLines = lines.slice(0, numLines);

            return outputLines.join('\n');
        }

        async function handleTail(args) {
            const defaultNumLines = 10;
            const commandName = "tail"; // For consistent error messages
            const options = parseNumericOption(args, "-n", defaultNumLines);
            let numLines = options.value;

            if (options.error) {
                appendToOutput(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`, false, CSS_WARNING_MSG);
            }

            const filePathArg = options.remainingArgs[0];

            if (!filePathArg) {
                if (options.remainingArgs.length === 0 && args.includes("-n")) {
                     appendToOutput(`${commandName}: missing file operand after -n option`, true);
                } else {
                    appendToOutput(`${commandName}: missing file operand`, true);
                }
                appendToOutput(`Usage: ${commandName} [-n N] <filename>`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            
            if (options.remainingArgs.length > 1) {
                appendToOutput(`${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'`, true);
                return null;
            }

            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) {
                appendToOutput(`${commandName}: ${filePathArg}: No such file or directory`, true);
                return null;
            }
            if (node.type === 'directory') {
                appendToOutput(`${commandName}: error reading '${filePathArg}': Is a directory`, true);
                return null;
            }

            const fileContent = node.content || "";
            const lines = fileContent.split('\n');
            const outputLines = lines.slice(Math.max(0, lines.length - numLines));

            return outputLines.join('\n');
        }

        async function handleExport(args) {
            if (args.length === 0) {
                appendToOutput("export: missing file operand", true);
                return null;
            }
            const filePathArg = args[0];
            const resolvedPath = getAbsolutePath(filePathArg, currentPath);
            const node = getNodeByPath(resolvedPath);

            if (!node) {
                appendToOutput(`export: ${filePathArg}: No such file or directory`, true);
                return null;
            }
            if (node.type === 'directory') {
                appendToOutput(`export: ${filePathArg}: Is a directory. Cannot export directories.`, true);
                return null;
            }

            const fileName = resolvedPath.substring(resolvedPath.lastIndexOf('/') + 1) || 'downloaded_file.txt';
            const fileContent = node.content || "";
            const mimeType = "text/plain";

            try {
                const blob = new Blob([fileContent], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                appendToOutput(`Exporting '${fileName}'... Check your browser downloads.`, false, CSS_SUCCESS_MSG);
            } catch (error) {
                console.error("Export failed:", error);
                appendToOutput(`Error exporting file '${fileName}': ${error.message}`, true);
                return null;
            }
            return null;
        }

        async function handleBackup(args) {
            const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
            const backupFileName = `oopis_backup_${currentUser}_${timestamp}.json`;

            const backupData = {
                backupVersion: "1.0",
                osVersion: OS_VERSION,
                user: currentUser,
                timestamp: new Date().toISOString(),
                filesystem: deepCopyNode(fsData),
                currentPath: currentPath,
                commandHistory: [...commandHistory],
            };

            try {
                const jsonString = JSON.stringify(backupData, null, 2);
                const blob = new Blob([jsonString], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = backupFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                appendToOutput(`Creating backup '${backupFileName}'... Check your browser downloads.`, false, CSS_SUCCESS_MSG);
            } catch (error) {
                console.error("Backup failed:", error);
                appendToOutput(`Error creating backup: ${error.message}`, true);
                return null;
            }
            return null;
        }

        async function handleImport(args) {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';

            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    appendToOutput("Import cancelled: No file selected.", false, CSS_CONSOLE_LOG_MSG);
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const fileContent = e.target.result;
                        const parsedData = JSON.parse(fileContent);

                        if (typeof parsedData !== 'object' || parsedData === null ||
                            !parsedData.hasOwnProperty('filesystem') ||
                            !parsedData.hasOwnProperty('user') ||
                            !parsedData.hasOwnProperty('currentPath') ||
                            !parsedData.hasOwnProperty('commandHistory') ||
                            !parsedData.hasOwnProperty('backupVersion')) {
                            appendToOutput("Error: Invalid backup file format. Missing essential properties.", true);
                            return;
                        }
                        if (parsedData.backupVersion !== "1.0") { // Example version check
                            appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, false, CSS_WARNING_MSG);
                        }


                        pendingImportData = parsedData;
                        awaitingImportConfirmation = true;
                        appendToOutput(`Backup file '${file.name}' for user '${parsedData.user}' selected.`, false, CSS_CONSOLE_LOG_MSG);
                        appendToOutput(`This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`, false, CSS_WARNING_MSG);
                        appendToOutput("Type 'YES' (all caps) to confirm import, or any other input to cancel.", false, CSS_WARNING_MSG);

                    } catch (parseError) {
                        console.error("Import error - parsing JSON:", parseError);
                        appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", true);
                        pendingImportData = null;
                        awaitingImportConfirmation = false;
                    }
                };
                reader.onerror = (e) => {
                    console.error("Import error - reading file:", e);
                    appendToOutput("Error: Could not read the selected file.", true);
                    pendingImportData = null;
                    awaitingImportConfirmation = false;
                };
                reader.readAsText(file);
            };

            fileInput.click();
            return null;
        }


        // --- Command Registry ---
        const commandRegistry = {
            'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch,
            'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd,
            'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep,
            'sort': handleSort,
            'sysmon': handleSysmon,
            'mv': handleMv, 'cp': handleCp,
            'clear': handleClear,
            'register': handleRegister, 'login': handleLogin, 'logout': handleLogout,
            'savestate': handleManualSaveState, 'loadstate': handleManualLoadState,
            'reset': handleReset, 'help': handleHelp, 'man': handleMan,
            'edit': handleEdit,
            'diag': handleDiag,
            'tree': handleTree,
            'find': handleFind,
            'du': handleDu,
            'head': handleHead,
            'tail': handleTail,
            'export': handleExport,
            'backup': handleBackup,
            'import': handleImport
        };

        // --- UI Update Functions ---
        function updatePrompt() {
            promptUserSpan.textContent = currentUser;
            promptHostSpan.textContent = OS_NAME;
            promptPathSpan.textContent = currentPath.trim() === '' ? '/' : currentPath;
        }

        // --- Command Processing ---
        async function processCommand(commandInputText, isInteractive = true) {
            if (isEditingFile && !isRunningDiag) return true;
            lastCommandFailed = false;
            let commandSuccessful = true;

            const trimmedCommand = commandInputText.trim();

            if (isInteractive && !isRunningDiag) {
                let displayCommand = trimmedCommand;
                if (isPasswordInputActive && passwordMaskStartIndex !== -1 && trimmedCommand.length > passwordMaskStartIndex) {
                    const prefix = trimmedCommand.substring(0, passwordMaskStartIndex);
                    const suffixToMask = trimmedCommand.substring(passwordMaskStartIndex);
                    displayCommand = prefix + '*'.repeat(suffixToMask.length);
                }
                const promptText = `${promptUserSpan.textContent}@${promptHostSpan.textContent}:${promptPathSpan.textContent}> `;
                appendToOutput(`${promptText}${displayCommand}`);
            } else if (!isInteractive && !isRunningDiag && trimmedCommand) {
                 appendToOutput(`> ${trimmedCommand}`);
            }


            if (isInteractive && trimmedCommand && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== trimmedCommand)) {
                commandHistory.push(trimmedCommand);
                if (commandHistory.length > MAX_HISTORY_SIZE) commandHistory.shift();
            }
            if (isInteractive) {
                if (!isNavigatingHistory) {
                    historyIndex = commandHistory.length;
                }
            }


            if (awaitingResetConfirmation) {
                if (trimmedCommand === 'YES') { await performFullReset(); }
                else { appendToOutput("Reset cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingResetConfirmation = false;
            } else if (awaitingLoadstateConfirmation) {
                 if (trimmedCommand === 'YES' && pendingManualStateToLoad) {
                    fsData = deepCopyNode(pendingManualStateToLoad.fsDataSnapshot) || { '/': { type: 'directory', children: {} } };
                    currentPath = pendingManualStateToLoad.currentPath || '/';
                    outputDiv.innerHTML = pendingManualStateToLoad.outputHTML || '';
                    hiddenInput.value = pendingManualStateToLoad.currentInput || '';
                    await saveFileSystemData(); // Save for current user
                    appendToOutput("Session loaded from manual save.", false, CSS_SUCCESS_MSG);
                    updateVisualInput(); updatePrompt(); outputDiv.scrollTop = outputDiv.scrollHeight;
                } else { appendToOutput("Load state cancelled.", false, CSS_CONSOLE_LOG_MSG); }
                awaitingLoadstateConfirmation = false; pendingManualStateToLoad = null;
            } else if (awaitingRmConfirmation && !isRunningDiag) {
                if (trimmedCommand === 'YES' && itemToRemovePath) {
                    const parentPath = itemToRemovePath.substring(0, itemToRemovePath.lastIndexOf('/')) || '/';
                    const itemName = itemToRemovePath.substring(itemToRemovePath.lastIndexOf('/') + 1);
                    const parentNode = getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await saveFileSystemData()) commandSuccessful = false;
                        else appendToOutput(`'${itemToRemovePath}' removed.`, false, CSS_SUCCESS_MSG);
                    } else { appendToOutput(`Error removing '${itemToRemovePath}': Item not found or parent changed.`, true); commandSuccessful = false;}
                } else { appendToOutput(`Removal of '${itemToRemovePath || 'item'}' cancelled.`, false, CSS_CONSOLE_LOG_MSG); }
                awaitingRmConfirmation = false; itemToRemovePath = null;
            } else if (awaitingImportConfirmation) {
                if (trimmedCommand === 'YES' && pendingImportData) {
                    const importedUser = pendingImportData.user;
                    
                    // Save current user's UI state before switching, if they are not Guest and not the imported user
                    if (currentUser !== DEFAULT_USER && currentUser !== importedUser && !isRunningDiag) {
                        saveAutomaticSessionState(); 
                    }

                    currentUser = importedUser;
                    fsData = deepCopyNode(pendingImportData.filesystem) || { '/': { type: 'directory', children: {} } };
                    currentPath = pendingImportData.currentPath || '/';
                    commandHistory = Array.isArray(pendingImportData.commandHistory) ? [...pendingImportData.commandHistory] : [];
                    historyIndex = commandHistory.length;

                    outputDiv.innerHTML = ''; // Clear current output
                    // Optionally, restore output from backup if it was stored:
                    // if (pendingImportData.currentTerminalOutput) outputDiv.innerHTML = pendingImportData.currentTerminalOutput;
                    hiddenInput.value = ''; // Clear current input
                    // if (pendingImportData.currentTerminalInput) hiddenInput.value = pendingImportData.currentTerminalInput;


                    await saveFileSystemData(currentUser); // Save FS for the (now) current user
                    // Check if user exists in credentials, if not, they can't "login" with a password but session is restored
                    const credentials = getUserCredentials();
                    if (!credentials[currentUser] && currentUser !== DEFAULT_USER) {
                         appendToOutput(`Warning: User '${currentUser}' from backup does not have credentials. Session restored, but login for this user is not possible without registering.`, false, CSS_WARNING_MSG);
                    }

                    appendToOutput(`Session for user '${currentUser}' successfully imported and restored.`, false, CSS_SUCCESS_MSG);
                    updateVisualInput();
                    updatePrompt();
                    outputDiv.scrollTop = outputDiv.scrollHeight;
                } else {
                    appendToOutput("Import cancelled.", false, CSS_CONSOLE_LOG_MSG);
                }
                awaitingImportConfirmation = false;
                pendingImportData = null;
            } else {
                let commandToExecute = trimmedCommand;
                let redirectionType = null;
                let redirectionFile = null;

                const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/);
                if (appendMatch) {
                    redirectionType = 'append';
                    redirectionFile = appendMatch[1];
                    commandToExecute = commandToExecute.substring(0, appendMatch.index).trim();
                } else {
                    const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/);
                    if (overwriteMatch) {
                        redirectionType = 'overwrite';
                        redirectionFile = overwriteMatch[1];
                        commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim();
                    }
                }


                if (commandToExecute !== '') {
                    const parts = commandToExecute.split(' ').filter(p => p);
                    const baseCommand = parts[0].toLowerCase();
                    let args;

                    if (baseCommand === 'echo') {
                        args = [commandToExecute.substring(baseCommand.length).trimStart()];
                    } else if (['find', 'grep', 'head', 'tail', 'export', 'backup', 'import'].includes(baseCommand)) {
                        args = parts.slice(1);
                    }
                    else {
                        args = parts.slice(1);
                    }


                    const handler = commandRegistry[baseCommand];
                    if (handler) {
                        let commandOutput = null;
                        try {
                            commandOutput = await handler(args);
                            if (lastCommandFailed) commandSuccessful = false;

                            if (redirectionType && redirectionFile) {
                                if (lastCommandFailed) {
                                    appendToOutput(`Error: Command '${baseCommand}' failed. Output not redirected to '${redirectionFile}'.`, true);
                                } else {
                                    const targetAbsPathForRedir = getAbsolutePath(redirectionFile, currentPath);
                                    if (targetAbsPathForRedir === '/') {
                                        appendToOutput(`Error: cannot redirect output to root '/'`, true);
                                        commandSuccessful = false;
                                    } else {
                                        const parentNodeForRedir = createParentDirectoriesIfNeeded(targetAbsPathForRedir);
                                        if (!parentNodeForRedir) {
                                            commandSuccessful = false;
                                        } else {
                                            const newFileNameForRedir = targetAbsPathForRedir.substring(targetAbsPathForRedir.lastIndexOf('/') + 1);
                                            const targetNodeForRedir = parentNodeForRedir.children[newFileNameForRedir];

                                            if (targetNodeForRedir?.type === 'directory') {
                                                appendToOutput(`Error: cannot write to '${redirectionFile}': It is a directory.`, true);
                                                commandSuccessful = false;
                                            } else {
                                                let contentToWrite = "";
                                                if (commandOutput !== null && commandOutput !== undefined) { contentToWrite = String(commandOutput); }

                                                if (redirectionType === 'overwrite' || !targetNodeForRedir) {
                                                    parentNodeForRedir.children[newFileNameForRedir] = { type: 'file', content: contentToWrite };
                                                } else if (redirectionType === 'append') {
                                                    const existingContent = targetNodeForRedir?.content || "";
                                                    const separator = (existingContent && contentToWrite) ? "\n" : "";
                                                    parentNodeForRedir.children[newFileNameForRedir].content = existingContent + separator + contentToWrite;
                                                }
                                                if(!await saveFileSystemData()) commandSuccessful = false;
                                            }
                                        }
                                    }
                                }
                            } else if (commandOutput !== null && commandOutput !== undefined && !isRunningDiag) {
                                const lines = String(commandOutput).split('\n');
                                lines.forEach(line => {
                                    if (baseCommand === 'man' || baseCommand === 'sysmon') { /* Already handled by appendHtmlToOutput */ }
                                    else if (baseCommand === 'ls' && line.endsWith('/')) { appendToOutput(line, false, CSS_DIR_ITEM); }
                                    else { appendToOutput(line); }
                                });
                            }
                            if(lastCommandFailed) commandSuccessful = false;

                        } catch (e) {
                            console.error(`Error in '${baseCommand}':`, e);
                            if (!isRunningDiag) {
                                appendToOutput(`Unexpected error executing '${baseCommand}'. Check console.`, true);
                            } else {
                                appendToOutput(`  ERROR in '${baseCommand}': ${e.message}`, true, 'diag-output');
                            }
                            commandSuccessful = false;
                        }
                    } else {
                         if (!isRunningDiag) {
                            appendToOutput(`Error: Command not found: "${parts[0]}"`, true);
                        } else {
                            appendToOutput(`  ERROR: Command not found: "${parts[0]}"`, true, 'diag-output');
                        }
                        commandSuccessful = false;
                    }
                } else if (trimmedCommand === '') {
                    commandSuccessful = true;
                    lastCommandFailed = false;
                }
            }

            if (isInteractive && !isRunningDiag) {
                hiddenInput.value = '';
                isPasswordInputActive = false; passwordMaskStartIndex = -1;
                updateVisualInput();
            }

            if (!isEditingFile && !awaitingLoadstateConfirmation && !awaitingResetConfirmation && !awaitingRmConfirmation && !awaitingImportConfirmation &&!isRunningDiag) {
                updatePrompt();
            }
            return commandSuccessful;
        }

        // --- Event Listeners ---
        terminalDiv.addEventListener('click', e => {
            if (isEditingFile) {
                if (editorTextareaElement && editorWrapperDiv && editorWrapperDiv.contains(e.target) && e.target !== editorTextareaElement) {
                     editorTextareaElement.focus();
                }
                return;
            }
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A' && !e.target.closest('#visual-input-container')) {
                hiddenInput.focus();
            }
            if (e.target.closest('.input-line') || e.target.id === 'terminal') {
                 hiddenInput.focus();
            }
        });

        hiddenInput.addEventListener('keydown', async e => {
            if (isEditingFile) { e.preventDefault(); return; }
            isNavigatingHistory = false;

            if (e.key === 'Enter') {
                e.preventDefault();
                await processCommand(hiddenInput.value, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex > 0) {
                    isNavigatingHistory = true;
                    historyIndex--;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                    isNavigatingHistory = true;
                    historyIndex++;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                } else if (historyIndex >= commandHistory.length - 1) {
                    isNavigatingHistory = true;
                    historyIndex = commandHistory.length;
                    hiddenInput.value = "";
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
            } else if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'Backspace', 'Delete'].includes(e.key)) {
                setTimeout(() => hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })), 0);
            }
        });

        hiddenInput.addEventListener('input', (event) => {
            if (isEditingFile) return;

            const rawInput = hiddenInput.value;
            isPasswordInputActive = false;
            passwordMaskStartIndex = -1;

            const passwordCommandRegex = /^(login|register)(\s+)(\S+)(\s+)(.*)$/i;
            const match = rawInput.match(passwordCommandRegex);

            if (match) {
                passwordMaskStartIndex = match[1].length + match[2].length + match[3].length + match[4].length;
                isPasswordInputActive = true;
            } else {
                const prefixRegex = /^(login|register)(\s+)(\S+)$/i;
                const prefixMatch = rawInput.match(prefixRegex);
                if (prefixMatch && rawInput.endsWith(' ')) {
                    isPasswordInputActive = true;
                    passwordMaskStartIndex = rawInput.length;
                }
            }
            updateVisualInput();

            if (!isNavigatingHistory) {
                 historyIndex = commandHistory.length;
            }
        });


        // --- Initialization ---
        window.onload = async () => {
            console.warn("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.");
            try {
                await initDB();
                currentUser = DEFAULT_USER;
                await loadFileSystemData(currentUser);
                loadAutomaticSessionState(currentUser);

                setTimeout(() => { if (!isEditingFile) hiddenInput.focus(); }, 100);
                console.log(`${OS_NAME} v.${OS_VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details.", true);
                hiddenInput.disabled = true;
            }
        };
    </script></body>
</html>
