<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OopisOs v.0.3.0</title> <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #terminal-bezel {
            background-color: #2c2c2c;
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                inset 0 0 10px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3),
                0 0 3px 1px #111;
            display: inline-block;
        }
        #terminal {
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            background-color: #0d0d0d;
            border: 2px solid #181818;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 0 15px rgba(0, 255, 0, 0.15);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #0d0d0d;
        }
        #terminal::-webkit-scrollbar { width: 10px; }
        #terminal::-webkit-scrollbar-track { background: #0d0d0d; border-radius: 8px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #00ff00; border-radius: 10px; border: 2px solid #0d0d0d; }
        #terminal::-webkit-scrollbar-thumb:hover { background-color: #00cc00; }

        #output { flex-grow: 1; margin-bottom: 10px; overflow-x: hidden; width: 100%; min-width: 0; overflow-y: auto;}
        .output-line {
            white-space: pre-wrap;
            word-break: break-all;
            overflow-wrap: break-word;
            overflow-x: hidden;
            min-height: 1.2em;
        }

        .input-line { display: flex; align-items: center; width: 100%; }
        .prompt-user { margin-right: 2px; color: #7fdbff; }
        .prompt-separator, .prompt-host { margin-right: 2px; }
        .prompt-path { margin-right: 4px; }
        .prompt-char { margin-right: 8px; }

        #visual-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        #input-before-cursor, #input-after-cursor {
            white-space: pre;
            display: inline-block;
        }
        .cursor {
            width: 10px;
            height: 1.2em;
            background-color: #00ff00;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #hidden-input { position: absolute; opacity: 0; width: 1px; height: 1px; top: -10px; left: -10px; }

        .error-message { color: #ff4136; }
        .console-log-message { color: #aaaaaa; }
        .directory-item { color: #7fdbff; }
        .file-item { }
        .success-message { color: #2ecc40; }
        .warning-message { color: #ff851b; }
        .help-command-name, .man-section-title { color: #7fdbff; font-weight: bold; }
        .help-description, .man-section-content { margin-left: 10px; }
        .man-example { margin-left: 20px; font-style: italic; color: #aaffaa; }
        .sysmon-label { color: #7fdbff; }

        /* Editor specific styles */
        #editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #editor-textarea {
            flex-grow: 1;
            width: 100%;
            background-color: #0c0c0c;
            color: #00dd00;
            border: 1px solid #222;
            font-family: 'VT323', monospace;
            font-size: 1em;
            line-height: 1.2em;
            resize: none;
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 4px;
            overflow-y: auto;
        }
        #editor-instructions {
            padding: 5px 0;
            font-size: 0.9em;
            text-align: center;
            color: #aaa;
            flex-shrink: 0;
        }
        .diag-output-block {
        }

    </style>
</head>
<body>
    <div id="terminal-bezel">
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line">
                <span id="prompt-user" class="prompt-user"></span>
                <span class="prompt-separator">@</span>
                <span id="prompt-host" class="prompt-host">OopisOs</span>
                <span class="prompt-separator">:</span>
                <span id="prompt-path" class="prompt-path"></span>
                <span class="prompt-char">&gt;</span>
                <div id="visual-input-container">
                    <span id="input-before-cursor"></span>
                    <div class="cursor"></div>
                    <span id="input-after-cursor"></span>
                </div>
            </div>
            <input type="text" id="hidden-input" autofocus autocapitalize="none" autocorrect="off" spellcheck="false">
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const terminalDiv = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const standardInputLineDiv = terminalDiv.querySelector('.input-line');
        const inputBeforeCursorSpan = document.getElementById('input-before-cursor');
        const inputAfterCursorSpan = document.getElementById('input-after-cursor');
        const hiddenInput = document.getElementById('hidden-input');
        const promptUserSpan = document.getElementById('prompt-user');
        const promptPathSpan = document.getElementById('prompt-path');
        const promptHostSpan = document.getElementById('prompt-host');

        // --- Constants ---
        const USER_CREDENTIALS_KEY = 'oopisOsUserCredentials';
        const USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsUserTerminalState_';
        const MANUAL_USER_TERMINAL_STATE_KEY_PREFIX = 'oopisOsManualUserTerminalState_';
        const DEFAULT_USER = "Guest";
        const OS_NAME = "OopisOs";
        const OS_VERSION = "0.3.0.0"; // Updated OS Version for alias command
        const MAX_HISTORY_SIZE = 50;
        const ALIAS_FILE_PATH = "/.aliases"; // Path for storing aliases
        const MAX_ALIAS_EXPANSION_DEPTH = 10; // To prevent infinite alias loops

        // IndexedDB Constants
        const DB_NAME = "OopisOsDB";
        const DB_VERSION = 1;
        const FS_STORE_NAME = "FileSystemsStore";
        let db;

        // --- CSS Classes ---
        const CSS_ERROR_MSG = 'error-message';
        const CSS_SUCCESS_MSG = 'success-message';
        const CSS_CONSOLE_LOG_MSG = 'console-log-message';
        const CSS_WARNING_MSG = 'warning-message';
        const CSS_DIR_ITEM = 'directory-item';
        const CSS_FILE_ITEM = 'file-item';
        const CSS_HELP_CMD_NAME = 'help-command-name';
        const CSS_HELP_DESC = 'help-description';
        const CSS_OUTPUT_LINE = 'output-line';
        const CSS_MAN_SECTION_TITLE = 'man-section-title';
        const CSS_MAN_SECTION_CONTENT = 'man-section-content';
        const CSS_MAN_EXAMPLE = 'man-example';
        const CSS_SYSMON_LABEL = 'sysmon-label';

        // --- Application State ---
        let fsData = {};
        let currentPath = '/';
        let currentUser = DEFAULT_USER;
        
        let awaitingConfirmation = false;
        let confirmationContext = null; 

        let commandHistory = [];
        let historyIndex = 0;
        let lastCommandFailed = false;
        let isPasswordInputActive = false;
        let passwordMaskStartIndex = -1;
        let isEditingFile = false;
        let editingFilePath = null;
        let editorWrapperDiv = null;
        let editorTextareaElement = null;
        let editorInstructionsDiv = null;
        let isRunningDiag = false;
        let isNavigatingHistory = false;
        let userAliases = {}; // Holds currently loaded aliases for the user


        // --- Helper to format console arguments ---
        function formatConsoleArgs(args) {
            return Array.from(args).map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg) : String(arg)).join(' ');
        }

        // --- Output Management ---
        function appendToOutput(text, isError = false, typeClass = null) {
            if (isEditingFile && typeClass !== 'editor-message' && typeClass !== 'diag-output') return;
            const newLine = document.createElement('div');
            newLine.classList.add(CSS_OUTPUT_LINE);
            if (typeClass) newLine.classList.add(typeClass);
            if (isError && !typeClass) newLine.classList.add(CSS_ERROR_MSG);
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
            outputDiv.scrollTop = outputDiv.scrollHeight;
            if(isError) lastCommandFailed = true;
        }
        function appendHtmlToOutput(htmlContent) {
             if (isEditingFile) return;
             const blockDiv = document.createElement('div');
             blockDiv.innerHTML = htmlContent;
             outputDiv.appendChild(blockDiv);
             outputDiv.scrollTop = outputDiv.scrollHeight;
        }
        function appendStyledOutput(label, value) {
            if (isEditingFile) return;
            const line = document.createElement('div');
            line.classList.add(CSS_OUTPUT_LINE);
            const labelSpan = document.createElement('span');
            labelSpan.classList.add(CSS_SYSMON_LABEL);
            labelSpan.textContent = label.padEnd(20, ' ');
            const valueSpan = document.createElement('span');
            valueSpan.textContent = value;
            line.appendChild(labelSpan);
            line.appendChild(valueSpan);
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        // --- Console Output Redirection ---
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        console.log = (...args) => { if (!isEditingFile) appendToOutput(`LOG: ${formatConsoleArgs(args)}`, false, CSS_CONSOLE_LOG_MSG); originalConsoleLog.apply(console, args); };
        console.warn = (...args) => { if (!isEditingFile) appendToOutput(`WARN: ${formatConsoleArgs(args)}`, false, CSS_WARNING_MSG); originalConsoleWarn.apply(console, args); };
        console.error = (...args) => { if (!isEditingFile) appendToOutput(`ERROR: ${formatConsoleArgs(args)}`, true, CSS_ERROR_MSG); originalConsoleError.apply(console, args); };

        // --- Unified LocalStorage Helpers (for non-filesystem data) ---
        function loadJSONFromStorage(key, itemName, defaultValue = null) {
            try {
                const storedValue = localStorage.getItem(key);
                if (storedValue) return JSON.parse(storedValue);
            } catch (e) {
                if(!isRunningDiag) appendToOutput(`Warning: ${itemName} for '${key}' corrupted. Using default.`, false, CSS_WARNING_MSG);
            }
            return defaultValue;
        }
        function saveJSONToStorage(key, data, itemName) {
            try { localStorage.setItem(key, JSON.stringify(data)); return true; }
            catch (e) {
                if(!isRunningDiag) appendToOutput(`Critical Error: Could not save ${itemName} for '${key}'.`, true, CSS_ERROR_MSG);
            }
            return false;
        }

        // --- IndexedDB Initialization ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(FS_STORE_NAME)) {
                        dbInstance.createObjectStore(FS_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    if (!isRunningDiag && !window.diagInitialized) {
                        appendToOutput("FileSystem DB initialized.", false, CSS_CONSOLE_LOG_MSG);
                        window.diagInitialized = true;
                    }
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("Database error: ", event.target.error);
                    appendToOutput("Critical Error: Could not initialize FileSystem DB.", true, CSS_ERROR_MSG);
                    reject(event.target.error);
                };
            });
        }

        // --- Filesystem Management (IndexedDB) ---
        function getFileSystemKey(user) { return `fs_${user}`; }

        async function initializeFileSystem(user = currentUser) {
            fsData = { '/': { type: 'directory', children: {} } };
            await saveFileSystemData(user);
            await loadAliases(user); // Load aliases after FS init
        }

        async function saveFileSystemData(user = currentUser) {
            if (!db) {
                if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for saving.", true, CSS_ERROR_MSG);
                return Promise.reject("DB not initialized");
            }
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.put({ id: getFileSystemKey(user), data: deepCopyNode(fsData) });
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        console.error(`Error saving FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user}.`, true, CSS_ERROR_MSG);
                        reject(event.target.error);
                    };
                } catch (e) {
                    console.error(`Error initiating save transaction for ${user}:`, e);
                    if (!isRunningDiag) appendToOutput(`Critical Error: Could not save FS for ${user} (transaction error).`, true, CSS_ERROR_MSG);
                    reject(e);
                }
            });
        }

        async function loadFileSystemData(user) {
            if (!db) {
                 if(!isRunningDiag) appendToOutput("Error: Filesystem DB not available for loading.", true, CSS_ERROR_MSG);
                fsData = { '/': { type: 'directory', children: {} } };
                return Promise.reject("DB not initialized");
            }
            return new Promise(async (resolve, reject) => {
                try {
                    const transaction = db.transaction([FS_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(FS_STORE_NAME);
                    const request = store.get(getFileSystemKey(user));
                    request.onsuccess = async (event) => {
                        const result = event.target.result;
                        if (result && result.data && result.data['/']?.type === 'directory') {
                            fsData = result.data;
                        } else {
                            if (!isRunningDiag) appendToOutput(result ? `Invalid FS for ${user}. Reinitializing.` : `No FS for ${user}. Initializing.`, false, result ? CSS_WARNING_MSG : CSS_CONSOLE_LOG_MSG);
                            await initializeFileSystem(user); // This will also load aliases
                        }
                        await loadAliases(user); // Ensure aliases are loaded even if FS existed
                        resolve();
                    };
                    request.onerror = async (event) => {
                        console.error(`Error loading FS for ${user}:`, event.target.error);
                        if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted or unavailable. Initializing new FS.`, false, CSS_WARNING_MSG);
                        await initializeFileSystem(user); // This will also load aliases
                        reject(event.target.error);
                    };
                } catch (e) {
                     console.error(`Error initiating load transaction for ${user}:`, e);
                     if (!isRunningDiag) appendToOutput(`Warning: FS for '${user}' corrupted (transaction error). Initializing new FS.`, false, CSS_WARNING_MSG);
                     await initializeFileSystem(user); // This will also load aliases
                     reject(e);
                }
            });
        }

        async function deleteFileSystemData(user) {
            if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(FS_STORE_NAME);
                const request = store.delete(getFileSystemKey(user));
                request.onsuccess = () => resolve(true);
                request.onerror = (event) => {
                    console.error(`Error deleting FS for ${user}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // --- Visual Input Update ---
        function updateVisualInput() {
            const inputValue = hiddenInput.value;
            const cursorPos = hiddenInput.selectionStart;
            let visualString = inputValue;
            if (isPasswordInputActive && passwordMaskStartIndex !== -1) {
                if (inputValue.length > passwordMaskStartIndex) {
                    const prefix = inputValue.substring(0, passwordMaskStartIndex);
                    const suffixToMask = inputValue.substring(passwordMaskStartIndex);
                    visualString = prefix + '*'.repeat(suffixToMask.length);
                }
            }
            inputBeforeCursorSpan.textContent = visualString.substring(0, cursorPos);
            inputAfterCursorSpan.textContent = visualString.substring(cursorPos);
        }

        // --- Automatic Session State (UI only - localStorage) ---
        function getAutomaticSessionStateKey(user) { return `${USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }
        function saveAutomaticSessionState() {
             const autoState = { currentPath, outputHTML: outputDiv.innerHTML, currentInput: hiddenInput.value };
            saveJSONToStorage(getAutomaticSessionStateKey(currentUser), autoState, `Auto session for ${currentUser}`);
        }
        function loadAutomaticSessionState(user = currentUser) {
            const autoState = loadJSONFromStorage(getAutomaticSessionStateKey(user), `Auto session for ${user}`);
            if (autoState) {
                currentPath = autoState.currentPath || '/';
                if (!isRunningDiag && autoState.hasOwnProperty('outputHTML')) {
                     outputDiv.innerHTML = autoState.outputHTML || '';
                } else if (!isRunningDiag && !autoState.hasOwnProperty('outputHTML')) {
                }
                hiddenInput.value = autoState.currentInput || '';
            } else {
                if (!isRunningDiag) outputDiv.innerHTML = '';
                hiddenInput.value = ''; currentPath = '/';
                if (!isRunningDiag) {
                    appendToOutput(`Welcome, ${user}! Type 'help' for commands.`, false, CSS_CONSOLE_LOG_MSG);
                }
            }
            updateVisualInput();
            updatePrompt();
            if (!isRunningDiag) outputDiv.scrollTop = outputDiv.scrollHeight;
            return !!autoState;
        }

        // --- Manual Save State (fsDataSnapshot will be from memory) ---
        function getManualUserTerminalStateKey(user) { return `${MANUAL_USER_TERMINAL_STATE_KEY_PREFIX}${user}`; }

        // --- Path and Node Utilities ---
        function getAbsolutePath(targetPath, basePath) {
            if (!targetPath) targetPath = '.';
            if (targetPath.startsWith('/')) basePath = '/';

            const baseSegments = basePath === '/' ? [] : basePath.substring(1).split('/').filter(s => s && s !== '.');
            let resolvedSegments = [...baseSegments];
            const targetSegments = targetPath.split('/');

            for (const segment of targetSegments) {
                if (segment === '' || segment === '.') {
                    if (targetPath.startsWith('/') && resolvedSegments.length === 0 && segment === '') {}
                    continue;
                }
                if (segment === '..') {
                    if (resolvedSegments.length > 0) {
                        resolvedSegments.pop();
                    }
                } else {
                    resolvedSegments.push(segment);
                }
            }
            if (targetPath.startsWith('/') && resolvedSegments.length === 0) return '/';
            return resolvedSegments.length === 0 ? '/' : '/' + resolvedSegments.join('/');
        }
        function getNodeByPath(path) {
             if (path === '/') return fsData['/'];
            const segments = path.substring(1).split('/').filter(s => s);
            let currentNode = fsData['/'];
            for (const segment of segments) {
                if (currentNode && currentNode.type === 'directory' && currentNode.children && currentNode.children[segment]) {
                    currentNode = currentNode.children[segment];
                } else return null;
            }
            return currentNode;
        }
        function deepCopyNode(node) { return node ? JSON.parse(JSON.stringify(node)) : null; }

        // --- User Credentials Management (localStorage) ---
        function getUserCredentials() { return loadJSONFromStorage(USER_CREDENTIALS_KEY, "User creds", {}); }
        function saveUserCredentials(credentials) { return saveJSONToStorage(USER_CREDENTIALS_KEY, credentials, "User creds"); }

        // --- Password Hashing ---
        async function hashPassword(password) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            } catch (error) {
                console.error("Password hashing failed:", error);
                appendToOutput("Critical error: Password hashing service unavailable.", true, CSS_ERROR_MSG);
                throw error;
            }
        }

        // --- Helper to create parent directories ---
        function createParentDirectoriesIfNeeded(fullPath) {
            if (fullPath === '/') return { parentNode: null, error: "Cannot create parent for root." }; 
            const lastSlashIndex = fullPath.lastIndexOf('/');
            if (lastSlashIndex === -1 && fullPath.startsWith('/')) { 
                 return { parentNode: fsData['/'], error: null };
            }
             if (lastSlashIndex === -1 && !fullPath.startsWith('/')) { 
                 return { parentNode: fsData['/'], error: null };
            }

            const parentPath = lastSlashIndex === 0 ? '/' : fullPath.substring(0, lastSlashIndex);
            const newFileName = fullPath.substring(lastSlashIndex + 1); 

            if (!newFileName || newFileName === "." || newFileName === "..") {
                return { parentNode: null, error: `Invalid name component '${newFileName}' in path '${fullPath}'` };
            }

            if (parentPath === '/') return { parentNode: fsData['/'], error: null };

            const parentPathSegments = parentPath.substring(1).split('/').filter(s => s);
            let currentDirNode = fsData['/'];
            let currentBuiltParentPath = "";

            for (const segment of parentPathSegments) {
                currentBuiltParentPath += "/" + segment;
                if (!currentDirNode.children[segment]) {
                    currentDirNode.children[segment] = { type: 'directory', children: {} };
                } else if (currentDirNode.children[segment].type !== 'directory') {
                    return { parentNode: null, error: `Path component '${currentBuiltParentPath}' is not a directory.` };
                }
                currentDirNode = currentDirNode.children[segment];
            }
            return { parentNode: currentDirNode, error: null };
        }


        // --- Byte Formatting Helper ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- Argument Parsing Helpers ---
        function parseNumericOption(args, optionStr, defaultValue) {
            let numericValue = defaultValue;
            const remainingArgs = [...args];
            let error = null;
            const optionIndex = remainingArgs.indexOf(optionStr);

            if (optionIndex !== -1) {
                if (optionIndex + 1 < remainingArgs.length) {
                    const potentialNumber = remainingArgs[optionIndex + 1];
                    const parsedNumber = parseInt(potentialNumber, 10);
                    if (!isNaN(parsedNumber) && parsedNumber > 0) {
                        numericValue = parsedNumber;
                        remainingArgs.splice(optionIndex, 2);
                    } else {
                        error = `invalid numeric value for ${optionStr}: '${potentialNumber}'`;
                        remainingArgs.splice(optionIndex, 2);
                    }
                } else {
                    error = `option ${optionStr} requires an argument`;
                    remainingArgs.splice(optionIndex, 1);
                }
            }
            return { value: numericValue, remainingArgs, error };
        }

        function validatePath(commandName, pathArg, options = {}) {
            const {
                expectedType = 'any',
                allowMissing = false,
                disallowRoot = false,
                defaultToCurrentIfEmpty = true
            } = options;

            let effectivePathArg = pathArg;
            if (defaultToCurrentIfEmpty && (pathArg === undefined || pathArg === null || String(pathArg).trim() === '')) {
                effectivePathArg = '.';
            }

            if (effectivePathArg === undefined || effectivePathArg === null) {
                 return { node: null, resolvedPath: null, error: `${commandName}: missing path operand` };
            }

            const resolvedPath = getAbsolutePath(String(effectivePathArg), currentPath);
            const node = getNodeByPath(resolvedPath);

            if (disallowRoot && resolvedPath === '/') {
                return { node: null, resolvedPath: resolvedPath, error: `${commandName}: operation not permitted on root directory '/'` };
            }

            if (node) {
                if (expectedType === 'file' && node.type !== 'file') {
                    return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Is a directory` };
                }
                if (expectedType === 'directory' && node.type !== 'directory') {
                    return { node: node, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': Not a directory` };
                }
                return { node: node, resolvedPath: resolvedPath, error: null };
            } else {
                if (allowMissing) {
                    return { node: null, resolvedPath: resolvedPath, error: null };
                } else {
                    return { node: null, resolvedPath: resolvedPath, error: `${commandName}: '${pathArg}': No such file or directory` };
                }
            }
        }

        // --- Generic Confirmation Helper ---
        function requestConfirmation(promptMessageLines, dataForAction, onConfirmCallback, onCancelCallback = null) {
            awaitingConfirmation = true;
            confirmationContext = {
                promptMessageLines: Array.isArray(promptMessageLines) ? promptMessageLines : [promptMessageLines],
                data: dataForAction,
                onConfirm: onConfirmCallback,
                onCancel: onCancelCallback
            };
            confirmationContext.promptMessageLines.forEach(line => {
                appendToOutput(line, false, CSS_WARNING_MSG);
            });
            appendToOutput("Type 'YES' (all caps) to confirm, or any other input to cancel.", false, CSS_WARNING_MSG);
        }

        // --- Redirection Helper ---
        async function handleRedirection(commandName, commandOutput, redirectionType, redirectionFile) {
            if (!redirectionFile) { 
                appendToOutput(`${commandName}: internal error: redirection file not specified.`, true);
                return false;
            }

            const validation = validatePath(commandName, redirectionFile, {
                expectedType: 'file', 
                allowMissing: true,   
                disallowRoot: true,   
                defaultToCurrentIfEmpty: false 
            });

            if (validation.error) {
                if (validation.node && validation.node.type === 'directory') {
                     appendToOutput(`${commandName}: cannot redirect to '${redirectionFile}': It is a directory.`, true);
                } else {
                    appendToOutput(validation.error, true); 
                }
                return false;
            }

            const targetAbsPath = validation.resolvedPath;
            const parentDirCreationResult = createParentDirectoriesIfNeeded(targetAbsPath); 

            if (parentDirCreationResult.error) { 
                appendToOutput(`${commandName}: ${parentDirCreationResult.error}`, true); 
                return false; 
            }
            const parentNode = parentDirCreationResult.parentNode; 

            if (!parentNode) { 
                appendToOutput(`${commandName}: error obtaining parent directory for redirection target '${redirectionFile}'.`, true);
                return false;
            }

            const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);
            const targetNode = parentNode.children[newFileName]; 

            let contentToWrite = (commandOutput !== null && commandOutput !== undefined) ? String(commandOutput) : "";

            if (redirectionType === 'overwrite' || !targetNode) {
                parentNode.children[newFileName] = { type: 'file', content: contentToWrite };
            } else if (redirectionType === 'append' && targetNode.type === 'file') {
                const existingContent = targetNode.content || "";
                const separator = (existingContent && contentToWrite) ? "\n" : "";
                parentNode.children[newFileName].content = existingContent + separator + contentToWrite;
            } else {
                appendToOutput(`${commandName}: cannot write to '${redirectionFile}': Unexpected target type.`, true);
                return false;
            }

            if (!await saveFileSystemData()) {
                appendToOutput(`${commandName}: failed to save redirected output to '${redirectionFile}'.`, true);
                return false;
            }
            return true;
        }
        
        // --- Diff Algorithm Helper (LCS) ---
        function findLCS(X, Y) {
            const m = X.length;
            const n = Y.length;
            const L = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    if (i === 0 || j === 0) {
                        L[i][j] = 0;
                    } else if (X[i - 1] === Y[j - 1]) {
                        L[i][j] = L[i - 1][j - 1] + 1;
                    } else {
                        L[i][j] = Math.max(L[i - 1][j], L[i][j - 1]);
                    }
                }
            }

            let index = L[m][n];
            const lcs = Array(index); 

            let i = m, j = n;
            while (i > 0 && j > 0) {
                if (X[i - 1] === Y[j - 1]) {
                    lcs[index - 1] = X[i - 1]; 
                    i--; j--; index--; 
                } else if (L[i - 1][j] > L[i][j - 1]) {
                    i--;
                } else {
                    j--;
                }
            }
            return lcs;
        }

        // --- Alias Management ---
        async function loadAliases(user = currentUser) {
            userAliases = {}; // Reset for current user
            const aliasFileNode = getNodeByPath(getAbsolutePath(ALIAS_FILE_PATH, '/')); // Aliases are always at root
            if (aliasFileNode && aliasFileNode.type === 'file') {
                try {
                    const parsed = JSON.parse(aliasFileNode.content);
                    if (typeof parsed === 'object' && parsed !== null) {
                        userAliases = parsed;
                    } else {
                        // appendToOutput(`Warning: Alias file '${ALIAS_FILE_PATH}' is not a valid JSON object. Ignoring.`, false, CSS_WARNING_MSG);
                    }
                } catch (e) {
                    // appendToOutput(`Warning: Could not parse alias file '${ALIAS_FILE_PATH}'. Error: ${e.message}`, false, CSS_WARNING_MSG);
                }
            }
            // No message if file doesn't exist, just means no aliases.
        }

        async function saveAliases(user = currentUser) {
            const aliasJsonString = JSON.stringify(userAliases, null, 2);
            
            // Use existing file writing logic, effectively: echo "content" > ALIAS_FILE_PATH
            // Need to handle this carefully to avoid processCommand recursion if echo itself is aliased.
            // Direct file node manipulation is safer here.
            const parentNode = getNodeByPath('/'); // Parent is always root for ALIAS_FILE_PATH
            if (parentNode) {
                const aliasFileName = ALIAS_FILE_PATH.substring(1); // remove leading '/'
                parentNode.children[aliasFileName] = { type: 'file', content: aliasJsonString };
                await saveFileSystemData(user); // Save the entire FS
            } else {
                // This should ideally not happen as root always exists.
                appendToOutput("Critical error: Could not save aliases. Root directory not found.", true);
            }
        }

        async function expandAlias(commandInputText, depth = 0) {
            if (depth > MAX_ALIAS_EXPANSION_DEPTH) {
                appendToOutput(`alias: Maximum expansion depth exceeded (possible loop).`, true);
                return commandInputText; // Return original to prevent infinite loop
            }

            const parts = commandInputText.trim().split(' ');
            const potentialAlias = parts[0];
            
            if (userAliases.hasOwnProperty(potentialAlias)) {
                const aliasValue = userAliases[potentialAlias];
                const remainingArgs = parts.slice(1).join(' ');
                const expandedCommand = (aliasValue + (remainingArgs ? ' ' + remainingArgs : '')).trim();
                
                // Recursively expand if the new command also starts with an alias
                if (userAliases.hasOwnProperty(expandedCommand.split(' ')[0])) {
                    return await expandAlias(expandedCommand, depth + 1);
                }
                return expandedCommand;
            }
            return commandInputText; // No alias found, return original
        }


        // --- Command Help Data ---
        const commandHelpData = {
            'ls': { usage: 'ls [path/to/directory]', summary: 'Lists directory contents.', syntax: 'ls [PATH]', details: 'Displays a list of files and directories within the specified PATH. If PATH is omitted, it lists the contents of the current working directory. Directories are indicated with a trailing slash (/). Output can be redirected.', examples: ['ls', 'ls /my_stuff > file_list.txt', 'ls ../old_projects']},
            'cd': { usage: 'cd <path/to/directory>', summary: 'Changes current directory.', syntax: 'cd DIRECTORY', details: 'Changes the current working directory to the specified DIRECTORY. Use "cd .." to navigate to the parent directory. Use "cd /" to navigate to the root directory. Relative and absolute paths are supported. Provides feedback if already in the target directory.', examples: ['cd /home/user/documents', 'cd ../images', 'cd project_alpha']},
            'mkdir': { usage: 'mkdir <path/to/new_directory_name>', summary: 'Creates a new directory, including parents.', syntax: 'mkdir DIRECTORY_PATH', details: 'Creates a new directory at the specified DIRECTORY_PATH. If any parent directories in the path do not exist, they will be created automatically (similar to mkdir -p). Provides feedback if directory already exists or if a file blocks path creation.', examples: ['mkdir new_folder', 'mkdir /projects/alpha/assets', 'mkdir backups/2025/may']},
            'touch': { usage: 'touch <path/to/filename>', summary: 'Creates an empty file or updates timestamp.', syntax: 'touch FILE_PATH', details: 'Creates a new, empty file at the specified FILE_PATH if it does not exist. If any parent directories in the path do not exist, they will be created automatically. If the file already exists, its timestamp is conceptually updated (no content change) and a message is shown.', examples: ['touch new_document.txt', 'touch /logs/today.log', 'touch notes/project_x/ideas.md']},
            'cat': { usage: 'cat <path/to/filename>', summary: 'Displays file contents.', syntax: 'cat FILE_PATH', details: 'Displays the full contents of the file specified by FILE_PATH on the screen. This command is intended for text files. Output can be redirected.', examples: ['cat my_file.txt', 'cat /config/settings.conf > settings_backup.txt']},
            'echo': { usage: 'echo [text]', summary: 'Displays text, stripping outer quotes.', syntax: 'echo [STRING...]', details: 'Displays the given STRING(s) to the terminal. If the entire output string is surrounded by a matching pair of double or single quotes, they are removed before display/redirection. To write to a file, use redirection operators > (overwrite) or >> (append) after the command, e.g., echo "text" > filename.txt.', examples: ['echo Hello World!', 'echo "My new note" > notes.txt', 'echo \'Another line\' >> notes.txt']},
            'mv': { usage: 'mv <source_path> <destination_path>', summary: 'Moves or renames a file or directory.', syntax: 'mv SOURCE DESTINATION', details: 'Moves (renames) SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is moved into that directory. Cannot move a directory into itself or one of its own subdirectories.', examples: ['mv old_name.txt new_name.txt', 'mv report.doc /archives/', 'mv /temp/data /processed_data/june_data']},
            'cp': { usage: 'cp <source_path> <destination_path>', summary: 'Copies a file or directory.', syntax: 'cp SOURCE DESTINATION', details: 'Copies SOURCE to DESTINATION. If DESTINATION is an existing directory, SOURCE is copied into that directory. Copying a directory also copies all its contents recursively. Cannot copy a directory into itself or one of its own subdirectories.', examples: ['cp original.txt backup.txt', 'cp image.jpg /gallery/photos/', 'cp /assets/logo.png /website/img/logo_copy.png']},
            'rm': { usage: 'rm <path/to/item>', summary: 'Removes a file or directory (confirms).', syntax: 'rm ITEM_PATH', details: 'Removes the file or directory specified by ITEM_PATH. If ITEM_PATH is a directory, it and all its contents will be removed recursively. This command requires confirmation before deletion as it cannot be undone. The root directory ("/") cannot be removed.', examples: ['rm old_file.txt', 'rm /temp/junk_folder']},
            'pwd': { usage: 'pwd', summary: 'Prints the current working directory path.', syntax: 'pwd', details: 'Displays the full absolute path of the current working directory. Output can be redirected.', examples: ['pwd', 'pwd > current_dir.txt']},
            'date': { usage: 'date', summary: 'Displays the current date and time.', syntax: 'date', details: 'Shows the current system date and time in a standard format. Output can be redirected.', examples: ['date', 'date > timestamp.log']},
            'whoami': { usage: 'whoami', summary: 'Displays the current user\'s username.', syntax: 'whoami', details: 'Prints the username of the currently logged-in user. Output can be redirected.', examples: ['whoami', 'whoami > user.txt']},
            'run': { usage: 'run <path/to/scriptfile>', summary: 'Executes commands from a script file.', syntax: 'run SCRIPT_FILE_PATH', details: 'Reads and executes OopisOs commands from the specified SCRIPT_FILE_PATH, one command per line. Lines starting with "#" are treated as comments and ignored. Script execution stops if a command within the script encounters an error. Commands executed from a script are not added to the interactive command history.', examples: ['run setup_project.sh', 'run /scripts/daily_backup.txt']},
            'grep': { usage: 'grep "PATTERN" <path/to/filename>', summary: 'Searches for a PATTERN in a file.', syntax: 'grep PATTERN FILE_PATH', details: 'Searches for PATTERN in the specified FILE_PATH and prints lines that contain the pattern. The search is case-sensitive. If PATTERN contains spaces, it must be enclosed in double quotes. Output can be redirected.', examples: ['grep "error" logfile.txt', 'grep "version 1.0" /docs/readme.md > version_mentions.txt']},
            'sort': { usage: 'sort <path/to/filename>', summary: 'Sorts lines of a text file.', syntax: 'sort FILE_PATH', details: 'Reads the specified FILE_PATH, sorts its lines alphabetically (case-sensitive), and prints the result. Output can be redirected.', examples: ['sort names.txt', 'sort unsorted_list.txt > sorted_list.txt']},
            'sysmon': { usage: 'sysmon', summary: 'Displays virtual system hardware information.', syntax: 'sysmon', details: 'Shows conceptual specifications of the OopisOs virtual machine environment, including CPU, RAM, Storage, and OS details.', examples: ['sysmon']},
            'clear': { usage: 'clear', summary: 'Clears the terminal screen.', syntax: 'clear', details: 'Clears all visible output from the terminal screen, providing a fresh prompt at the top.', examples: ['clear']},
            'register': { usage: 'register <username> <password>', summary: 'Creates a new user profile (passwords hashed & masked).', syntax: 'register USERNAME PASSWORD', details: 'Registers a new user with the given USERNAME and PASSWORD. Usernames are unique. The username "Guest" is reserved. Passwords are securely hashed before storage and input is masked.', examples: ['register myuser mysecretpass']},
            'login': { usage: 'login <username> <password>', summary: 'Logs in as a specified user (passwords hashed & masked).', syntax: 'login USERNAME PASSWORD', details: 'Logs in as the specified USERNAME using the provided PASSWORD. The entered password will be hashed, compared against the stored hash, and input is masked. Provides feedback if already logged in as the target user. This loads the user\'s unique filesystem and session state.', examples: ['login myuser mysecretpass']},
            'logout': { usage: 'logout', summary: 'Logs out the current user.', syntax: 'logout', details: 'Logs out the current user and returns to the default Guest session. The current user\'s session UI state is saved automatically.', examples: ['logout']},
            'savestate': { usage: 'savestate', summary: 'Manually saves the current session.', syntax: 'savestate', details: 'Creates a full snapshot of the current session, including the entire filesystem and terminal output. This saved state can be restored later using the "loadstate" command.', examples: ['savestate']},
            'loadstate': { usage: 'loadstate', summary: 'Loads the last manually saved session (confirms).', syntax: 'loadstate', details: 'Loads the last state saved by the "savestate" command for the current user. This is a destructive operation and will overwrite the current session (filesystem and terminal output) after confirmation.', examples: ['loadstate']},
            'reset': { usage: 'reset', summary: 'Performs a full factory reset (confirms).', syntax: 'reset', details: 'Performs a full factory reset of OopisOs. This action deletes ALL users, their filesystems, and any saved states (including hashed passwords). This operation is highly destructive and requires confirmation.', examples: ['reset']},
            'help': { usage: 'help [command_name]', summary: 'Displays command list or brief help.', syntax: 'help [COMMAND]', details: 'Without arguments, "help" lists all available commands and their summaries. If a COMMAND is specified, it displays a short usage summary for that command. For more detailed information, use "man COMMAND".', examples: ['help', 'help ls']},
            'man': { usage: 'man <command_name>', summary: 'Displays detailed manual pages for commands.', syntax: 'man COMMAND', details: 'Displays the full manual page for the specified COMMAND, including syntax, detailed explanation, and examples.', examples: ['man mkdir']},
            'edit': { usage: 'edit <path/to/filename>', summary: 'Edits a text file or creates a new one.', syntax: 'edit FILE_PATH', details: 'Opens the specified FILE_PATH in a simple text editor. If the file does not exist, it will be created upon saving. Cannot edit directories. Use Ctrl+S to save and exit, Ctrl+O to exit without saving.', examples: ['edit my_notes.txt', 'edit /projects/config.ini']},
            'diag': { usage: 'diag', summary: 'Runs internal diagnostic tests.', syntax: 'diag', details: 'Executes a series of predefined tests on core OopisOs functionalities such as filesystem, path resolution, and user management. Reports PASS/FAIL for each test. Primarily for development and debugging purposes.', examples: ['diag']},
            'tree': { usage: 'tree [path]', summary: 'Displays directory structure as a tree.', syntax: 'tree [DIRECTORY_PATH]', details: 'Shows the contents of DIRECTORY_PATH (or current directory if none specified) in a tree-like format. Files and subdirectories are listed alphabetically.', examples: ['tree', 'tree /projects', 'tree ../docs > structure.txt']},
            'find': { usage: 'find [path] -name "<pattern>"', summary: 'Searches for files and directories.', syntax: 'find [PATH] -name PATTERN', details: 'Recursively searches within the specified PATH (or current directory if PATH is omitted) for files and directories whose names match the given PATTERN. The PATTERN can include wildcards: "*" matches any sequence of characters, and "?" matches any single character. The -name option and a pattern are mandatory. Ensure the pattern is quoted if it contains spaces or special characters interpreted by the shell.', examples: ['find -name "*.txt"', 'find /documents -name "report_*.doc"', 'find . -name "image?"']},
            'du': { usage: 'du [path...]', summary: 'Estimates file space usage (approx. bytes).', syntax: 'du [FILE_OR_DIRECTORY...]', details: 'Displays the approximate "disk usage" (based on character count, 1 char ~ 1 byte) for each specified FILE_OR_DIRECTORY. For directories, the size reported is the total size of all files within that directory and its subdirectories. If no arguments are given, it reports the size of the current directory (`.`). Output is formatted in B, KB, MB, etc.', examples: ['du', 'du /documents my_file.txt', 'du project_alpha/src']},
            'head': {
                usage: 'head [-n N] <filename>',
                summary: 'Displays the beginning of a file.',
                syntax: 'head [-n N] FILE',
                details: 'Prints the first N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.',
                examples: ['head myfile.txt', 'head -n 5 log.txt', 'head -n 20 data.csv > preview.txt']
            },
            'tail': {
                usage: 'tail [-n N] <filename>',
                summary: 'Displays the end of a file.',
                syntax: 'tail [-n N] FILE',
                details: 'Prints the last N lines (default 10) of the specified FILE to standard output. ' +
                         'The -n option specifies the number of lines. If N is invalid (e.g., not a positive integer), it defaults to 10.',
                examples: ['tail error.log', 'tail -n 3 access.log', 'tail -n 50 large_file.txt']
            },
            'export': {
                usage: 'export <path/to/filename>',
                summary: 'Exports a file to your local disk.',
                syntax: 'export FILE_PATH',
                details: 'Downloads the specified FILE_PATH from the OopisOs filesystem to your computer\'s default download location. Cannot export directories.',
                examples: ['export my_document.txt', 'export /logs/today.log']
            },
            'backup': {
                usage: 'backup',
                summary: 'Backs up current user session to a local file.',
                syntax: 'backup',
                details: 'Creates a JSON file containing the current user\'s entire filesystem, current path, command history, and terminal display state. This file is then downloaded to your local disk. This is a comprehensive snapshot for external backup.',
                examples: ['backup']
            },
            'import': {
                usage: 'import',
                summary: 'Imports a user session from a local backup file.',
                syntax: 'import',
                details: 'Prompts you to select an OopisOs backup file (JSON format) from your local disk. Upon confirmation, it restores the session for the user specified in the backup, overwriting their current OopisOs state (filesystem, path, history).',
                examples: ['import']
            },
            'wc': { 
                usage: 'wc [-l] [-w] [-c] <filename>',
                summary: 'Counts lines, words, and bytes in a file.',
                syntax: 'wc [OPTION]... [FILE]',
                details: 'Prints newline, word, and byte counts for the specified FILE. A word is a non-zero-length sequence of characters delimited by white space. With no OPTION, prints all three counts.\n' +
                         '  -c, --bytes         print the byte counts\n' +
                         '  -l, --lines         print the newline counts\n' +
                         '  -w, --words         print the word counts',
                examples: ['wc myfile.txt', 'wc -l story.txt', 'wc -w -c report.doc', 'wc -lwc data.csv']
            },
            'diff': { 
                usage: 'diff <file1> <file2>',
                summary: 'Compares two files line by line.',
                syntax: 'diff FILE1 FILE2',
                details: 'Compares FILE1 and FILE2 line by line and outputs the differences. Common lines are prefixed with two spaces. Lines unique to FILE1 are prefixed with "< ". Lines unique to FILE2 are prefixed with "> ".',
                examples: ['diff old_version.txt new_version.txt', 'diff /config/main.conf /config/backup.conf']
            },
            'history': { 
                usage: 'history',
                summary: 'Displays the command history.',
                syntax: 'history',
                details: 'Shows a numbered list of previously executed commands in the current session. The most recent commands appear last.',
                examples: ['history']
            },
            'alias': { // NEW
                usage: 'alias [name[=value] ...]',
                summary: 'Define or display aliases.',
                syntax: 'alias [NAME[=VALUE]...]',
                details: '`alias` with no arguments prints the list of aliases in the form `name=\'value\'`.\n' +
                         '`alias name` prints the alias for `name`.\n' +
                         '`alias name=value` defines an alias. `value` can be a string containing commands. If `value` contains spaces, it should be quoted.\n' +
                         '`alias name=` unsets the alias `name`.',
                examples: ['alias', 'alias ll', "alias ll='ls -alF'", "alias mydocs='cd /home/user/documents'", "alias lsl="]
            },
            'unalias': { // NEW
                usage: 'unalias <name>',
                summary: 'Remove an alias.',
                syntax: 'unalias NAME',
                details: 'Removes the alias specified by NAME from the current user\'s alias list.',
                examples: ['unalias ll']
            }
        };

        // --- Command Handlers ---
        async function handleLs(args) {
            const targetPathArg = args[0]; 
            const validation = validatePath("ls", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }
            
            const childrenNames = Object.keys(validation.node.children).sort();
            if (childrenNames.length === 0) return "Directory is empty.";
            
            let outputLines = [];
            childrenNames.forEach(name => {
                const childNode = validation.node.children[name];
                let line = name;
                if (childNode.type === 'directory') line += '/';
                outputLines.push(line);
            });
            return outputLines.join('\n');
        }

        async function handleCd(args) {
            const targetPathArg = args[0];
            if (targetPathArg === undefined) { 
                appendToOutput("cd: missing operand", true);
                appendToOutput("Usage: cd <directory>", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            const validation = validatePath("cd", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            if (validation.resolvedPath === currentPath) {
                return null; 
            }
            currentPath = validation.resolvedPath;
            updatePrompt();
            return null;
        }

        async function handleMkdir(args) {
            const fullPathArg = args[0];
            if (!fullPathArg) {
                appendToOutput("mkdir: missing operand", true);
                appendToOutput("Usage: mkdir <directory_name>", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            if (fullPathArg === '.' || fullPathArg === '..') {
                 appendToOutput(`mkdir: invalid directory name '${fullPathArg}'`, true); return null;
            }

            const validation = validatePath("mkdir", fullPathArg, { allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false });

            if (validation.error && validation.node && validation.node.type === 'file') {
                appendToOutput(`mkdir: cannot create directory '${fullPathArg}': A file with that name already exists.`, true);
                return null;
            }
            if (validation.error && validation.resolvedPath === '/') { 
                appendToOutput(validation.error, true); 
                return null;
            }
            if (validation.error && !validation.node && !validation.allowMissing) { 
                appendToOutput(validation.error, true);
                return null;
            }

            const targetAbsPath = validation.resolvedPath;

            if (validation.node && validation.node.type === 'directory') {
                appendToOutput(`mkdir: cannot create directory '${fullPathArg}': Directory already exists.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            
            const parentDirResult = createParentDirectoriesIfNeeded(targetAbsPath); 
            if (parentDirResult.error) { 
                appendToOutput(`mkdir: ${parentDirResult.error}`, true); 
                return null; 
            }
            const parentNode = parentDirResult.parentNode; 
            
            if (!parentNode) { 
                appendToOutput(`mkdir: could not obtain parent directory for '${targetAbsPath}'`, true);
                return null;
            }
            const dirToCreateName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);
            if (!dirToCreateName) { 
                 appendToOutput(`mkdir: invalid directory name in '${fullPathArg}'`, true); return null;
            }
            parentNode.children[dirToCreateName] = { type: 'directory', children: {} };
            if (!await saveFileSystemData()) {
                return null;
            }
            return null;
        }

        async function handleTouch(args) {
            const fullPathArg = args[0];
            if (!fullPathArg) {
                appendToOutput("touch: missing file operand", true);
                appendToOutput("Usage: touch <filename>", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
             if (fullPathArg.endsWith('/')) {
                appendToOutput(`touch: invalid argument '${fullPathArg}' (cannot be a directory path)`, true); return null;
            }

            const validation = validatePath("touch", fullPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false });

            if (validation.error) { 
                appendToOutput(validation.error, true);
                return null;
            }

            const targetAbsPath = validation.resolvedPath;

            if (validation.node) { 
                return null;
            }

            const parentDirResult = createParentDirectoriesIfNeeded(targetAbsPath); 
            if (parentDirResult.error) { 
                appendToOutput(`touch: ${parentDirResult.error}`, true); 
                return null; 
            }
            const parentNode = parentDirResult.parentNode; 

            if (!parentNode) return null; 

            const newFileName = targetAbsPath.substring(targetAbsPath.lastIndexOf('/') + 1);
            parentNode.children[newFileName] = { type: 'file', content: "" };
            if (!await saveFileSystemData()) return null;
            return null;
        }

        async function handleCat(args) {
            const targetPathArg = args[0];
             if (!targetPathArg) {
                appendToOutput("cat: missing file operand", true);
                appendToOutput("Usage: cat <filename>", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            const validation = validatePath("cat", targetPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }
            return validation.node.content;
        }

        async function handleEcho(args) {
            let outputString = args.join(' ');
            if (outputString.length >= 2) {
                const firstChar = outputString[0];
                const lastChar = outputString[outputString.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    outputString = outputString.substring(1, outputString.length - 1);
                }
            }
            return outputString;
        }
        async function handleMv(args) {
            if (args.length < 2) { appendToOutput("mv: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];
            
            const sourceValidation = validatePath("mv", sourcePathArg, {disallowRoot: true, defaultToCurrentIfEmpty: false});
            if (sourceValidation.error) {
                appendToOutput(sourceValidation.error, true); return null;
            }
            const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;

            const destValidation = validatePath("mv", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false });
             if (destValidation.error && destValidation.node && destValidation.node.type === 'file') { 
                appendToOutput(`mv: destination '${destPathArg}' exists and is a file. Cannot overwrite.`, true); return null;
            }
            if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) {
                 appendToOutput(destValidation.error, true); return null;
            }

            let absDestPath = destValidation.resolvedPath;
            const sourceParentPath = absSourcePath.substring(0, absSourcePath.lastIndexOf('/')) || '/';
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            const sourceParentNode = getNodeByPath(sourceParentPath);

            if (!sourceParentNode?.children?.[sourceName]) {
                appendToOutput(`mv: internal error: source '${sourceName}' not in parent`, true); return null;
            }

            let finalDestParentNode, finalDestName;
            if (destValidation.node && destValidation.node.type === 'directory') { 
                finalDestParentNode = destValidation.node;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath); 
            } else { 
                const lastSlash = absDestPath.lastIndexOf('/');
                const parentDirResult = createParentDirectoriesIfNeeded(absDestPath); 
                if(parentDirResult.error){ 
                    appendToOutput(`mv: ${parentDirResult.error}`, true); 
                    return null; 
                }
                finalDestParentNode = parentDirResult.parentNode; 
                if (!finalDestParentNode) return null; 
                finalDestName = absDestPath.substring(lastSlash + 1);
            }

            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`mv: invalid destination name '${finalDestName}'`, true); return null; }
            if (absSourcePath === absDestPath) { appendToOutput(`mv: '${sourcePathArg}' and '${destPathArg}' are the same file.`, false, CSS_CONSOLE_LOG_MSG); return null; }
            
            if (finalDestParentNode.children[finalDestName] && !(destValidation.node && destValidation.node.type === 'directory')) {
                 appendToOutput(`mv: destination '${finalDestName}' already exists.`, true); return null;
            }

            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`mv: cannot move directory into itself or one of its subdirectories`, true); return null;
            }

            finalDestParentNode.children[finalDestName] = sourceNode;
            delete sourceParentNode.children[sourceName];

            if (await saveFileSystemData()) {}
            return null;
        }
        async function handleCp(args) {
            if (args.length < 2) { appendToOutput("cp: missing source and/or destination", true); return null; }
            const sourcePathArg = args[0], destPathArg = args[1];

            const sourceValidation = validatePath("cp", sourcePathArg, {disallowRoot: true, defaultToCurrentIfEmpty: false});
             if (sourceValidation.error) {
                appendToOutput(sourceValidation.error, true); return null;
            }
            const { node: sourceNode, resolvedPath: absSourcePath } = sourceValidation;

            const destValidation = validatePath("cp", destPathArg, { allowMissing: true, defaultToCurrentIfEmpty: false });
            if (destValidation.error && destValidation.node && destValidation.node.type === 'file') {
                appendToOutput(`cp: destination '${destPathArg}' exists and is a file. Cannot overwrite.`, true); return null;
            }
            if (destValidation.error && !(destValidation.node && destValidation.node.type === 'file')) {
                 appendToOutput(destValidation.error, true); return null;
            }
            
            let absDestPath = destValidation.resolvedPath;
            const sourceName = absSourcePath.substring(absSourcePath.lastIndexOf('/') + 1);
            let finalDestParentNode, finalDestName;

            if (destValidation.node && destValidation.node.type === 'directory') {
                finalDestParentNode = destValidation.node;
                finalDestName = sourceName;
                absDestPath = getAbsolutePath(finalDestName, absDestPath);
            } else {
                const lastSlash = absDestPath.lastIndexOf('/');
                const parentDirResult = createParentDirectoriesIfNeeded(absDestPath); 
                if(parentDirResult.error){ 
                    appendToOutput(`cp: ${parentDirResult.error}`, true); 
                    return null; 
                }
                finalDestParentNode = parentDirResult.parentNode; 
                if (!finalDestParentNode) {
                     appendToOutput(`cp: could not obtain parent directory for '${absDestPath}'`, true);
                    return null;
                }
                finalDestName = absDestPath.substring(lastSlash + 1);
            }

            if (!finalDestName || finalDestName === "." || finalDestName === "..") { appendToOutput(`cp: invalid destination name '${finalDestName}'`, true); return null; }
            if (finalDestParentNode.children[finalDestName]) { appendToOutput(`cp: destination '${finalDestName}' already exists.`, true); return null; }
            if (sourceNode.type === 'directory' && (absDestPath.startsWith(absSourcePath + '/') || absDestPath === absSourcePath)) {
                appendToOutput(`cp: cannot copy a directory into itself or one of its subdirectories.`, true); return null;
            }

            const copiedNode = deepCopyNode(sourceNode);
            if (!copiedNode) { appendToOutput(`cp: internal error copying '${sourcePathArg}'.`, true); return null; }

            finalDestParentNode.children[finalDestName] = copiedNode;
            if (await saveFileSystemData()) {}
            return null;
        }
        async function handleRm(args) {
            const targetPathArg = args[0];
            if (!targetPathArg) {
                appendToOutput("rm: missing operand", true);
                appendToOutput("Usage: rm <file_or_directory>", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            const validation = validatePath("rm", targetPathArg, { disallowRoot: true, defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }
            
            const itemType = validation.node.type === 'directory' ? 'directory' : 'file';
            const dataForConfirm = { path: validation.resolvedPath, arg: targetPathArg };

            requestConfirmation(
                [`Are you sure you want to remove ${itemType} '${targetPathArg}'? This action cannot be undone.`],
                dataForConfirm,
                async (data) => { // onConfirm
                    const parentPath = data.path.substring(0, data.path.lastIndexOf('/')) || '/';
                    const itemName = data.path.substring(data.path.lastIndexOf('/') + 1);
                    const parentNode = getNodeByPath(parentPath);
                    if (parentNode && parentNode.children && parentNode.children[itemName]) {
                        delete parentNode.children[itemName];
                        if(!await saveFileSystemData()) { /* Error saving */ }
                        else appendToOutput(`'${data.path}' removed.`, false, CSS_SUCCESS_MSG);
                    } else { 
                        appendToOutput(`Error removing '${data.path}': Item not found or parent changed.`, true); 
                    }
                },
                (data) => { // onCancel
                    appendToOutput(`Removal of '${data.arg || 'item'}' cancelled.`, false, CSS_CONSOLE_LOG_MSG);
                }
            );
            return null;
        }

        async function handlePwd(args) { return currentPath;}
        async function handleDate(args) { return new Date().toString();}
        async function handleWhoami(args) { return currentUser;}

        async function handleGrep(args) {
            if (args.length < 2) {
                appendToOutput("grep: usage: grep PATTERN FILE", true);
                return null;
            }
            const filePathArg = args[args.length - 1];
            let pattern = args.slice(0, args.length - 1).join(' ');
            if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                pattern = pattern.substring(1, pattern.length - 1);
            }
            if (!pattern) { appendToOutput("grep: pattern cannot be empty", true); return null; }

            const validation = validatePath("grep", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            const fileContent = validation.node.content || "";
            const lines = fileContent.split('\n');
            const matchingLines = lines.filter(line => line.includes(pattern));
            return matchingLines.length > 0 ? matchingLines.join('\n') : "";
        }

        async function handleRun(args) {
            const scriptPathArg = args[0];
            if (!scriptPathArg) {
                appendToOutput("run: missing script file operand", true);
                return null;
            }
            const validation = validatePath("run", scriptPathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }
            
            const scriptContent = validation.node.content || "";
            const scriptLines = scriptContent.split('\n');
            appendToOutput(`Executing script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);

            (async () => {
                for (let i = 0; i < scriptLines.length; i++) {
                    const line = scriptLines[i];
                    const trimmedLine = line.trim();
                    if (trimmedLine === '' || trimmedLine.startsWith('#')) continue;
                    const cmdResult = await processCommand(trimmedLine, false); 
                    if (!cmdResult.commandSuccessful) { 
                        appendToOutput(`Script '${scriptPathArg}' aborted due to error on line ${i + 1}: ${trimmedLine}`, true);
                        return;
                    }
                }
                appendToOutput(`Finished script: ${scriptPathArg}`, false, CSS_CONSOLE_LOG_MSG);
            })();
            return null;
        }
        async function handleSysmon(args) {
            const output = [
                "** OopisOs System Monitor v6.9 - Sub-Etha Edition **",
                "----------------------------------------------------",
                `Registered User:    ${currentUser} (Probably you, unless you stole this login!)`,
                `OopisOs Version:    ${OS_VERSION} (Now with less existential dread!)`,
                "",
                "==[ MAIN PROCESSOR UNIT (MPU) ]==",
                `  Type:             QualmCore 9001 (Barely Legal Edition)`,
                `  Architecture:     Mostly Wishful Thinking with a Dash of RISC-y Business`,
                `  Conceptual Cores: 1 (It's trying its best, okay?)`,
                `  Clock Speed:      ~1 OopoHertz (Can reach 5 on a good day, with a tailwind)`,
                "",
                "==[ RANDOM ACCESS MUD (RAM) ]==", 
                `  Type:             DJHAR (Don't Jiggle; Highly Agitated Ram)`,
                `  Capacity:         640 KiloSegs (Should be enough for anyone, right?)`, 
                `  Current Load:     Probably too high. Did you try turning it off and on again?`,
                "",
                "==[ STORAGE (Probably Borrowed) ]==",
                `  Primary Drive:    The ol' IndexedDB Drive (Capacity: Browser's Whim)`,
                `  Space Used:       Enough to make you question your life choices.`,
                `  Space Free:       Less than you'd hope. Consider deleting 'that' folder.`,
                "",
                "==[ VISUAL DISPLAY UNIT (VDU) ]==",
                `  Model:            GreenScreen Deluxe (Now with 50 shades of green!)`,
                `  Resolution:       Optimistically Text-Mode`,
                `  Burn-in Status:   Impressive. You've been at this a while, huh?`,
                "----------------------------------------------------",
                "System Status:      'Nominally Operational'. (Whatever that means.)"
            ];
            let styledOutput = "";
            output.forEach(line => {
                const parts = line.split(':');
                if (parts.length > 1 && line.trim().startsWith(parts[0].trim())) { 
                     styledOutput += `<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_SYSMON_LABEL}">${parts[0].padEnd(20, ' ')}:</span><span>${parts.slice(1).join(':').trim()}</span></div>`;
                } else {
                    styledOutput += `<div class="${CSS_OUTPUT_LINE}">${line}</div>`;
                }
            });
            appendHtmlToOutput(styledOutput);
            return null;
        }
        async function handleSort(args) {
            const filePathArg = args[0];
            if (!filePathArg) {
                appendToOutput("sort: missing file operand", true);
                return null;
            }
            const validation = validatePath("sort", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            const fileContent = validation.node.content || "";
            if (fileContent.trim() === "") return "";
            const lines = fileContent.split('\n');
            lines.sort();
            return lines.join('\n');
        }

        async function handleClear() { if (!isEditingFile) outputDiv.innerHTML = ''; return null; }
        
        async function handleManualSaveState() {
            const pendingData = { 
                currentPath, 
                outputHTML: outputDiv.innerHTML, 
                currentInput: hiddenInput.value, 
                fsDataSnapshot: deepCopyNode(fsData) 
            };
            if (saveJSONToStorage(getManualUserTerminalStateKey(currentUser), pendingData, `Manual save for ${currentUser}`)) {
                appendToOutput(`Session manually saved for ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }

        async function handleManualLoadState() {
            const pendingData = loadJSONFromStorage(getManualUserTerminalStateKey(currentUser), `Manual save for ${currentUser}`);
            if (pendingData) {
                requestConfirmation(
                    ["Load manually saved state? This overwrites current session & filesystem."],
                    { pendingData: pendingData }, 
                    async (data) => { 
                        fsData = deepCopyNode(data.pendingData.fsDataSnapshot) || { '/': { type: 'directory', children: {} } };
                        currentPath = data.pendingData.currentPath || '/';
                        outputDiv.innerHTML = data.pendingData.outputHTML || '';
                        hiddenInput.value = data.pendingData.currentInput || '';
                        await saveFileSystemData();
                        appendToOutput("Session loaded from manual save.", false, CSS_SUCCESS_MSG);
                        updateVisualInput(); 
                        updatePrompt(); 
                        outputDiv.scrollTop = outputDiv.scrollHeight;
                    },
                    () => { 
                        appendToOutput("Load state cancelled.", false, CSS_CONSOLE_LOG_MSG);
                    }
                );
            } else {
                appendToOutput(`No manually saved state found for ${currentUser}.`, false, CSS_CONSOLE_LOG_MSG);
            }
            return null;
        }

        async function performFullReset() { 
            outputDiv.innerHTML = ''; hiddenInput.value = ''; updateVisualInput();
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(USER_TERMINAL_STATE_KEY_PREFIX) || key.startsWith(MANUAL_USER_TERMINAL_STATE_KEY_PREFIX) || key === USER_CREDENTIALS_KEY) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
            appendToOutput("All session states and credentials cleared from local storage.", false, CSS_CONSOLE_LOG_MSG);

            if (db) {
                try {
                    await new Promise((resolve, reject) => {
                        const transaction = db.transaction([FS_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(FS_STORE_NAME);
                        const request = store.clear();
                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                    appendToOutput("All user filesystems cleared from DB.", false, CSS_CONSOLE_LOG_MSG);
                } catch (error) {
                    console.error("Error clearing FileSystemsStore during reset:", error);
                    appendToOutput("Error clearing user filesystems from DB.", true);
                }
            }

            commandHistory = []; historyIndex = commandHistory.length; currentUser = DEFAULT_USER;
            await initializeFileSystem(DEFAULT_USER); // This will also load aliases for Guest
            loadAutomaticSessionState(DEFAULT_USER); 
            appendToOutput("Terminal fully reset. All user data and states cleared.", false, CSS_SUCCESS_MSG);
        }

        async function handleReset() {
            requestConfirmation(
                ["Reset ALL terminal data? This includes all users, files, and saved states, and cannot be undone."],
                null, 
                async () => { 
                    await performFullReset(); 
                },
                () => { 
                    appendToOutput("Reset cancelled.", false, CSS_CONSOLE_LOG_MSG);
                }
            );
            return null;
        }
        async function handleRegister(args) {
            if (args.length < 2) { appendToOutput("Usage: register <username> <password>", true); return null; }
            const [username, password] = args;
            const credentials = getUserCredentials();
            if (credentials[username]) { appendToOutput(`Error: User '${username}' already exists.`, true); return null; }
            if (username.toLowerCase() === DEFAULT_USER.toLowerCase()) { appendToOutput(`Error: Cannot register '${DEFAULT_USER}'. This username is reserved.`, true); return null; }
            if (username.includes(" ") || password.includes(" ")) {
                 appendToOutput("Error: Username and password cannot contain spaces.", true); return null;
            }

            try {
                const hashedPassword = await hashPassword(password);
                credentials[username] = hashedPassword;
                if (saveUserCredentials(credentials)) {
                    await initializeFileSystem(username); // This will also load aliases for the new user
                    if (!isRunningDiag) appendToOutput(`User '${username}' registered. You can now login.`, false, CSS_SUCCESS_MSG);
                }
            } catch (error) {
                 if (!isRunningDiag) appendToOutput(`Registration failed for '${username}' due to a system error.`, true);
                 else throw error;
            }
            return null;
        }
        async function handleLogin(args) {
            if (args.length < 2) { appendToOutput("Usage: login <username> <password>", true); return null; }
            const [username, password] = args;

            if (username === currentUser && !isRunningDiag) {
                appendToOutput(`login: already logged in as '${username}'.`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const credentials = getUserCredentials();
            const storedPasswordHash = credentials[username];

            if (!storedPasswordHash) {
                if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                else lastCommandFailed = true;
                return null;
            }

            try {
                const enteredPasswordHash = await hashPassword(password);
                if (storedPasswordHash === enteredPasswordHash) {
                    if (currentUser !== DEFAULT_USER && currentUser !== username && !isRunningDiag) saveAutomaticSessionState();
                    currentUser = username;
                    commandHistory = []; historyIndex = commandHistory.length; // Reset history for new user
                    await loadFileSystemData(currentUser); // Also loads aliases
                    if(!isRunningDiag) loadAutomaticSessionState(currentUser);
                    if(!isRunningDiag) appendToOutput(`Logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
                } else {
                    if (!isRunningDiag) appendToOutput("Login failed: Invalid username or password.", true);
                    else lastCommandFailed = true;
                }
            } catch (error) {
                if (!isRunningDiag) appendToOutput("Login failed due to a system error during password verification.", true);
                else { lastCommandFailed = true; throw error; }
            }
            return null;
        }
        async function handleLogout() {
            if (currentUser === DEFAULT_USER) {
                 if (!isRunningDiag) appendToOutput("Already logged in as Guest. No action taken.", false, CSS_CONSOLE_LOG_MSG);
                 return null;
            }
            if (!isRunningDiag) saveAutomaticSessionState();
            const prevUser = currentUser;
            currentUser = DEFAULT_USER;
            commandHistory = []; historyIndex = commandHistory.length; 
            await loadFileSystemData(DEFAULT_USER); // Also loads aliases for Guest
            if (!isRunningDiag) {
                loadAutomaticSessionState(DEFAULT_USER);
                appendToOutput(`User ${prevUser} logged out. Now logged in as ${currentUser}.`, false, CSS_SUCCESS_MSG);
            }
            return null;
        }
        async function handleHelp(args) {
            let outputLines = [];
            if (!args.length) {
                outputLines.push("Available commands (type 'help <command>' or 'man <command>'):");
                const commandNames = Object.keys(commandRegistry).sort();
                commandNames.forEach(cmdName => {
                    const summary = commandHelpData[cmdName]?.summary || 'No summary available.';
                    outputLines.push(`- ${cmdName.padEnd(10, ' ')} ${summary}`);
                });
            } else {
                const commandName = args[0].toLowerCase();
                const helpInfo = commandHelpData[commandName];
                if (helpInfo) {
                    outputLines.push(`${commandName}: ${helpInfo.summary || 'No summary available.'}`);
                    outputLines.push(`  Usage: ${helpInfo.usage || 'N/A'}`);
                    outputLines.push(`  For more details, type: man ${commandName}`);
                } else { appendToOutput(`No help available for '${commandName}'. Try 'man ${commandName}'.`, true); return null; }
            }
            return outputLines.join('\n');
        }
        async function handleMan(args) {
            function escapeHtml(unsafe) {
                if (typeof unsafe !== 'string') return '';
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            if (args.length === 0) {
                appendToOutput("What manual page do you want? (e.g., man ls)", false, CSS_CONSOLE_LOG_MSG);
                return null;
            }
            const commandName = args[0].toLowerCase();
            const manData = commandHelpData[commandName];
            
            if (manData) {
                let manOutputHtmlLines = [];

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">NAME</span></div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    ${escapeHtml(commandName)} - ${escapeHtml(manData.summary || 'No summary available.')}</div>`);

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">SYNOPSIS</span></div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    <span class="${CSS_HELP_CMD_NAME}">${escapeHtml(manData.syntax || manData.usage || 'No syntax information available.')}</span></div>`);

                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">DESCRIPTION</span></div>`);
                const detailLines = (manData.details || 'No detailed description available.').split('\n');
                detailLines.forEach(line => {
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">    <span class="${CSS_MAN_SECTION_CONTENT}">${escapeHtml(line)}</span></div>`);
                });

                if (manData.examples && manData.examples.length > 0) {
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);
                    manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}"><span class="${CSS_MAN_SECTION_TITLE}">EXAMPLES</span></div>`);
                    manData.examples.forEach(example => {
                        manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">        <span class="${CSS_MAN_EXAMPLE}">${escapeHtml(example)}</span></div>`);
                    });
                }
                manOutputHtmlLines.push(`<div class="${CSS_OUTPUT_LINE}">&nbsp;</div>`);

                appendHtmlToOutput(manOutputHtmlLines.join(''));
                return null;
            } else {
                appendToOutput(`No manual entry for ${commandName}`, true);
                return null;
            }
        }

        async function handleEdit(args) {
            if (isEditingFile) {
                appendToOutput("Editor already active. Ctrl+S to save, Ctrl+O to quit.", false, 'editor-message');
                return null;
            }
            const targetPathArg = args[0];
             if (!targetPathArg) {
                appendToOutput("edit: missing file operand", true);
                return null;
            }
            if (targetPathArg.endsWith('/')) {
                 appendToOutput(`edit: '${targetPathArg}' is a directory path, not a file. Provide a filename.`, true);
                 return null;
            }
            const validation = validatePath("edit", targetPathArg, { expectedType: 'file', allowMissing: true, disallowRoot: true, defaultToCurrentIfEmpty: false });

            if (validation.error) { 
                appendToOutput(validation.error, true);
                return null;
            }
            
            const content = validation.node ? validation.node.content : ""; 
            enterEditMode(validation.resolvedPath, content);
            return null;
        }

        function enterEditMode(filePath, content) {
            isEditingFile = true;
            editingFilePath = filePath;

            outputDiv.style.display = 'none';
            standardInputLineDiv.style.display = 'none';
            hiddenInput.blur();

            editorWrapperDiv = document.createElement('div');
            editorWrapperDiv.id = 'editor-wrapper';

            editorTextareaElement = document.createElement('textarea');
            editorTextareaElement.id = 'editor-textarea';
            editorTextareaElement.value = content;

            editorInstructionsDiv = document.createElement('div');
            editorInstructionsDiv.id = 'editor-instructions';
            editorInstructionsDiv.textContent = `Editing: ${filePath} | Ctrl+S: Save & Exit | Ctrl+O: Exit without Saving`;

            editorWrapperDiv.appendChild(editorTextareaElement);
            editorWrapperDiv.appendChild(editorInstructionsDiv);

            terminalDiv.insertBefore(editorWrapperDiv, standardInputLineDiv);

            editorTextareaElement.focus();
            editorTextareaElement.setSelectionRange(editorTextareaElement.value.length, editorTextareaElement.value.length);
            editorTextareaElement.addEventListener('keydown', handleEditorKeyDown);
        }

        async function exitEditMode(saveChanges = false) {
            let success = true;
            if (saveChanges && editorTextareaElement && editingFilePath) {
                const newContent = editorTextareaElement.value;
                const parentDirResult = createParentDirectoriesIfNeeded(editingFilePath); 
                if (parentDirResult.error) { 
                    appendToOutput(`edit: ${parentDirResult.error}`, true); 
                    success = false; 
                } else {
                    const parentNode = parentDirResult.parentNode; 
                    if (parentNode) {
                        const fileName = editingFilePath.substring(editingFilePath.lastIndexOf('/') + 1);
                        parentNode.children[fileName] = { type: 'file', content: newContent };
                        if (await saveFileSystemData()) {
                            appendToOutput(`File '${editingFilePath}' saved.`, false, CSS_SUCCESS_MSG);
                        } else {
                            appendToOutput(`Error saving file '${editingFilePath}'. Changes might be lost.`, true, CSS_ERROR_MSG);
                            success = false;
                        }
                    } else { 
                        appendToOutput(`Failed to save '${editingFilePath}'. Could not obtain parent directory.`, true, CSS_ERROR_MSG);
                        success = false;
                    }
                }
            } else if (editingFilePath) {
                appendToOutput(`Exited editor for '${editingFilePath}' without saving.`, false, CSS_CONSOLE_LOG_MSG);
            }

            if (editorWrapperDiv && editorWrapperDiv.parentNode === terminalDiv) {
                terminalDiv.removeChild(editorWrapperDiv);
            }
            if (editorTextareaElement) {
                editorTextareaElement.removeEventListener('keydown', handleEditorKeyDown);
            }
            editorWrapperDiv = null; editorTextareaElement = null; editorInstructionsDiv = null;

            isEditingFile = false; editingFilePath = null;

            outputDiv.style.display = '';
            standardInputLineDiv.style.display = '';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            hiddenInput.focus();
            updatePrompt();
            return success;
        }

        async function handleEditorKeyDown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 1;
                return;
            }

            if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                await exitEditMode(true);
            } else if (event.ctrlKey && (event.key === 'o' || event.key === 'O')) {
                event.preventDefault();
                await exitEditMode(false);
            }
        }


        async function handleDiag(args) {
            isRunningDiag = true;
            let passCount = 0;
            let failCount = 0;

            const originalCurrentUser = currentUser;
            let originalFsData = deepCopyNode(fsData);
            const originalCurrentPath = currentPath;
            const originalCredentials = deepCopyNode(getUserCredentials());
            const originalOutputHTML = outputDiv.innerHTML;
            const originalCommandHistory = [...commandHistory];
            const originalHistoryIndex = historyIndex;


            const diagPrint = (message) => appendToOutput(message, false, 'diag-output');
            const report = (testName, success, details = "") => {
                if (success) { passCount++; diagPrint(`  PASS: ${testName}`); }
                else { failCount++; diagPrint(`  FAIL: ${testName} ${details ? `- ${details}` : ''}`); }
                return success;
            };
            
            const createTestFile = async (filePath, content) => {
                const escapedContent = content.replace(/"/g, '\\"'); 
                const echoResult = await processCommand(`echo "${escapedContent}" > ${filePath}`, false);
                if (!echoResult.commandSuccessful) {
                    diagPrint(`  WARN: Failed to create test file ${filePath} for diag. Error during echo/redirection.`);
                }
            };


            outputDiv.innerHTML = '';
            diagPrint("Starting OopisOs Diagnostics...");
            diagPrint("-------------------------------");

            const fsTestUser = "__diag_cmd_user__"; 
            const fsTestBaseDir = "/tmp/__diag_cmd_tests__";
            
            let loginCmdResult = await processCommand(`login ${fsTestUser} testpassword`, false);
            if (!loginCmdResult.commandSuccessful) { 
                await processCommand(`register ${fsTestUser} testpassword`, false);
                loginCmdResult = await processCommand(`login ${fsTestUser} testpassword`, false);
            }
            if (!loginCmdResult.commandSuccessful) {
                diagPrint("  CRITICAL: Could not switch to/create diag_cmd_user. Aborting command tests.");
                currentUser = originalCurrentUser; fsData = originalFsData; await saveFileSystemData(currentUser); currentPath = originalCurrentPath;
                outputDiv.innerHTML = originalOutputHTML; commandHistory = originalCommandHistory; historyIndex = originalHistoryIndex;
                updatePrompt(); updateVisualInput(); isRunningDiag = false; window.diagInitialized = false;
                return "";
            }
            
            let rmSetupResult = await processCommand(`rm ${fsTestBaseDir}`, false);
            if (awaitingConfirmation) { await processCommand("YES", false); }
            lastCommandFailed = false; 

            await processCommand(`mkdir ${fsTestBaseDir}`, false);
            await processCommand(`cd ${fsTestBaseDir}`, false);
            
            diagPrint("SECTION: File Content Commands (wc, head, tail, diff)");
            
            const wcFile = "wc_test.txt";
            const wcContent = "one two three\nfour five\n\nsix seven eight nine ten"; 
            await createTestFile(wcFile, wcContent);
            
            let expectedLinesForWcDefault = 4; 
            let expectedLinesForWcL = 3; 
            let expectedWords = 10;
            let expectedBytes = wcContent.length;

            let wcCmdResultObj = await processCommand(`wc ${wcFile}`, false);
            report("wc default", wcCmdResultObj.output && wcCmdResultObj.output.trim() === `${String(expectedLinesForWcDefault).padStart(7)} ${String(expectedWords).padStart(7)} ${String(expectedBytes).padStart(7)} ${wcFile}`.trim() && !wcCmdResultObj.lastCommandFailed, `Expected: "${String(expectedLinesForWcDefault).padStart(7)} ${String(expectedWords).padStart(7)} ${String(expectedBytes).padStart(7)} ${wcFile}".trim() Got: "${wcCmdResultObj.output ? wcCmdResultObj.output.trim() : 'null'}"`);

            wcCmdResultObj = await processCommand(`wc -l ${wcFile}`, false);
            report("wc -l", wcCmdResultObj.output && wcCmdResultObj.output.trim() === `${String(expectedLinesForWcL).padStart(7)} ${wcFile}`.trim() && !wcCmdResultObj.lastCommandFailed, `Expected: "${String(expectedLinesForWcL).padStart(7)} ${wcFile}".trim() Got: "${wcCmdResultObj.output ? wcCmdResultObj.output.trim() : 'null'}"`);
            
            wcCmdResultObj = await processCommand(`wc -w ${wcFile}`, false);
            report("wc -w", wcCmdResultObj.output && wcCmdResultObj.output.trim() === `${String(expectedWords).padStart(7)} ${wcFile}`.trim() && !wcCmdResultObj.lastCommandFailed, `Expected: "${String(expectedWords).padStart(7)} ${wcFile}".trim() Got: "${wcCmdResultObj.output ? wcCmdResultObj.output.trim() : 'null'}"`);

            wcCmdResultObj = await processCommand(`wc -c ${wcFile}`, false);
            report("wc -c", wcCmdResultObj.output && wcCmdResultObj.output.trim() === `${String(expectedBytes).padStart(7)} ${wcFile}`.trim() && !wcCmdResultObj.lastCommandFailed, `Expected: "${String(expectedBytes).padStart(7)} ${wcFile}".trim() Got: "${wcCmdResultObj.output ? wcCmdResultObj.output.trim() : 'null'}"`);

            const wcEmptyFile = "wc_empty.txt";
            await createTestFile(wcEmptyFile, "");
            wcCmdResultObj = await processCommand(`wc ${wcEmptyFile}`, false);
            report("wc empty file", wcCmdResultObj.output && wcCmdResultObj.output.trim() === `${String(0).padStart(7)} ${String(0).padStart(7)} ${String(0).padStart(7)} ${wcEmptyFile}`.trim() && !wcCmdResultObj.lastCommandFailed, `Expected: "${String(0).padStart(7)} ${String(0).padStart(7)} ${String(0).padStart(7)} ${wcEmptyFile}".trim() Got: "${wcCmdResultObj.output ? wcCmdResultObj.output.trim() : 'null'}"`);

            const htFile = "ht_test.txt";
            const htContent = "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12";
            await createTestFile(htFile, htContent);

            let headCmdResultObj = await processCommand(`head ${htFile}`, false);
            report("head default", headCmdResultObj.output === "1\n2\n3\n4\n5\n6\n7\n8\n9\n10" && !headCmdResultObj.lastCommandFailed);
            
            headCmdResultObj = await processCommand(`head -n 3 ${htFile}`, false);
            report("head -n 3", headCmdResultObj.output === "1\n2\n3" && !headCmdResultObj.lastCommandFailed);

            headCmdResultObj = await processCommand(`head -n 15 ${htFile}`, false); 
            report("head -n 15 (more than lines)", headCmdResultObj.output === htContent && !headCmdResultObj.lastCommandFailed);
            
            let tailCmdResultObj = await processCommand(`tail ${htFile}`, false);
            report("tail default", tailCmdResultObj.output === "3\n4\n5\n6\n7\n8\n9\n10\n11\n12" && !tailCmdResultObj.lastCommandFailed);

            tailCmdResultObj = await processCommand(`tail -n 3 ${htFile}`, false);
            report("tail -n 3", tailCmdResultObj.output === "10\n11\n12" && !tailCmdResultObj.lastCommandFailed);

            const diffFileA1 = "diffA1.txt"; const diffFileA2 = "diffA2.txt";
            const diffContentA = "common line 1\ncommon line 2\ncommon line 3";
            await createTestFile(diffFileA1, diffContentA);
            await createTestFile(diffFileA2, diffContentA);
            let diffCmdResultObj = await processCommand(`diff ${diffFileA1} ${diffFileA2}`, false);
            report("diff identical files", diffCmdResultObj.output === "" && !diffCmdResultObj.lastCommandFailed, `Got: "${diffCmdResultObj.output}"`);

            const diffFileB1 = "diffB1.txt"; const diffFileB2 = "diffB2.txt";
            await createTestFile(diffFileB1, "line one\nline two");
            await createTestFile(diffFileB2, "line one\nINSERTED LINE\nline two");
            diffCmdResultObj = await processCommand(`diff ${diffFileB1} ${diffFileB2}`, false);
            report("diff additions", diffCmdResultObj.output === "> INSERTED LINE" && !diffCmdResultObj.lastCommandFailed, `Got: "${diffCmdResultObj.output}"`);

            const diffFileC1 = "diffC1.txt"; const diffFileC2 = "diffC2.txt";
            await createTestFile(diffFileC1, "alpha\nbeta\ngamma");
            await createTestFile(diffFileC2, "alpha\ngamma");
            diffCmdResultObj = await processCommand(`diff ${diffFileC1} ${diffFileC2}`, false);
            report("diff deletions", diffCmdResultObj.output === "< beta" && !diffCmdResultObj.lastCommandFailed, `Got: "${diffCmdResultObj.output}"`);

            const diffFileD1 = "diffD1.txt"; const diffFileD2 = "diffD2.txt";
            await createTestFile(diffFileD1, "first line\nsecond line CHANGED\nthird line");
            await createTestFile(diffFileD2, "first line\nsecond line MODIFIED\nthird line");
            diffCmdResultObj = await processCommand(`diff ${diffFileD1} ${diffFileD2}`, false);
            report("diff changes", diffCmdResultObj.output === "< second line CHANGED\n> second line MODIFIED" && !diffCmdResultObj.lastCommandFailed, `Got: "${diffCmdResultObj.output}"`);
            
            await processCommand(`cd /tmp`, false); 
            let cleanupRmResult = await processCommand(`rm __diag_cmd_tests__`, false); 
            if (awaitingConfirmation) { await processCommand("YES", false); }


            diagPrint("SECTION: Path Resolution (getAbsolutePath)");
             const pathTestCases = [
                { target: '.', base: '/', expected: '/' , desc: "Current dir at root"}, { target: '..', base: '/', expected: '/', desc: "Parent dir at root" }, { target: 'foo', base: '/', expected: '/foo', desc: "Simple relative from root" }, { target: '/foo/bar', base: '/baz', expected: '/foo/bar', desc: "Absolute target, ignore base" }, { target: 'bar', base: '/foo', expected: '/foo/bar', desc: "Relative from non-root" }, { target: '../bar', base: '/foo/baz', expected: '/foo/bar', desc: "Relative parent navigation" }, { target: '../../bar', base: '/foo/baz/qux', expected: '/foo/bar', desc: "Multiple parent nav" }, { target: '../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav to higher level" }, { target: '../../../../bar', base: '/foo/baz/qux', expected: '/bar', desc: "Parent nav beyond root" },
                { target: 'qux/./corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With current dir token"}, { target: 'qux//corge', base: '/foo/bar', expected: '/foo/bar/qux/corge', desc: "With double slashes"}, { target: '.', base: '/foo/bar', expected: '/foo/bar', desc: "Current dir in non-root"}, { target: '', base: '/foo/bar', expected: '/foo/bar', desc: "Empty target (like current)"}, { target: 'a/b/../../c', base: '/x/y', expected: '/x/y/c', desc: "Complex relative with backtracking"}, { target: '/a/b/../c', base: '/x', expected: '/a/c', desc: "Absolute with backtracking"}, { target: 'a/../..', base: '/x', expected: '/', desc: "Relative to root"}, { target: 'a/b', base: '/', expected: '/a/b', desc: "Simple relative from root 2"}, { target: '//a//b', base: '/', expected: '/a/b', desc: "Multiple slashes at start and middle"},
            ];
            pathTestCases.forEach(tc => {
                const actual = getAbsolutePath(tc.target, tc.base);
                report(`Path: ${tc.desc} ('${tc.target}', '${tc.base}')`, actual === tc.expected, `Expected '${tc.expected}', got '${actual}'`);
            });


            diagPrint("SECTION: User Management");
            const testUsername = "__diag_user__";
            const testPassword = "diagPassword123!";
            const wrongPassword = "wrongPassword!";

            let tempCredentialsPre = getUserCredentials();
            if (tempCredentialsPre[testUsername]) { delete tempCredentialsPre[testUsername]; saveUserCredentials(tempCredentialsPre); }
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            diagPrint(`  INFO: Pre-cleaned test user '${testUsername}' related data.`);


            diagPrint("  Test UM.1: register new user");
            let regResult = await processCommand(`register ${testUsername} ${testPassword}`, false);
            let tempCredentials = getUserCredentials();
            const userRegistered = tempCredentials[testUsername] && tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername].length === 64;
            let testUserFsExistsInDb = false;
            if(db) {
                const storedFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => { console.error("Diag DB read error:", e.target.error); res(null);};
                }).catch(() => null);
                testUserFsExistsInDb = !!(storedFs && storedFs.data && storedFs.data['/']);
            }
            report("Register test user", userRegistered && testUserFsExistsInDb && !regResult.lastCommandFailed,
                   `User in creds: ${!!tempCredentials[testUsername]}, Pwd hashed: ${tempCredentials[testUsername] !== testPassword && tempCredentials[testUsername]?.length === 64}, FS in DB: ${testUserFsExistsInDb}`);


            diagPrint("  Test UM.2: login with correct password");
            const currentUserBeforeLogin = currentUser; 
            let loginCmdResultUM = await processCommand(`login ${testUsername} ${testPassword}`, false);
            report("Login test user (correct pwd)", currentUser === testUsername && !loginCmdResultUM.lastCommandFailed);


            if (currentUser === testUsername) { 
                diagPrint("  Test UM.3: whoami as test user");
                const whoOutputCmdResult = await processCommand("whoami", false); 
                report("whoami check", whoOutputCmdResult.output === testUsername && !whoOutputCmdResult.lastCommandFailed, `Expected '${testUsername}', got '${whoOutputCmdResult.output}'`);
            } else {
                report("whoami check", false, "Skipped due to previous login failure or currentUser mismatch.");
            }

            diagPrint("  Test UM.4: login with incorrect password");
            const currentUserBeforeWrongLogin = currentUser; 
            loginCmdResultUM = await processCommand(`login ${testUsername} ${wrongPassword}`, false);
            report("Login test user (incorrect pwd)", currentUser === currentUserBeforeWrongLogin && loginCmdResultUM.lastCommandFailed, `currentUser is ${currentUser}, expected ${currentUserBeforeWrongLogin}. lastCommandFailed: ${loginCmdResultUM.lastCommandFailed}`);


            diagPrint("  Test UM.5: logout from test user (if logged in)");
            let logoutCmdResult = {lastCommandFailed: false}; 
            if (currentUser === testUsername) { 
                logoutCmdResult = await processCommand("logout", false);
                report("Logout to Guest", currentUser === DEFAULT_USER && !logoutCmdResult.lastCommandFailed);
            } else {
                report("Logout to Guest", currentUser === DEFAULT_USER || currentUser === originalCurrentUser, "Skipped logout as not logged in as test user, or already Guest/OriginalUser.");
            }

            diagPrint("  Cleanup: Removing test user credentials and data");
            tempCredentials = getUserCredentials();
            if (tempCredentials[testUsername]) delete tempCredentials[testUsername];
            saveUserCredentials(tempCredentials);
            await deleteFileSystemData(testUsername).catch(e => {});
            localStorage.removeItem(getAutomaticSessionStateKey(testUsername));
            localStorage.removeItem(getManualUserTerminalStateKey(testUsername));
            let finalCredCheck = !getUserCredentials()[testUsername];
            let finalFsCheckInDb = true;
             if(db) {
                const finalStoredFs = await new Promise((res, rej) => {
                    const trans = db.transaction(FS_STORE_NAME, 'readonly').objectStore(FS_STORE_NAME).get(getFileSystemKey(testUsername));
                    trans.onsuccess = e => res(e.target.result);
                    trans.onerror = e => res(null); 
                }).catch(()=>null);
                finalFsCheckInDb = !finalStoredFs; 
            }
            report("User data cleanup", finalCredCheck && finalFsCheckInDb);

            // Restore original user state that was active before diag tests
            currentUser = originalCurrentUser;
            fsData = deepCopyNode(originalFsData) || { '/': { type: 'directory', children: {} } };
            await saveFileSystemData(currentUser); 
            currentPath = originalCurrentPath; 
            commandHistory = originalCommandHistory; 
            historyIndex = originalHistoryIndex;

            diagPrint("-------------------------------");
            diagPrint(`Diagnostics Complete: ${passCount} PASSED, ${failCount} FAILED.`);
            diagPrint("-------------------------------");
            const finalDiagReportHTML = outputDiv.innerHTML; 

            outputDiv.innerHTML = originalOutputHTML; 
            const diagReportContainer = document.createElement('div');
            diagReportContainer.innerHTML = finalDiagReportHTML; 
            outputDiv.appendChild(diagReportContainer);

            updatePrompt();
            updateVisualInput(); 
            hiddenInput.value = ''; 
            setTimeout(() => { outputDiv.scrollTop = outputDiv.scrollHeight; }, 50); 

            isRunningDiag = false;
            window.diagInitialized = false; 
            return ""; 
        }
        async function handleTree(args) {
            const targetPathArg = args[0];
            const validation = validatePath("tree", targetPathArg, { expectedType: 'directory', defaultToCurrentIfEmpty: true });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }
            
            const outputLines = [];
            const startingDirName = validation.resolvedPath === '/' ? '/' : validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || validation.resolvedPath;
            outputLines.push(startingDirName);

            function generateTreeLinesRecursive(directoryNode, prefix) {
                const childrenNames = Object.keys(directoryNode.children).sort();
                childrenNames.forEach((name, index) => {
                    const childNode = directoryNode.children[name];
                    const isLast = index === childrenNames.length - 1;
                    const connector = isLast ? " " : " ";
                    let line = prefix + connector + name;
                    if (childNode.type === 'directory') { line += "/"; }
                    outputLines.push(line);

                    if (childNode.type === 'directory') {
                        const newPrefix = prefix + (isLast ? "    " : "   ");
                        generateTreeLinesRecursive(childNode, newPrefix);
                    }
                });
            }
            generateTreeLinesRecursive(validation.node, "");
            return outputLines.join('\n');
        }

        function matchPattern(name, pattern) {
            let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.');
            try {
                const regex = new RegExp(`^${regexPattern}$`);
                return regex.test(name);
            } catch (e) {
                appendToOutput(`find: invalid pattern regex: ${pattern}`, true);
                return false;
            }
        }
        function findRecursive(currentSearchNode, currentSearchPath, pattern, foundItems) {
            if (!currentSearchNode || currentSearchNode.type !== 'directory') { return; }

            const childrenNames = Object.keys(currentSearchNode.children).sort();
            for (const name of childrenNames) {
                const childNode = currentSearchNode.children[name];
                const childFullPath = getAbsolutePath(name, currentSearchPath);

                if (matchPattern(name, pattern)) {
                    foundItems.push(childFullPath + (childNode.type === 'directory' ? '/' : ''));
                }

                if (childNode.type === 'directory') {
                    findRecursive(childNode, childFullPath, pattern, foundItems);
                }
            }
        }
        function handleFind(args) {
            let searchPathArg = '.'; let pattern = null;
            const nameOptionIndex = args.indexOf('-name');

            if (nameOptionIndex === -1) { appendToOutput("find: usage: find [path] -name \"<pattern>\"", true); return null; }

            if (nameOptionIndex === 0) { 
                searchPathArg = '.'; 
                if (args.length < 2) { appendToOutput("find: missing pattern after -name", true); return null; }
                pattern = args[1];
            } else if (nameOptionIndex > 0) { 
                searchPathArg = args[nameOptionIndex - 1];
                if (nameOptionIndex + 1 >= args.length) { appendToOutput("find: missing pattern after -name", true); return null;}
                pattern = args[nameOptionIndex + 1];
            } else { 
                appendToOutput("find: invalid arguments for -name", true); return null;
            }


            if (pattern && pattern.length >= 2) {
                const firstChar = pattern[0]; const lastChar = pattern[pattern.length - 1];
                if ((firstChar === '"' && lastChar === '"') || (firstChar === "'" && lastChar === "'")) {
                    pattern = pattern.substring(1, pattern.length - 1);
                }
            }
            if (!pattern) { appendToOutput("find: pattern cannot be empty", true); return null; }

            const validation = validatePath("find", searchPathArg, {defaultToCurrentIfEmpty: true}); 
            if(validation.error){
                appendToOutput(validation.error, true); return null;
            }
            
            const foundItems = [];
            if (validation.node.type === 'directory') {
                findRecursive(validation.node, validation.resolvedPath, pattern, foundItems);
            } else if (validation.node.type === 'file') {
                const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1);
                if (matchPattern(fileName, pattern)) {
                    foundItems.push(validation.resolvedPath);
                }
            }
            return foundItems.length > 0 ? foundItems.join('\n') : "";
        }
        async function handleDu(args) {
            const outputLines = [];
            let pathsToProcess = args.length > 0 ? args : ['.']; 

            for (const pathArg of pathsToProcess) {
                const validation = validatePath("du", pathArg, {defaultToCurrentIfEmpty: (args.length === 0)}); 
                if (validation.error) {
                    appendToOutput(validation.error, true);
                    continue; 
                }
                
                const rawSize = calculateNodeSize(validation.node);
                const formattedSize = formatBytes(rawSize);
                let displayPath = pathArg;
                 if (validation.node.type === 'directory' && pathArg === '.') { displayPath = './'; }
                outputLines.push(`${formattedSize.padEnd(9)}\t${displayPath}`);
            }
            return outputLines.join('\n');
        }

        async function handleHead(args) {
            const defaultNumLines = 10;
            const commandName = "head";
            const options = parseNumericOption(args, "-n", defaultNumLines);
            let numLines = options.value;

            if (options.error) {
                appendToOutput(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`, false, CSS_WARNING_MSG);
            }

            const filePathArg = options.remainingArgs[0];

            if (!filePathArg && options.remainingArgs.length === 0) { 
                 appendToOutput(`${commandName}: missing file operand`, true);
                 appendToOutput(`Usage: ${commandName} [-n N] <filename>`, false, CSS_CONSOLE_LOG_MSG);
                 return null;
            }
             if (options.remainingArgs.length > 1) { 
                appendToOutput(`${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'`, true);
                return null;
            }
            
            const validation = validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            const fileContent = validation.node.content || "";
            const lines = fileContent.split('\n');
            const outputLines = lines.slice(0, numLines);

            return outputLines.join('\n');
        }

        async function handleTail(args) {
            const defaultNumLines = 10;
            const commandName = "tail";
            const options = parseNumericOption(args, "-n", defaultNumLines);
            let numLines = options.value;

            if (options.error) {
                appendToOutput(`${commandName}: ${options.error}. Using ${defaultNumLines} lines.`, false, CSS_WARNING_MSG);
            }

            const filePathArg = options.remainingArgs[0];

             if (!filePathArg && options.remainingArgs.length === 0) {
                 appendToOutput(`${commandName}: missing file operand`, true);
                 appendToOutput(`Usage: ${commandName} [-n N] <filename>`, false, CSS_CONSOLE_LOG_MSG);
                 return null;
            }
            if (options.remainingArgs.length > 1) {
                appendToOutput(`${commandName}: extraneous argument(s): '${options.remainingArgs.slice(1).join(' ')}'`, true);
                return null;
            }

            const validation = validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            const fileContent = validation.node.content || "";
            const lines = fileContent.split('\n');
            const outputLines = lines.slice(Math.max(0, lines.length - numLines));

            return outputLines.join('\n');
        }

        async function handleExport(args) {
            const filePathArg = args[0];
            if (!filePathArg) {
                appendToOutput("export: missing file operand", true);
                return null;
            }
            const validation = validatePath("export", filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });

            if (validation.error) {
                appendToOutput(validation.error, true);
                return null;
            }

            const fileName = validation.resolvedPath.substring(validation.resolvedPath.lastIndexOf('/') + 1) || 'downloaded_file.txt';
            const fileContent = validation.node.content || "";
            const mimeType = "text/plain";

            try {
                const blob = new Blob([fileContent], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                appendToOutput(`Exporting '${fileName}'... Check your browser downloads.`, false, CSS_SUCCESS_MSG);
            } catch (error) {
                console.error("Export failed:", error);
                appendToOutput(`Error exporting file '${fileName}': ${error.message}`, true);
                return null;
            }
            return null;
        }

        async function handleBackup(args) {
            const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
            const backupFileName = `oopis_backup_${currentUser}_${timestamp}.json`;

            const backupData = {
                backupVersion: "1.0",
                osVersion: OS_VERSION,
                user: currentUser,
                timestamp: new Date().toISOString(),
                filesystem: deepCopyNode(fsData),
                currentPath: currentPath,
                commandHistory: [...commandHistory],
            };

            try {
                const jsonString = JSON.stringify(backupData, null, 2);
                const blob = new Blob([jsonString], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = backupFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                appendToOutput(`Creating backup '${backupFileName}'... Check your browser downloads.`, false, CSS_SUCCESS_MSG);
            } catch (error) {
                console.error("Backup failed:", error);
                appendToOutput(`Error creating backup: ${error.message}`, true);
                return null;
            }
            return null;
        }

        async function handleImport(args) {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';

            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    appendToOutput("Import cancelled: No file selected.", false, CSS_CONSOLE_LOG_MSG);
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const fileContent = e.target.result;
                        const parsedData = JSON.parse(fileContent);

                        if (typeof parsedData !== 'object' || parsedData === null ||
                            !parsedData.hasOwnProperty('filesystem') ||
                            !parsedData.hasOwnProperty('user') ||
                            !parsedData.hasOwnProperty('currentPath') ||
                            !parsedData.hasOwnProperty('commandHistory') ||
                            !parsedData.hasOwnProperty('backupVersion')) {
                            appendToOutput("Error: Invalid backup file format. Missing essential properties.", true);
                            return;
                        }
                        if (parsedData.backupVersion !== "1.0") {
                            appendToOutput(`Warning: Backup version mismatch. Expected "1.0", got "${parsedData.backupVersion}". Attempting import anyway.`, false, CSS_WARNING_MSG);
                        }
                        
                        const dataForConfirm = { parsedData: parsedData, fileName: file.name };
                        requestConfirmation(
                            [`Backup file '${file.name}' for user '${parsedData.user}' selected.`,
                             `This will overwrite the session for user '${parsedData.user}' (if they exist) or create them if they don't. Current user's unsaved state will be lost.`],
                            dataForConfirm,
                            async (data) => { // onConfirm
                                const importedUser = data.parsedData.user;
                                if (currentUser !== DEFAULT_USER && currentUser !== importedUser && !isRunningDiag) {
                                    saveAutomaticSessionState(); 
                                }
                                currentUser = importedUser;
                                fsData = deepCopyNode(data.parsedData.filesystem) || { '/': { type: 'directory', children: {} } };
                                currentPath = data.parsedData.currentPath || '/';
                                commandHistory = Array.isArray(data.parsedData.commandHistory) ? [...data.parsedData.commandHistory] : [];
                                historyIndex = commandHistory.length;
                                outputDiv.innerHTML = ''; 
                                hiddenInput.value = ''; 
                                await saveFileSystemData(currentUser); 
                                const credentials = getUserCredentials();
                                if (!credentials[currentUser] && currentUser !== DEFAULT_USER) {
                                     appendToOutput(`Warning: User '${currentUser}' from backup does not have credentials. Session restored, but login for this user is not possible without registering.`, false, CSS_WARNING_MSG);
                                }
                                appendToOutput(`Session for user '${currentUser}' successfully imported and restored from '${data.fileName}'.`, false, CSS_SUCCESS_MSG);
                                updateVisualInput();
                                updatePrompt();
                                outputDiv.scrollTop = outputDiv.scrollHeight;
                            },
                            () => { // onCancel
                                appendToOutput("Import cancelled.", false, CSS_CONSOLE_LOG_MSG);
                            }
                        );

                    } catch (parseError) {
                        console.error("Import error - parsing JSON:", parseError);
                        appendToOutput("Error: Could not parse backup file. Ensure it is a valid JSON.", true);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Import error - reading file:", e);
                    appendToOutput("Error: Could not read the selected file.", true);
                };
                reader.readAsText(file);
            };

            fileInput.click();
            return null;
        }

        async function handleWc(args) {
            const commandName = "wc";
            let showLines = false;
            let showWords = false;
            let showBytes = false;
            let optionsSpecified = false;

            const tempArgs = [...args]; 
            const filesToProcess = [];

            while (tempArgs.length > 0 && tempArgs[0].startsWith('-')) {
                const option = tempArgs.shift(); 
                optionsSpecified = true;
                for (const char of option.substring(1)) { 
                    switch (char) {
                        case 'l': showLines = true; break;
                        case 'w': showWords = true; break;
                        case 'c': showBytes = true; break;
                        default:
                            appendToOutput(`${commandName}: invalid option -- '${char}'`, true);
                            appendToOutput(`Usage: ${commandName} [-lwc] [file...]`, false, CSS_CONSOLE_LOG_MSG);
                            return null;
                    }
                }
            }
            
            filesToProcess.push(...tempArgs);

            if (filesToProcess.length === 0) {
                appendToOutput(`${commandName}: missing file operand`, true);
                appendToOutput(`Usage: ${commandName} [-lwc] [file...]`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const defaultAll = !optionsSpecified;

            let totalLines = 0;
            let totalWords = 0;
            let totalBytes = 0;
            const outputResults = [];
            let allFilesValid = true;

            for (const filePathArg of filesToProcess) {
                const validation = validatePath(commandName, filePathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
                if (validation.error) {
                    appendToOutput(validation.error, true);
                    allFilesValid = false; 
                    continue; 
                }

                const fileContent = validation.node.content || "";
                
                let lineCountForDisplay;
                const newlineOnlyCount = (fileContent.match(/\n/g) || []).length;

                if (showLines && optionsSpecified) { 
                    lineCountForDisplay = newlineOnlyCount;
                } else { 
                    lineCountForDisplay = newlineOnlyCount;
                    if (fileContent.length > 0 && !fileContent.endsWith('\n')) {
                        lineCountForDisplay++;
                    }
                }
                if (fileContent === "") lineCountForDisplay = 0; 


                const words = fileContent.trim() === "" ? 0 : fileContent.trim().split(/\s+/).filter(Boolean).length;
                const bytes = fileContent.length;

                totalLines += lineCountForDisplay; 
                totalWords += words;
                totalBytes += bytes;

                let resultLine = "";
                if (showLines || defaultAll) resultLine += `${String(lineCountForDisplay).padStart(7)} `;
                if (showWords || defaultAll) resultLine += `${String(words).padStart(7)} `;
                if (showBytes || defaultAll) resultLine += `${String(bytes).padStart(7)} `;
                resultLine += filePathArg;
                outputResults.push(resultLine);
            }

            if (filesToProcess.length > 1 && allFilesValid) { 
                let totalLineStr = "";
                if (showLines || defaultAll) totalLineStr += `${String(totalLines).padStart(7)} `;
                if (showWords || defaultAll) totalLineStr += `${String(totalWords).padStart(7)} `;
                if (showBytes || defaultAll) totalLineStr += `${String(totalBytes).padStart(7)} `;
                totalLineStr += "total";
                outputResults.push(totalLineStr);
            }
            
            return outputResults.join('\n');
        }

        async function handleDiff(args) {
            const commandName = "diff";
            if (args.length !== 2) {
                appendToOutput(`${commandName}: missing operand. Requires two file arguments.`, true);
                appendToOutput(`Usage: ${commandName} <file1> <file2>`, false, CSS_CONSOLE_LOG_MSG);
                return null;
            }

            const file1PathArg = args[0];
            const file2PathArg = args[1];

            const validation1 = validatePath(commandName, file1PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
            if (validation1.error) {
                appendToOutput(validation1.error, true);
                return null;
            }

            const validation2 = validatePath(commandName, file2PathArg, { expectedType: 'file', defaultToCurrentIfEmpty: false });
            if (validation2.error) {
                appendToOutput(validation2.error, true);
                return null;
            }

            const lines1 = (validation1.node.content || "").split('\n');
            const lines2 = (validation2.node.content || "").split('\n');

            const lcsArray = findLCS(lines1, lines2);
            
            let ptr1 = 0, ptr2 = 0, ptrLcs = 0;
            const diffOutput = [];
            let differencesFound = false;

            while (ptr1 < lines1.length || ptr2 < lines2.length) {
                const line1Exists = ptr1 < lines1.length;
                const line2Exists = ptr2 < lines2.length;
                const lcsExists = ptrLcs < lcsArray.length;

                if (lcsExists && line1Exists && lines1[ptr1] === lcsArray[ptrLcs] && line2Exists && lines2[ptr2] === lcsArray[ptrLcs]) {
                    ptr1++; ptr2++; ptrLcs++;
                } else {
                     differencesFound = true; 
                    if (line1Exists && (!lcsExists || lines1[ptr1] !== lcsArray[ptrLcs])) {
                        if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                            diffOutput.push(`< ${lines1[ptr1]}`);
                            diffOutput.push(`> ${lines2[ptr2]}`);
                            ptr1++;
                            ptr2++;
                        } else { 
                            diffOutput.push(`< ${lines1[ptr1]}`);
                            ptr1++;
                        }
                    } else if (line2Exists && (!lcsExists || lines2[ptr2] !== lcsArray[ptrLcs])) {
                        diffOutput.push(`> ${lines2[ptr2]}`);
                        ptr2++;
                    } else { 
                         if (ptr1 < lines1.length) { diffOutput.push(`< ${lines1[ptr1]}`); ptr1++; }
                         else if (ptr2 < lines2.length) { diffOutput.push(`> ${lines2[ptr2]}`); ptr2++; }
                         else { break; } 
                    }
                }
            }
            
            return differencesFound ? diffOutput.join('\n') : "";
        }

        async function handleHistory(args) {
            if (commandHistory.length === 0) {
                return "No commands in history.";
            }
            return commandHistory.map((cmd, index) => `  ${String(index + 1).padStart(3)}  ${cmd}`).join('\n');
        }

        async function handleAlias(args) {
            const commandName = "alias";
            if (args.length === 0) { // List all aliases
                if (Object.keys(userAliases).length === 0) {
                    return "No aliases defined.";
                }
                const output = [];
                for (const name in userAliases) {
                    // Properly quote the value if it contains spaces or special characters
                    let value = userAliases[name];
                    if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                        value = `'${value.replace(/'/g, "'\\''")}'`; // Basic shell-like quoting
                    }
                    output.push(`${name}=${value}`);
                }
                return output.join('\n');
            }

            const firstArg = args.join(" "); // Rejoin args to handle 'name=value' or 'name="value with spaces"'
            const assignmentIndex = firstArg.indexOf('=');

            if (assignmentIndex === -1) { // Display specific alias or error
                const aliasName = args[0];
                if (userAliases.hasOwnProperty(aliasName)) {
                    let value = userAliases[aliasName];
                     if (value.includes(' ') || value.includes("'") || value.includes('"') || value.includes("=") || value.includes("#")) {
                        value = `'${value.replace(/'/g, "'\\''")}'`;
                    }
                    return `alias ${aliasName}=${value}`;
                } else {
                    appendToOutput(`${commandName}: ${aliasName}: not found`, true);
                    return null;
                }
            } else { // Define or unset an alias
                const aliasName = firstArg.substring(0, assignmentIndex).trim();
                let commandString = firstArg.substring(assignmentIndex + 1).trim();

                if (!aliasName) {
                    appendToOutput(`${commandName}: invalid alias name.`, true);
                    return null;
                }
                if (aliasName.includes(" ")) {
                     appendToOutput(`${commandName}: alias name cannot contain spaces.`, true);
                     return null;
                }
                 // Prevent aliasing to existing commands for now to avoid simple footguns
                if (commandRegistry.hasOwnProperty(aliasName) && aliasName !== "alias" && aliasName !== "unalias") {
                    appendToOutput(`${commandName}: '${aliasName}' is a built-in command. Cannot create alias.`, true);
                    return null;
                }


                // Unset alias if commandString is empty after '='
                if (commandString === "") {
                    if (userAliases.hasOwnProperty(aliasName)) {
                        delete userAliases[aliasName];
                        await saveAliases();
                        // appendToOutput(`${commandName}: ${aliasName} unset.`, false, CSS_CONSOLE_LOG_MSG); // Optional feedback
                    } else {
                        // appendToOutput(`${commandName}: ${aliasName}: not found, nothing to unset.`, false, CSS_CONSOLE_LOG_MSG); // Optional
                    }
                    return null;
                }

                // Strip outer quotes from commandString
                if ((commandString.startsWith("'") && commandString.endsWith("'")) ||
                    (commandString.startsWith('"') && commandString.endsWith('"'))) {
                    commandString = commandString.substring(1, commandString.length - 1);
                }
                
                // Prevent direct self-referential alias
                if (aliasName === commandString.split(' ')[0]) {
                    appendToOutput(`${commandName}: cannot alias '${aliasName}' to itself directly.`, true);
                    return null;
                }


                userAliases[aliasName] = commandString;
                await saveAliases();
                return null; // No output on successful definition
            }
        }

        async function handleUnalias(args) {
            const commandName = "unalias";
            if (args.length !== 1) {
                appendToOutput(`${commandName}: usage: unalias <name>`, true);
                return null;
            }
            const aliasName = args[0];
            if (userAliases.hasOwnProperty(aliasName)) {
                delete userAliases[aliasName];
                await saveAliases();
                // appendToOutput(`${commandName}: ${aliasName} removed.`, false, CSS_CONSOLE_LOG_MSG); // Optional
            } else {
                appendToOutput(`${commandName}: ${aliasName}: not found`, true);
            }
            return null;
        }


        // --- Command Registry ---
        const commandRegistry = {
            'ls': handleLs, 'cd': handleCd, 'mkdir': handleMkdir, 'touch': handleTouch,
            'cat': handleCat, 'echo': handleEcho, 'rm': handleRm, 'pwd': handlePwd,
            'date': handleDate, 'whoami': handleWhoami, 'run': handleRun, 'grep': handleGrep,
            'sort': handleSort,
            'sysmon': handleSysmon,
            'mv': handleMv, 'cp': handleCp,
            'clear': handleClear,
            'register': handleRegister, 'login': handleLogin, 'logout': handleLogout,
            'savestate': handleManualSaveState, 'loadstate': handleManualLoadState,
            'reset': handleReset, 'help': handleHelp, 'man': handleMan,
            'edit': handleEdit,
            'diag': handleDiag,
            'tree': handleTree,
            'find': handleFind,
            'du': handleDu,
            'head': handleHead,
            'tail': handleTail,
            'export': handleExport,
            'backup': handleBackup,
            'import': handleImport,
            'wc': handleWc,
            'diff': handleDiff,
            'history': handleHistory,
            'alias': handleAlias, // NEW
            'unalias': handleUnalias // NEW
        };

        // --- UI Update Functions ---
        function updatePrompt() {
            promptUserSpan.textContent = currentUser;
            promptHostSpan.textContent = OS_NAME;
            promptPathSpan.textContent = currentPath.trim() === '' ? '/' : currentPath;
        }

        // --- Command Processing ---
        async function processCommand(commandInputText, isInteractive = true) {
            if (isEditingFile && !isRunningDiag) return { commandSuccessful: true, output: null, lastCommandFailed: false }; 
            lastCommandFailed = false;
            let commandSuccessful = true;
            let commandOutput = null; 

            let processedCommandText = await expandAlias(commandInputText.trim()); // Expand aliases first
            const trimmedCommand = processedCommandText; // Use the (potentially expanded) command

            if (isInteractive && !isRunningDiag) {
                let displayCommand = commandInputText.trim(); // Show original user input
                if (isPasswordInputActive && passwordMaskStartIndex !== -1 && displayCommand.length > passwordMaskStartIndex) {
                    const prefix = displayCommand.substring(0, passwordMaskStartIndex);
                    const suffixToMask = displayCommand.substring(passwordMaskStartIndex);
                    displayCommand = prefix + '*'.repeat(suffixToMask.length);
                }
                const promptText = `${promptUserSpan.textContent}@${promptHostSpan.textContent}:${promptPathSpan.textContent}> `;
                appendToOutput(`${promptText}${displayCommand}`);
                if (commandInputText.trim() !== trimmedCommand) { // If alias was expanded, show what ran
                    appendToOutput(`> ${trimmedCommand}`, false, CSS_CONSOLE_LOG_MSG);
                }

            } else if (!isInteractive && !isRunningDiag && trimmedCommand) {
                 appendToOutput(`> ${trimmedCommand}`);
            }


            if (isInteractive && commandInputText.trim() && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== commandInputText.trim())) {
                commandHistory.push(commandInputText.trim()); // Store original command in history
                if (commandHistory.length > MAX_HISTORY_SIZE) commandHistory.shift();
            }
            if (isInteractive) {
                if (!isNavigatingHistory) {
                    historyIndex = commandHistory.length;
                }
            }

            if (awaitingConfirmation) {
                if (trimmedCommand === 'YES' && confirmationContext && typeof confirmationContext.onConfirm === 'function') {
                    await confirmationContext.onConfirm(confirmationContext.data);
                } else {
                    if (confirmationContext && typeof confirmationContext.onCancel === 'function') {
                        confirmationContext.onCancel(confirmationContext.data);
                    } else {
                        appendToOutput("Operation cancelled.", false, CSS_CONSOLE_LOG_MSG);
                    }
                }
                awaitingConfirmation = false;
                confirmationContext = null;
            } else { 
                let commandToExecute = trimmedCommand; // Already expanded
                let redirectionType = null;
                let redirectionFile = null;

                const appendMatch = commandToExecute.match(/\s+>>\s+(\S+)$/);
                if (appendMatch) {
                    redirectionType = 'append';
                    redirectionFile = appendMatch[1];
                    commandToExecute = commandToExecute.substring(0, appendMatch.index).trim();
                } else {
                    const overwriteMatch = commandToExecute.match(/\s+>\s+(\S+)$/);
                    if (overwriteMatch) {
                        redirectionType = 'overwrite';
                        redirectionFile = overwriteMatch[1];
                        commandToExecute = commandToExecute.substring(0, overwriteMatch.index).trim();
                    }
                }


                if (commandToExecute !== '') {
                    const parts = commandToExecute.split(' ').filter(p => p);
                    const baseCommand = parts[0].toLowerCase();
                    let args;

                    // Special handling for 'alias' command arguments due to 'name=value' format
                    if (baseCommand === 'alias' && commandToExecute.includes('=')) {
                        args = [commandToExecute.substring(baseCommand.length).trimStart()];
                    } else if (['echo', 'find', 'grep', 'head', 'tail', 'export', 'backup', 'import', 'wc', 'diff', 'history', 'alias', 'unalias'].includes(baseCommand)) { 
                        args = parts.slice(1);
                    }
                    else {
                        args = parts.slice(1);
                    }


                    const handler = commandRegistry[baseCommand];
                    if (handler) {
                        try {
                            commandOutput = await handler(args); 
                            if (lastCommandFailed) commandSuccessful = false;

                            if (redirectionType && redirectionFile) {
                                if (!await handleRedirection(baseCommand, commandOutput, redirectionType, redirectionFile)) {
                                    commandSuccessful = false; 
                                }
                            } else if (commandOutput !== null && commandOutput !== undefined && !isRunningDiag) { // Don't output if diag is running and not redirecting
                                const lines = String(commandOutput).split('\n');
                                lines.forEach(line => {
                                    if (baseCommand === 'man' || baseCommand === 'sysmon') { /* Already handled by appendHtmlToOutput */ }
                                    else if (baseCommand === 'ls' && line.endsWith('/')) { appendToOutput(line, false, CSS_DIR_ITEM); }
                                    else { appendToOutput(line); }
                                });
                            }
                            if(lastCommandFailed) commandSuccessful = false;

                        } catch (e) {
                            console.error(`Error in '${baseCommand}':`, e);
                            if (!isRunningDiag) {
                                appendToOutput(`Unexpected error executing '${baseCommand}'. Check console.`, true);
                            } else {
                                appendToOutput(`  ERROR in '${baseCommand}': ${e.message}`, true, 'diag-output');
                            }
                            commandSuccessful = false;
                        }
                    } else {
                         if (!isRunningDiag) {
                            appendToOutput(`Error: Command not found: "${parts[0]}"`, true);
                        } else {
                            appendToOutput(`  ERROR: Command not found: "${parts[0]}"`, true, 'diag-output');
                        }
                        commandSuccessful = false;
                    }
                } else if (trimmedCommand === '') {
                    commandSuccessful = true;
                    lastCommandFailed = false;
                }
            }

            if (isInteractive && !isRunningDiag) {
                hiddenInput.value = '';
                isPasswordInputActive = false; passwordMaskStartIndex = -1;
                updateVisualInput();
            }

            if (!isInteractive) {
                return {
                    output: (commandOutput === null || commandOutput === undefined) ? null : String(commandOutput),
                    lastCommandFailed: lastCommandFailed,
                    commandSuccessful: commandSuccessful && !lastCommandFailed
                };
            }

            if (!isEditingFile && !awaitingConfirmation && !isRunningDiag) {
                updatePrompt();
            }
            return commandSuccessful;
        }

        // --- Event Listeners ---
        terminalDiv.addEventListener('click', e => {
            if (isEditingFile) {
                if (editorTextareaElement && editorWrapperDiv && editorWrapperDiv.contains(e.target) && e.target !== editorTextareaElement) {
                     editorTextareaElement.focus();
                }
                return;
            }
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A' && !e.target.closest('#visual-input-container')) {
                hiddenInput.focus();
            }
            if (e.target.closest('.input-line') || e.target.id === 'terminal') {
                 hiddenInput.focus();
            }
        });

        hiddenInput.addEventListener('keydown', async e => {
            if (isEditingFile) { e.preventDefault(); return; }
            isNavigatingHistory = false;

            if (e.key === 'Enter') {
                e.preventDefault();
                await processCommand(hiddenInput.value, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex > 0) {
                    isNavigatingHistory = true;
                    historyIndex--;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                    isNavigatingHistory = true;
                    historyIndex++;
                    hiddenInput.value = commandHistory[historyIndex];
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    setTimeout(() => { const len = hiddenInput.value.length; hiddenInput.setSelectionRange(len, len); hiddenInput.focus(); }, 0);
                } else if (historyIndex >= commandHistory.length - 1) {
                    isNavigatingHistory = true;
                    historyIndex = commandHistory.length;
                    hiddenInput.value = "";
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
            } else if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'Backspace', 'Delete'].includes(e.key)) {
                setTimeout(() => hiddenInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })), 0);
            }
        });

        hiddenInput.addEventListener('input', (event) => {
            if (isEditingFile) return;

            const rawInput = hiddenInput.value;
            isPasswordInputActive = false;
            passwordMaskStartIndex = -1;

            const passwordCommandRegex = /^(login|register)(\s+)(\S+)(\s+)(.*)$/i;
            const match = rawInput.match(passwordCommandRegex);

            if (match) {
                passwordMaskStartIndex = match[1].length + match[2].length + match[3].length + match[4].length;
                isPasswordInputActive = true;
            } else {
                const prefixRegex = /^(login|register)(\s+)(\S+)$/i;
                const prefixMatch = rawInput.match(prefixRegex);
                if (prefixMatch && rawInput.endsWith(' ')) {
                    isPasswordInputActive = true;
                    passwordMaskStartIndex = rawInput.length;
                }
            }
            updateVisualInput();

            if (!isNavigatingHistory) {
                 historyIndex = commandHistory.length;
            }
        });


        // --- Initialization ---
        window.onload = async () => {
            console.warn("SECURITY NOTE: User credentials (still in localStorage) are NOT fully secure in this demo. Filesystem now in IndexedDB.");
            try {
                await initDB();
                currentUser = DEFAULT_USER;
                await loadFileSystemData(currentUser); // This now also calls loadAliases
                // loadAutomaticSessionState is called after FS and aliases are loaded
                loadAutomaticSessionState(currentUser);

                setTimeout(() => { if (!isEditingFile) hiddenInput.focus(); }, 100);
                console.log(`${OS_NAME} v.${OS_VERSION} loaded. Welcome!`);
            } catch (error) {
                console.error("Failed to initialize OopisOs on load:", error);
                appendToOutput("FATAL ERROR: OopisOs could not start. Check console for details.", true);
                hiddenInput.disabled = true;
            }
        };
    </script></body>
</html>
